{"notes":[{"tddate":null,"ddate":null,"tmdate":1512222653308,"tcdate":1512198307965,"number":3,"cdate":1512198307965,"id":"SynixA1WM","invitation":"ICLR.cc/2018/Conference/-/Paper439/Official_Review","forum":"r1hsJCe0Z","replyto":"r1hsJCe0Z","signatures":["ICLR.cc/2018/Conference/Paper439/AnonReviewer2"],"readers":["everyone"],"content":{"title":"Cool application of neural nets to bug repair, but only in 4 special cases","rating":"6: Marginally above acceptance threshold","review":"This paper describes the application of a neural network architecture, called Share, Specialize, and Compete, to the problem of automatically generating big fixes when the bugs fall into 4 specific categories. The approach is validated using both real and injected bugs based on a software corpus of 19,000 github projects implemented in python. The model achieves performance that is noticeably better than human experts.\n\nThis paper is well-written and nicely organized. The technical approach is described in sufficient detail, and supported with illustrative examples. Most importantly, the problem tackled is ambitious and of significance to the software engineering community.\n\nTo me the major shortcoming of the model is that the analysis focuses only on 4 specific types of semantic bugs. In practice, this is a minute fraction of what can actually go wrong when writing code. And while the high performance achieved on these 4 bugs is noteworthy, the fact that the baseline compared against is more generic weakens the contribution. The authors should address this potential limitation.  I would also be curious to see performance comparisons to recent rule-based and statistical techniques.\n\nOverall this is a nice paper with very promising results, but I believe addressing some of the above weaknesses (with experimental results, where possible) would make it an excellent paper.\n\n","confidence":"4: The reviewer is confident but not absolutely certain that the evaluation is correct"},"writers":[],"nonreaders":[],"replyCount":0,"writable":false,"revisions":false,"tags":[],"forumContent":{"title":"Semantic Code Repair using Neuro-Symbolic Transformation Networks","abstract":"We study the problem of semantic code repair, which can be broadly defined as automatically fixing non-syntactic bugs in source code. The majority of past work in semantic code repair assumed access to unit tests against which candidate repairs could be validated. In contrast, the goal here is to develop a strong statistical model to accurately predict both bug locations and exact fixes without access to information about the intended correct behavior of the program. Achieving such a goal requires a robust contextual repair model, which we train on a large corpus of real-world source code that has been augmented with synthetically injected bugs. Our framework adopts a two-stage approach where first a large set of repair candidates are generated by rule-based processors, and then these candidates are scored by a statistical model using a novel neural network architecture which we refer to as Share, Specialize, and Compete. Specifically, the architecture (1) generates a  shared encoding of the source code using an RNN over the abstract syntax tree, (2) scores each candidate repair using specialized network modules, and (3) then normalizes these scores together so they can compete against one another in comparable probability space. We evaluate our model on a real-world test set gathered from GitHub containing four common categories of bugs. Our model is able to predict the exact correct repair 41% of the time with a single guess, compared to 13% accuracy for an attentional sequence-to-sequence model.","pdf":"/pdf/7150529f3edbb412d0b0a7b4ff06b2a2bb01dd9e.pdf","TL;DR":"A neural architecture for scoring and ranking program repair candidates to perform semantic program repair statically without access to unit tests.","paperhash":"anonymous|semantic_code_repair_using_neurosymbolic_transformation_networks","_bibtex":"@article{\n  anonymous2018semantic,\n  title={Semantic Code Repair using Neuro-Symbolic Transformation Networks},\n  author={Anonymous},\n  journal={International Conference on Learning Representations},\n  year={2018},\n  url={https://openreview.net/forum?id=r1hsJCe0Z}\n}","authors":["Anonymous"],"authorids":["ICLR.cc/2018/Conference/Paper439/Authors"],"keywords":["semantic program repair","neural program embeddings","deep learning"]}},{"tddate":null,"ddate":null,"tmdate":1512222653352,"tcdate":1511854093423,"number":2,"cdate":1511854093423,"id":"SkSfxq9xM","invitation":"ICLR.cc/2018/Conference/-/Paper439/Official_Review","forum":"r1hsJCe0Z","replyto":"r1hsJCe0Z","signatures":["ICLR.cc/2018/Conference/Paper439/AnonReviewer3"],"readers":["everyone"],"content":{"title":"Interesting and challenging application with impressive results, but maybe a bit narrowly focused in its scope. ","rating":"6: Marginally above acceptance threshold","review":"This paper introduces a neural network architecture for fixing semantic bugs in code.  Focusing on four specific types of bugs, the proposed two-stage approach first generates a set of candidate repairs and then scores the repair candidates using a neural network trained on synthetically introduced bug/repair examples. Comparing to a prior sequence-to-sequence approach, the proposed approach achieved dominantly better accuracy on both synthetic and real bug datasets. On a real bug dataset constructed from GitHub commits, it was shown to outperform human. \n\nI find the application of neural networks to the problem of code repair to be highly interesting. The proposed approach is highly specialized for the specific four types of bugs considered here and appears to be effective for fixing these specific bug types, especially in comparison to the sequence-to-sequence model based approach.  However, I was wondering whether limiting the output choices (based on the bug type)  is going a long way toward improving the performance compared to seq-2-seq, which does not utilize such output constraints.  What if we introduce the same type of constraints for the seq-2-seq model? For example, one can simply modifying the decoding process such that for locations that are not in the candidate set, the network simply  makes no change, and for candidate-repair locations, the output space is limited to the specific choices provided in the candidate set.  This will provide a more fair comparison between the different models. \nRight now it is not clear how much of the observed performance gain is due to the use of these constraints on the output space. \n\nIs there any control mechanism used to ensure that the real bug test set do not overlap with the training set? This is not clear to me. \n\nI find the comparison result to human performance to be interesting and somewhat surprising. This seems quite impressive.  The presented example  where human makes a mistake but the algorithm is correct is informative and provides some potential explanation to this. But it also raises a question. The specific example snippet could be considered to be correct when placed in a different context.  Bugs are context sensitive artifacts. The setup of considering each function independently without any context seems like an inherent limitation in the types of bugs that this method could potentially address.  Some discussion on the limitation of the proposed method seems to be warranted. \n\n\n\n\nPro:\nInteresting application \nImpressive results on a difficult task\nNice discussion of results and informative examples\nClear presentation, easy to read.\n\nCon: \nThe comparison to baseline seq-2-seq does not seem quite fair\nThe method appears to be highly specialized to the four bug types. It is not clear how generalizable it will be to more complex bugs, and to the real application scenarios where we are dealing with open world classification and there is not fixed set of possible bugs. \n","confidence":"4: The reviewer is confident but not absolutely certain that the evaluation is correct"},"writers":[],"nonreaders":[],"replyCount":0,"writable":false,"revisions":false,"tags":[],"forumContent":{"title":"Semantic Code Repair using Neuro-Symbolic Transformation Networks","abstract":"We study the problem of semantic code repair, which can be broadly defined as automatically fixing non-syntactic bugs in source code. The majority of past work in semantic code repair assumed access to unit tests against which candidate repairs could be validated. In contrast, the goal here is to develop a strong statistical model to accurately predict both bug locations and exact fixes without access to information about the intended correct behavior of the program. Achieving such a goal requires a robust contextual repair model, which we train on a large corpus of real-world source code that has been augmented with synthetically injected bugs. Our framework adopts a two-stage approach where first a large set of repair candidates are generated by rule-based processors, and then these candidates are scored by a statistical model using a novel neural network architecture which we refer to as Share, Specialize, and Compete. Specifically, the architecture (1) generates a  shared encoding of the source code using an RNN over the abstract syntax tree, (2) scores each candidate repair using specialized network modules, and (3) then normalizes these scores together so they can compete against one another in comparable probability space. We evaluate our model on a real-world test set gathered from GitHub containing four common categories of bugs. Our model is able to predict the exact correct repair 41% of the time with a single guess, compared to 13% accuracy for an attentional sequence-to-sequence model.","pdf":"/pdf/7150529f3edbb412d0b0a7b4ff06b2a2bb01dd9e.pdf","TL;DR":"A neural architecture for scoring and ranking program repair candidates to perform semantic program repair statically without access to unit tests.","paperhash":"anonymous|semantic_code_repair_using_neurosymbolic_transformation_networks","_bibtex":"@article{\n  anonymous2018semantic,\n  title={Semantic Code Repair using Neuro-Symbolic Transformation Networks},\n  author={Anonymous},\n  journal={International Conference on Learning Representations},\n  year={2018},\n  url={https://openreview.net/forum?id=r1hsJCe0Z}\n}","authors":["Anonymous"],"authorids":["ICLR.cc/2018/Conference/Paper439/Authors"],"keywords":["semantic program repair","neural program embeddings","deep learning"]}},{"tddate":null,"ddate":null,"tmdate":1512222653393,"tcdate":1511804991316,"number":1,"cdate":1511804991316,"id":"rJvBlRteG","invitation":"ICLR.cc/2018/Conference/-/Paper439/Official_Review","forum":"r1hsJCe0Z","replyto":"r1hsJCe0Z","signatures":["ICLR.cc/2018/Conference/Paper439/AnonReviewer1"],"readers":["everyone"],"content":{"title":"This paper presents a neural network architecture for program repair. Although this paper contains several strong points, the weaknesses of this paper are also very obvious.","rating":"4: Ok but not good enough - rejection","review":"This paper presents a neural network architecture consisting of the share, specialize and compete parts for repairing code in four cases, i.e., VarReplace, CompReplace, IsSwap, and ClassMember. Experiments on the source codes from Github are conducted and the performance is evaluated against one sequence-to-sequence baseline method.\n\nPros:\n\n* The problem studied in this paper is of practical significance. \n* The proposed approach is technically sound in general. The paper is well-written and easy to follow.\n\nCons:\n\n* The scope of this paper is narrow. This paper can only repair the program in the four special cases. It leads to a natural question that how many other cases besides the four? It seems that even if the proposed method works pretty well in practice, it would not be very useful since it is effective to only 4 out of a huge number of cases that a program could be wrong.\n\n* Although the proposed architecture is specially designed for this problem, the components are a straight-forward application of existing approaches. E.g., The SHARE component that using bidirectional LSTM to encode from AST has been studied before and the specialized network has been studied in (Andreas et al., 2016).  This reduces the novelty and technical contribution of this paper.\n\n* Many technical details have not been well-explained. For example, how to determine the number of candidates m, since different snippets may have different number of candidates? How to train the model? What is the loss function?\n\n* The experiments are weak. 1) the state-of-the-art program repair approaches such as the statistical program repair models (Arcuri and Yao, 2008) (Goues et al., 2012), Rule-Based Static Analyzers (Thenault, 2001) (PyCQA, 2012) should be compared. 2) the comparsion between SSC with and Seq-to-Seq is not fair, since the baseline is more general and not specially crafted for these 4 cases.\n","confidence":"4: The reviewer is confident but not absolutely certain that the evaluation is correct"},"writers":[],"nonreaders":[],"replyCount":0,"writable":false,"revisions":false,"tags":[],"forumContent":{"title":"Semantic Code Repair using Neuro-Symbolic Transformation Networks","abstract":"We study the problem of semantic code repair, which can be broadly defined as automatically fixing non-syntactic bugs in source code. The majority of past work in semantic code repair assumed access to unit tests against which candidate repairs could be validated. In contrast, the goal here is to develop a strong statistical model to accurately predict both bug locations and exact fixes without access to information about the intended correct behavior of the program. Achieving such a goal requires a robust contextual repair model, which we train on a large corpus of real-world source code that has been augmented with synthetically injected bugs. Our framework adopts a two-stage approach where first a large set of repair candidates are generated by rule-based processors, and then these candidates are scored by a statistical model using a novel neural network architecture which we refer to as Share, Specialize, and Compete. Specifically, the architecture (1) generates a  shared encoding of the source code using an RNN over the abstract syntax tree, (2) scores each candidate repair using specialized network modules, and (3) then normalizes these scores together so they can compete against one another in comparable probability space. We evaluate our model on a real-world test set gathered from GitHub containing four common categories of bugs. Our model is able to predict the exact correct repair 41% of the time with a single guess, compared to 13% accuracy for an attentional sequence-to-sequence model.","pdf":"/pdf/7150529f3edbb412d0b0a7b4ff06b2a2bb01dd9e.pdf","TL;DR":"A neural architecture for scoring and ranking program repair candidates to perform semantic program repair statically without access to unit tests.","paperhash":"anonymous|semantic_code_repair_using_neurosymbolic_transformation_networks","_bibtex":"@article{\n  anonymous2018semantic,\n  title={Semantic Code Repair using Neuro-Symbolic Transformation Networks},\n  author={Anonymous},\n  journal={International Conference on Learning Representations},\n  year={2018},\n  url={https://openreview.net/forum?id=r1hsJCe0Z}\n}","authors":["Anonymous"],"authorids":["ICLR.cc/2018/Conference/Paper439/Authors"],"keywords":["semantic program repair","neural program embeddings","deep learning"]}},{"tddate":null,"ddate":null,"tmdate":1509739303410,"tcdate":1509117860430,"number":439,"cdate":1509739300752,"id":"r1hsJCe0Z","invitation":"ICLR.cc/2018/Conference/-/Blind_Submission","forum":"r1hsJCe0Z","signatures":["ICLR.cc/2018/Conference"],"readers":["everyone"],"writers":["ICLR.cc/2018/Conference"],"content":{"title":"Semantic Code Repair using Neuro-Symbolic Transformation Networks","abstract":"We study the problem of semantic code repair, which can be broadly defined as automatically fixing non-syntactic bugs in source code. The majority of past work in semantic code repair assumed access to unit tests against which candidate repairs could be validated. In contrast, the goal here is to develop a strong statistical model to accurately predict both bug locations and exact fixes without access to information about the intended correct behavior of the program. Achieving such a goal requires a robust contextual repair model, which we train on a large corpus of real-world source code that has been augmented with synthetically injected bugs. Our framework adopts a two-stage approach where first a large set of repair candidates are generated by rule-based processors, and then these candidates are scored by a statistical model using a novel neural network architecture which we refer to as Share, Specialize, and Compete. Specifically, the architecture (1) generates a  shared encoding of the source code using an RNN over the abstract syntax tree, (2) scores each candidate repair using specialized network modules, and (3) then normalizes these scores together so they can compete against one another in comparable probability space. We evaluate our model on a real-world test set gathered from GitHub containing four common categories of bugs. Our model is able to predict the exact correct repair 41% of the time with a single guess, compared to 13% accuracy for an attentional sequence-to-sequence model.","pdf":"/pdf/7150529f3edbb412d0b0a7b4ff06b2a2bb01dd9e.pdf","TL;DR":"A neural architecture for scoring and ranking program repair candidates to perform semantic program repair statically without access to unit tests.","paperhash":"anonymous|semantic_code_repair_using_neurosymbolic_transformation_networks","_bibtex":"@article{\n  anonymous2018semantic,\n  title={Semantic Code Repair using Neuro-Symbolic Transformation Networks},\n  author={Anonymous},\n  journal={International Conference on Learning Representations},\n  year={2018},\n  url={https://openreview.net/forum?id=r1hsJCe0Z}\n}","authors":["Anonymous"],"authorids":["ICLR.cc/2018/Conference/Paper439/Authors"],"keywords":["semantic program repair","neural program embeddings","deep learning"]},"nonreaders":[],"replyCount":3,"writable":false,"revisions":false,"tags":[],"forumContent":null,"tauthor":"ICLR.cc/2018/Conference"}],"limit":2000,"offset":0}