Under review as a conference paper at ICLR 2018
NOT-SO-RANDOM FEATURES
Anonymous authors Paper under double-blind review
ABSTRACT
We propose a principled method for kernel learning, which relies on a Fourieranalytic characterization of translation-invariant or rotation-invariant kernels. Our method produces a sequence of feature maps, iteratively refining the SVM margin. We provide rigorous guarantees for optimality and generalization, interpreting our algorithm as online equilibrium-finding dynamics in a certain two-player min-max game. Evaluations on synthetic and real-world datasets demonstrate scalability and consistent improvements over related random features-based methods.
1 INTRODUCTION
Choosing the right kernel is a classic question that has riddled machine learning practitioners and theorists alike. Conventional wisdom instructs the user to select a kernel which captures the structure and geometric invariances in the data. Efforts to formulate this principle have inspired vibrant areas of study, going by names from feature selection to multiple kernel learning (MKL).
We present a new, principled approach for selecting a translation-invariant or rotation-invariant kernel to maximize the SVM classification margin. We first describe a kernel-alignment subroutine, which finds a peak in the Fourier transform of a certain data-dependent measure. Then, we define an iterative procedure that produces a sequence of feature maps, progressively improving the margin. The resulting algorithm is strikingly simple and scalable.
Intriguingly, our analysis interprets the main algorithm as no-regret learning dynamics in a zero-sum min-max game, whose value is the classification margin. Thus, we are able to quantify convergence guarantees towards the largest margin realizable by a kernel with the assumed invariance. Finally, we exhibit experiments on synthetic and benchmark datasets, demonstrating consistent improvements over related random features-based kernel methods.
1.1 RELATED WORK
There is a vast literature on MKL, from which we use the key concept of kernel alignment (Cristianini et al., 2002). Otherwise, our work bears few similarities to traditional MKL; this and much related work (e.g. Cortes et al. (2012); Go¨nen & Alpaydin (2011); Lanckriet et al. (2004)) are concerned with selecting a kernel by combining a collection of base kernels, chosen beforehand. Our method allows for greater expressivity and even better generalization guarantees.
Instead, we take inspiration from the method of random features (Rahimi & Recht, 2007). In this pioneering work, originally motivated by scalability, feature maps are sampled according to the Fourier transform of a chosen kernel. The idea of optimizing a kernel in random feature space was studied by Sinha & Duchi (2016). In this work, which is most similar to ours, kernel alignment is optimized via importance sampling on a fixed, finitely supported proposal measure. However, the proposal can fail to contain informative features, especially in high dimension; indeed, they highlight efficiency, rather than showing performance improvements over RBF features.
Learning a kernel in the Fourier domain (without the primal feature maps) has also been considered previously: Oliva et al. (2016) model the Fourier spectrum as a mixture of Gaussians, which proves to be limiting; furthermore, the proposed algorithm requires complicated posterior inference procedures. Bazavan et al. (2012) study learning a kernel in the Fourier domain jointly with regression parameters. They show experimentally that this locates informative frequencies in the data, without theoretical guarantees. Our visualizations suggest that such an approach can get stuck in poor local minima, even in 2 dimensions.
1

Under review as a conference paper at ICLR 2018

Crammer et al. (2003) also use boosting to build a kernel sequentially; however, they only consider a basis of linear feature maps, and require a costly generalized eigenvector computation at each iteration. From a statistical view, Fukumizu et al. (2009) derive an upper bound on SVM margin in terms of maximum mean discrepancy, which is equivalent to (unweighted) kernel alignment. Notably, their bound can be loose if the number of support vectors is small; in such situations, our theory provides a tighter characterization. Moreover, our attention to the margin goes beyond the usual objective of kernel alignment.
1.2 OUR CONTRIBUTIONS
We present an algorithm that outputs a sequence of Fourier features, converging to the maximum realizable SVM classification margin on a labeled dataset. At each iteration, a pair of features is produced, which maximizes kernel alignment with a certain measure. As this measure changes slowly, the algorithm builds a diverse and informative feature representation.
Our main theorem can be seen as a case of von Neumann's min-max theorem for a zero-sum concave-linear game; indeed, our method bears a deep connection to boosting (Freund & Schapire, 1996; Schapire, 1999). In particular, both the theory and empirical evidence suggest that the generalization error of our method decreases as the number of random features increases. This stands in contrast to traditional MKL methods, whose generalization bounds worsen as base kernels are added.
Other methods in the framework of Fourier random features take the approach of approximating a kernel by sampling feature maps from a continuous distribution. In contrast, our method constructs a measure with small finite support, and realizes the kernel exactly by enumerating the associated finite-dimensional feature map; there is no randomness in the features.1

2 PRELIMINARIES

2.1 THE FOURIER DUAL MEASURE OF A KERNEL

We focus on two natural families of kernels k(x, x ): translation-invariant kernels on X = Rd, which depend only on x - x , and rotation-invariant kernels on the hypersphere X = Sd-1, which depend only on x, x . These invariance assumptions subsume most widely-used classes of kernels; notably, the Gaussian (RBF) kernel satisfies both. For the former invariance, Bochner's theorem provides a Fourier-analytic characterization:
Theorem 2.1 (e.g. Eq. (1), Sec. 1.4.3 in Rudin (2011)). A translation-invariant continuous function k : Rd × Rd  R is positive semidefinite if and only if k(x - x ) is the Fourier transform of a symmetric non-negative measure (where the Fourier domain is  = Rd). That is,

k(x - x ) = () ei ,x-x d = () ei ,x ei ,x d,

for some   L1(), satisfying ()  0 and () = (-) for all   .

(1)

A similar characterization is available for rotation-invariant kernels, where the Fourier basis func-

tions are the spherical harmonics, a countably infinite family of complex polynomials which form an orthonormal basis for square-integrable functions X  C. To unify notation, let   N × Z be the set of valid index pairs  = ( , m), and let   - denote a certain involution on ; we supply

details and references in Appendix B.1.

Theorem 2.2. A rotation-invariant continuous function k : Sd-1 × Sd-1  R is positive semidefi-

nite

if

and

only

if

it

has

a

symmetric

non-negative

expansion

into

spherical

harmonics

Y

d ,m

,

i.e.

 N (d, )

k( x, x ) =

( , m) Y d,m(x) Y d,m(x ),

j=0 l=1

(2)

for some   L1(), with ()  0 and () = (-) for all valid index pairs  = ( , m)  .

1We note a superficial resemblance to quasi-Monte Carlo methods (Avron et al., 2016); however, these are concerned with accelerating convergence rates rather than learning a kernel.

2

Under review as a conference paper at ICLR 2018

In each of these cases, we call this Fourier transform k() the dual measure of k. This measure decomposes k into a non-negative combination of Fourier basis kernels. Furthermore, this decomposition gives us a feature map  : X  L2(, k) whose image realizes the kernel under the codomain's inner product;2 that is, for all x, x  X ,

k(x, x ) = k() x() x () d.


(3)

Respectively, these feature maps are x() = ei ,x

and

x(

, m)

=

Y

d ,m

(x).

Although they

are complex-valued, symmetry of k allows us to apply the transformation {x(), x(-)} 

{Re x(), Im x()} to yield real features, preserving the inner product. The analogous result

holds for spherical harmonics.

2.2 KERNEL ALIGNMENT

In a binary classification task with n training samples (xi  X , yi  {±1}), a widely-used quantity
for measuring the quality of a kernel k : X × X  R is its alignment (Cristianini et al., 2002; Cortes et al., 2012),3 defined by

k(P, Q) d=ef

k(xi, xj)yiyj = yT Gky,

i,j[n]

where y is the vector of labels and Gk is the Gram matrix. Here, we let P = i:yi=1 xi and Q = i:yi=-1 xi denote the (unnormalized) empirical measures of each class, where x is the Dirac measure at x. When P, Q are arbitrary measures on X , this definition generalizes to

k(P, Q) d=ef

k(x, x ) dP2(x, x ) +

k(x, x ) dQ2(x, x ) -

k(x, x ) dP(x) dQ(x ).

X2 X2

X2

In terms of the dual measure k(), kernel alignment takes a useful alternate form, noted by Sriperumbudur et al. (2010). Let µ denote the signed measure P - Q. Then, when k is translation-
invariant, we have

2
k(P, Q) = k() ei ,x dµ(x) d
X
Analogously, when k is rotation-invariant, we have

d=ef k() v().


(4)

k(P, Q) =

k( , m)

( ,m)

2

Y

d ,m

(x)

dµ(x)

X

d=ef k( , m) v( , m).
( ,m)

(5)

It can also be verified that k L1() = k(x, x), which is of course the same for all x  X . In
each case, the alignment is linear in k. We call v() the Fourier potential, which is the squared magnitude of the Fourier transform of the signed measure µ = P - Q. This function is clearly bounded pointwise by (P(X ) + Q(X ))2.

3 ALGORITHMS
3.1 MAXIMIZING KERNEL ALIGNMENT IN THE FOURIER DOMAIN
First, we consider the problem of finding a kernel k (subject to either invariance) that maximizes alignment k(P, Q); we optimize the dual measure k(). Aside from the non-negativity and symmetry constraints from Theorems 2.1 and 2.2, we constrain k 1 = 1, as this quantity appears as a normalization constant in our generalization bounds (see Theorem 4.3). Maximizing k(P, Q) in this constraint set, which we call L  L1(), takes the form of a linear program on an infinitedimensional simplex. Noting that v() = v(-)  0, k is maximized by placing a Dirac mass at any pair of opposite modes ±  argmax v().
2In fact, such a pair (, ) exists for any psd kernel k; see Dai et al. (2014) or Devinatz (1953). 3Definitions vary up to constants and normalization, depending on the use case.

3

Under review as a conference paper at ICLR 2018

At first, P and Q will be the empirical distributions of the classes, specified in Section 2.2. However, as Algorithm 2 proceeds, it will reweight each data point xi in the measures by (i). Explicitly, the reweighted Fourier potential takes the form4

n2

n2

v() d=ef

yiie ,xi

or v( , m) d=ef

yiiY

d ,m

(xi

)

.

i=1 i=1

Due to its non-convexity, global optimization on v(), which can be interpreted as finding a Fourier peak in the data, is theoretically challenging in high dimension. However, it is a natural assumption on realistic data that the largest peaks are close to the origin: this is the assumption of bandlimitedness that underpins much of data compression. In our experiments, we find that it is easy to find informative peaks, even in hundreds of dimensions.

When a gradient is available (in the translation-invariant case), we use Langevin dynamics (Algorithm 1) to find the peaks of v(), which enjoys mild theoretical guarantees for hitting time (see Theorem 4.5). In the rotation-invariant case, where  is a discrete set, heuristics are available; see
Appendix A.3.

Algorithm 1 Langevin dynamics for kernel alignment

1: Input: training samples S = {(xi, yi)}ni=1, weights   Rn. 2: Parameters: time horizon  , diffusion rate , temperature .
3: Initialize 0 arbitrarily. 4: for t = 0, . . . ,  - 1 do

5: Update t+1  t + v(t) +
6: end for 7: return  := argmaxt v(t)

2 

z,

where

z



N

(0,

I ).

It is useful in practice to use parallel initialization, running m concurrent copies of the diffusion process and returning the best single  encountered. This admits a very efficient GPU implementation: the multi-point evaluations v(1..m) and v(1..m) can be computed from an (m, d) by (d, n)
matrix product and pointwise trigonometric functions. We find that Algorithm 1 typically finds a reasonable peak within 100 steps.

3.2 LEARNING THE MARGIN-MAXIMIZING KERNEL FOR SVM

Support vector machines (SVMs) are perhaps the most ubiquitous use case of kernels in practice.

To this end, we propose a method that boosts Algorithm 1, building a kernel that maximizes the

classification margin. Let k be a kernel with dual k, and Y d=ef diag(y). Write the dual l1-SVM objective,5 parameterizing the kernel by k:

F (, k)

d=ef

1T 

-

1 2

T

YGk Y

=

1T



-

1 2

k

(P,

Q)

=

1T



-

1 2

k() v() d.


Thus, for a fixed , F is equivalent to kernel alignment, and can be minimized by Algorithm 1.

However, the support vector weights  are of course not fixed; given a kernel k,  is chosen to

maximize F , giving the (reciprocal) SVM margin. In all, to find a kernel k which maximizes the

margin under an adversarial choice of , one must consider a two-player zero-sum game:

min max F (, ),
L K

(6)

where L is the same constraint set as in Section 3.1, and K is the usual dual feasible set {0  C, yT  = 0} with box parameter C.

In this view, we make some key observations. First, Algorithm 1 allows the min-player to play a pure-strategy best response to the max-player. Furthermore, a mixed strategy ¯ for the min-player

4Whenever i is an index, we will denote the imaginary unit by . 5Of course, our method applies to l2 SVMs, and has even stronger theoretical guarantees; see Section 4.1.

4

Under review as a conference paper at ICLR 2018

is simply a translation- or rotation-invariant kernel, realized by the feature map corresponding to its support. Finally, since the objective is linear in  and concave in , there exists a Nash equilibrium (, ) for this game, from which  gives the margin-maximizing kernel.
We can use no-regret learning dynamics to approximate this equilibrium. Algorithm 2 runs Algorithm 1 for the min-player, and online gradient ascent (Zinkevich, 2003) for the max-player. Intuitively (and as is visualized in our synthetic experiments), this process slowly morphs the landscape of v to emphasize the margin, causing Algorithm 1 to find progressively more informative features. At the end, we simply concatenate these features; contingent on the success of the kernel alignment steps, we have approximated the Nash equilibrium.

Algorithm 2 No-regret learning dynamics for SVM margin maximization

1: Input: training samples S = {(xi, yi)}in=1. 2: Parameters: box constraint C, # steps T , step sizes {t}; parameters for Algorithm 1.

3:

Set x() = ei ,x

(translation-invariant),

or

x(

, m)

=

Y

d ,m

(x)

(rotation-invariant).

4:

Initialize



=

ProjK[

C 2

· 1].

5: for t = 1, . . . , T do

6: Use Algorithm 1 (or other v maximizer) on S with weights t, returning t.

7: Append two features {Re x (t), Im x (-t)} to each xi's representation (xi).

8: Compute gradient gt := F (t, t), where t = t + -t . 9: Update t+1  ProjK[t + tgt].

10: end for

11:

return

features {(xi)  R2T }ni=1, or dual measure ¯ :=

1 2T

T t=1

t

+

-t

.

We provide a theoretical analysis in Section 4.1, and detailed discussion on heuristics, hyperpa-
rameters, and implementation details in depth in Appendix A. One important note is that the online gradient gt = 1-2Y Re( t, Yt t) is computed very efficiently, where t(i) = xi (t)  Cm is the vector of the most recently appended features. Langevin dynamics, easily implemented on a
GPU, comprise the primary time bottleneck.

4 THEORY

4.1 CONVERGENCE OF NO-REGRET LEARNING DYNAMICS

We first state the main theoretical result, which quantifies the convergence properties of Algorithm 2.

Theorem 4.1 (Main). Assume that at each step t, Algorithm 1 returns an t-approximate global

maximizer Algorithm

2pt r(oi.deu.,cevsat(dut)almesauspure¯vtL(w)h-ichts)a. tiTshfieens,

with

a

certain

choice

of

step

sizes

t,

max F (, ¯)  min max F (, ) +

K

L K

T t=1

t

2T

+

3(C +2C2)n . 4T

(Alternate form.) Suppose instead that vt(t)   at each time t. Then, ¯ satisfies

max F (, ¯)   + 3(C +2C2)n .

K

4T

We prove Theorem 4.1 in Appendix C. For convenience, we state the first version as an explicit margin bound (in terms of competitive ratio M/M ):

Corollary 4.2. Let M be the margin obtained by training an 1 linear SVM with the same C as in Algorithm 2, on the transformed samples {((xi), yi)}. Then, M is (1 - )-competitive with M , the maximally achievable margin by a kernel with the assumed invariance, with



t t T

+

3(C +2C2)n . 4T

This bound arises from the regret analysis of online gradient ascent (Zinkevich, 2003); our analysis

is similar to the approach of Freund & Schapire (1996), where they present a boosting perspective.

When using an

2-SVM,

the

final

term

can

be

improved

to

O(

log T

T

)

(Hazan

et

al.,

2007).

For a

general overview of results in the field, refer to Hazan (2016).

5

Under review as a conference paper at ICLR 2018

4.2 GENERALIZATION BOUNDS

Finally, we state two (rather distinct) generalization guarantees. To begin, we state a margindependent SVM generalization bound, due to Koltchinskii & Panchenko (2002). Notice the appearance of k 1, justifying our choice of normalization constant for Algorithm 1. Intruigingly, the end-to-end generalization error of our method decreases with an increasing number of random features, since the margin bound is being refined during Algorithm 2.
Theorem 4.3 (Generalization via margin). For any SVM decision function f : X  R with a kernel k trained on samples S drawn i.i.d. from distribution D, the generalization error is bounded by

Pr [yf
(x,y)D

(x)



0]



min


1 n

n

1yif (xi)

+

2 

i=1

k n

1

+3

log n

2 

.

Next, we address another concern entirely: the sample size required for v() to approximate the ideal Fourier potential videal(), the squared magnitude of the Fourier transform of the signed measure P - Q arising from the true distribution. In the shift-invariant case, we have such a generalization bound, requiring a bandwidth assumption  2  R. Intuitively, choosing frequencies too far
from the origin might overfit the data.

Theorem 4.4 (Generalization of the potential). Let S be a set of i.i.d. training samples on D, with

nO

d

log

1 

+log

1 

2

. We have that for all  :



 R, with probability at least 1 - ,

v() n2

-

videal()

 .

The O(·) suppresses factors polynomial in Rx d=ef maxi xi and R.

The full statement and proof are standard, and deferred to Appendix D. In particular, this result allows for a mild guarantee of polynomial hitting-time on the locus of approximate local maxima of videal (as opposed to the empirical v). Adapting the main result from Zhang et al. (2017):
Theorem 4.5 (Langevin hitting time). Let  be the output of Algorithm 1 on v(), after  steps. Algorithm 1 finds an approximate local maximum of videal in polynomial time. That is, with U being the set of -approximate local maxima of videal(), some t satisfies
v(t)  inf v()
d(U,)
for some   O(poly (Rx, R, d, , , -1, -1, log(1/)), with probability at least 1 - .

Of course, one should not expect polynomial hitting time on approximate global maxima; Roberts & Tweedie (1996) give asymptotic mixing guarantees.

5 EXPERIMENTS
In this section, we highlight the most important and illustrative parts of our experimental results. For further details, we provide an extended addendum to the experimental section in Appendix A.
First, we exhibit two simple binary classification tasks, one in R2 and the other on S2, to demonstrate the power of our kernel selection method. As depicted in Figure 1, we create datasets with sharp boundaries, which are difficult for the standard RBF and arccosine (Cho & Saul, 2009) kernel. In both cases, ntrain = 2000 and ntest = 50000.6 Used on a 1-SVM classifier, these baseline kernels saturate at 92.1% and 95.1% test accuracy, respectively; they are not expressive enough.
On the R2 "windmill" task, Algorithm 2 chooses random features that progressively refine the decision boundary at the margin. By T = 1000, it exhibits almost perfect classification (99.7% training, 99.3% test). Similarly, on the S2 "checkerboard" task, Algorithm 2 (with some adaptations described in Appendix A.3) reaches almost perfect classification (99.7% training, 99.1% test) at T = 100, supported on only 29 spherical harmonics as features.
6ntest is chosen so large to measure the true generalization error.

6

Under review as a conference paper at ICLR 2018

RBF (baseline, 92.1% test)

T = 100 (98.6% test)

T = 300 (99.1% test)

T = 1000 (99.3% test)

Data {(xi, yi)}; dual weights t

Features {±i}iT=1; potential v()

SVM decision function

(a) Evolution of Algorithm 2. Top: The windmill dataset, weighted by dual variables t. Middle: 2t random features (magenta; last added ±t in cyan), overlaying the Fourier potential vt() in the background. Bottom: Decision boundary of a hinge-loss classifier trained on the kernel, showing refinement at the margin. Contours
depth of color indicate the value of margin.

(b) Detailed evolution of the Fourier potential v(). Left: Initial potential v(), with uniform weights. Right: Reweighted v() at t = 300. Note the larger support of peaks.

(c) Toy dataset on the sphere, with top-3 selected features: spherical harmonics Y11,0, Y9,4, Y27,8.

Figure 1: Visualizations and experiments on synthetic data.

We provide some illuminating visualizations. Figures 1a and 1b show the evolution of the dual weights, random features, and classifier. As the theory suggests, the objective evolves to assign higher weight to points near the margin, and successive features improve the classifier's decisiveness in challenging regions (1a, bottom). Figure 1c visualizes some features from the S2 experiment.
Next, we evaluate our kernel on standard benchmark binary classification tasks. Challenging label pairs are chosen from the MNIST (LeCun et al., 1998) and CIFAR-10 (Krizhevsky, 2009) datasets; each task consists of 10000 training and 2000 test examples; this is considered to be large-scale for kernel methods. Following the standard protocol from Yu et al. (2016), 512-dimensional HoG features (Dalal & Triggs, 2005) are used for the CIFAR-10 tasks instead of raw images. Of course, our intent is not to show state-of-the-art results on these tasks, on which deep neural networks easily dominate. Instead, the aim is to demonstrate viability as a scalable, principled kernel method.
7

Under review as a conference paper at ICLR 2018

Training accuracy

1.00
0.95
0.90
0.85
0.80
0.75 RBF-RF LKRF
0.70 ours 0.90

0.85

0.80

0.75

0.70 0.65
0

RBF-RF LKRF ours
1000 2000 3000 4000 5000 Number of features m

Dataset
MNIST (1-7)
MNIST (4-9)
MNIST (5-6)
CIFAR-10 (plane-bird)
CIFAR-10 (auto-truck)
CIFAR-10 (dog-frog)
CIFAR-10 (auto-ship)
CIFAR-10 (auto-deer)

Method
RBF-RF LKRF ours RBF-RF LKRF ours RBF-RF LKRF ours RBF-RF LKRF ours RBF-RF LKRF ours RBF-RF LKRF ours RBF-RF LKRF ours RBF-RF LKRF ours

100
97.42 97.60 99.05 87.72 88.42 93.02 91.96 92.78 96.62 71.75 73.30 81.80 69.70 71.89 84.80 70.80 70.75 81.95 70.85 70.55 81.00 84.65 84.85 92.40

Number of features m 500 1000 2000

99.02 98.95 99.28 94.11 93.99 96.31 97.63 97.60 98.67 78.30 78.80 82.15 75.75 77.33 85.90 79.95 78.95 84.05 78.00 77.90 83.70 90.00 89.75 93.60

99.10 99.05 99.45 96.95 95.88 97.68 97.85 97.79 99.18 79.85 79.85 83.00 82.55 83.62 86.00 81.85 81.25 85.40 79.15 79.55 84.40 91.85 91.05 93.55

99.42 99.21 99.63 97.36 97.18 98.72 98.51 98.36 99.32 80.15 80.80 84.25 83.35 84.60 88.25 82.50 81.35 85.95 81.80 80.95 86.70 92.45 92.65 94.05

5000
99.31 99.37 99.65 98.08 97.76 99.01 98.82 98.54 99.64 81.25 81.55 85.15 85.10 84.95 88.80 82.95 83.00 86.25 82.55 82.85 87.35 92.65 92.90 94.90

Test accuracy

Table 1: Comparison on binary classification tasks. Our method is compared against standard RBF random features (RBF-RF), as well as the method from Sinha & Duchi (2016) (LKRF). Left: Performance is measured on the CIFAR-10 automobile vs. truck task, varying the number of features m. Standard deviations over 10 trials are shown, demonstrating high stability.

We compare our results to baseline random features-based kernel machines: the standard RBF random features (RBF-RF for short), and the method of Sinha & Duchi (2016) (LKRF),7 using the same 1-SVM throughout. As shown by Table 1, our method reliably outperforms these baselines, most significantly in the regime of few features. Intuitively, this lines up with the expectation that isotropic random sampling becomes exponentially unlikely to hit a good peak in high dimension; our method searches for these peaks.
Furthermore, our theory predicts that the margin keeps improving, regardless of the dimensionality of the feature maps. Indeed, as our classifier saturates on the training data, test accuracy continues increasing, without overfitting. This decoupling of generalization from model complexity is characteristic of boosting methods.
In practice, our method is robust with respect to hyperparameter settings. As well, to outperform both RBF-RF and LKRF with 5000 features, our method only needs  100 features. Our GPU implementation reaches this point in 30 seconds. See Appendix A.1 for more tuning guidelines.
6 CONCLUSION
We have presented an efficient kernel learning method that uses tools from Fourier analysis and online learning to optimize over two natural infinite families of kernels. With this method, we show meaningful improvements on benchmark tasks, compared to related random features-based methods. Many theoretical questions remain, such as accelerating the search for Fourier peaks (e.g. Hassanieh et al. (2012); Kapralov (2016)). These, in addition to applying our learned kernels to state-of-the-art methods (e.g. convolutional kernel networks (Mairal et al., 2014; Mairal, 2016)), prove to be exciting directions for future work.
7Traditional MKL methods are not tested here, as they are noticeably (> 100 times) slower.
8

Under review as a conference paper at ICLR 2018
REFERENCES
Naman Agarwal, Zeyuan Allen-Zhu, Brian Bullins, Elad Hazan, and Tengyu Ma. Finding approximate local minima faster than gradient descent. In Proceedings of the 49th Annual ACM SIGACT Symposium on Theory of Computing, pp. 1195­1199. ACM, 2017.
Haim Avron, Vikas Sindhwani, Jiyan Yang, and Michael W Mahoney. Quasi-Monte Carlo feature maps for shift-invariant kernels. Journal of Machine Learning Research, 17(120):1­38, 2016.
Eduard Gabriel Bazavan, Fuxin Li, and Cristian Sminchisescu. Fourier kernel learning. In Computer Vision­ECCV 2012, pp. 459­473. Springer, 2012.
Youngmin Cho and Lawrence K Saul. Kernel methods for deep learning. In Advances in Neural Information Processing Systems, pp. 342­350, 2009.
Corinna Cortes, Mehryar Mohri, and Afshin Rostamizadeh. Algorithms for learning kernels based on centered alignment. Journal of Machine Learning Research, 13(Mar):795­828, 2012.
Koby Crammer, Joseph Keshet, and Yoram Singer. Kernel design using boosting. In Advances in Neural Information Processing Systems, pp. 553­560, 2003.
Nello Cristianini, John Shawe-Taylor, Andre Elisseeff, and Jaz Kandola. On kernel-target alignment. In Advances in Neural Information Processing Systems, pp. 367­373, 2002.
Bo Dai, Bo Xie, Niao He, Yingyu Liang, Anant Raj, Maria-Florina Balcan, and Le Song. Scalable kernel methods via doubly stochastic gradients. In Advances in Neural Information Processing Systems, pp. 3041­3049, 2014.
Navneet Dalal and Bill Triggs. Histograms of oriented gradients for human detection. In Computer Vision and Pattern Recognition, 2005. CVPR 2005. IEEE Computer Society Conference on, volume 1, pp. 886­893. IEEE, 2005.
Constantinos Daskalakis, Alan Deckelbaum, and Anthony Kim. Near-optimal no-regret algorithms for zero-sum games. Games and Economic Behavior, 92:327­348, 2015.
A Devinatz. Integral representations of positive definite functions. Transactions of the American Mathematical Society, 74(1):56­77, 1953.
Yoav Freund and Robert E Schapire. Game theory, on-line prediction and boosting. In Proceedings of the Ninth Annual Conference on Computational Learning Theory, pp. 325­332. ACM, 1996.
Kenji Fukumizu, Arthur Gretton, Gert R Lanckriet, Bernhard Scho¨lkopf, and Bharath K Sriperumbudur. Kernel choice and classifiability for RKHS embeddings of probability distributions. In Advances in Neural Information Processing Systems, pp. 1750­1758, 2009.
Jean Gallier. Notes on spherical harmonics and linear representations of lie groups. 2009.
Mehmet Go¨nen and Ethem Alpaydin. Multiple kernel learning algorithms. Journal of Machine Learning Research, 12(Jul):2211­2268, 2011.
Haitham Hassanieh, Piotr Indyk, Dina Katabi, and Eric Price. Simple and practical algorithm for sparse Fourier transform. In Proceedings of the Twenty-Third Annual ACM-SIAM Symposium on Discrete Algorithms, pp. 1183­1194. Society for Industrial and Applied Mathematics, 2012.
Elad Hazan. Introduction to online convex optimization. Foundations and Trends R in Optimization, 2(3-4):157­325, 2016.
Elad Hazan, Amit Agarwal, and Satyen Kale. Logarithmic regret algorithms for online convex optimization. Machine Learning, 69(2):169­192, 2007.
Atsushi Higuchi. Symmetric tensor spherical harmonics on the N-sphere and their application to the de Sitter group SO (N, 1). Journal of mathematical physics, 28(7):1553­1566, 1987.
Michael Kapralov. Sparse Fourier transform in any constant dimension with nearly-optimal sample complexity in sublinear time. In Proceedings of the 48th Annual ACM SIGACT Symposium on Theory of Computing, pp. 264­277. ACM, 2016.
9

Under review as a conference paper at ICLR 2018
Vladimir Koltchinskii and Dmitry Panchenko. Empirical margin distributions and bounding the generalization error of combined classifiers. Annals of Statistics, pp. 1­50, 2002.
Alex Krizhevsky. Learning multiple layers of features from tiny images. 2009.
Gert RG Lanckriet, Nello Cristianini, Peter Bartlett, Laurent El Ghaoui, and Michael I Jordan. Learning the kernel matrix with semidefinite programming. Journal of Machine Learning Research, 5(Jan):27­72, 2004.
Yann LeCun, Le´on Bottou, Yoshua Bengio, and Patrick Haffner. Gradient-based learning applied to document recognition. Proceedings of the IEEE, 86(11):2278­2324, 1998.
Julien Mairal. End-to-end kernel learning with supervised convolutional kernel networks. In Advances in Neural Information Processing Systems, pp. 1399­1407, 2016.
Julien Mairal, Piotr Koniusz, Zaid Harchaoui, and Cordelia Schmid. Convolutional kernel networks. In Advances in Neural Information Processing Systems, pp. 2627­2635, 2014.
Colin McDiarmid. On the method of bounded differences. Surveys in combinatorics, 141(1):148­ 188, 1989.
Claus Mu¨ller. Analysis of spherical symmetries in Euclidean spaces, volume 129. Springer Science & Business Media, 2012.
Yurii Nesterov. Excessive gap technique in nonsmooth convex minimization. SIAM Journal on Optimization, 16(1):235­249, 2005.
Junier Oliva, Avinava Dubey, Barnabas Poczos, Jeff Schneider, and Eric P Xing. Bayesian nonparametric kernel-learning. In Proceedings of the 19th International Conference on Artificial Intelligence and Statistics, 2016.
Ali Rahimi and Benjamin Recht. Random features for large-scale kernel machines. In Advances in Neural Information Processing Systems, pp. 1177­1184, 2007.
Gareth O Roberts and Richard L Tweedie. Exponential convergence of Langevin distributions and their discrete approximations. Bernoulli, pp. 341­363, 1996.
Walter Rudin. Fourier analysis on groups. John Wiley & Sons, 2011.
Robert E Schapire. A brief introduction to boosting. In Proceedings of the 16th International Joint Conference on Artificial Intelligence, pp. 1401­1406, 1999.
IJ Schoenberg. Positive definite functions on spheres. Duke Mathematical Journal, 9(1):96­108, 1942.
Aman Sinha and John C Duchi. Learning kernels with random features. In Advances in Neural Information Processing Systems, pp. 1298­1306, 2016.
Bharath K Sriperumbudur, Arthur Gretton, Kenji Fukumizu, Bernhard Scho¨lkopf, and Gert RG Lanckriet. Hilbert space embeddings and metrics on probability measures. Journal of Machine Learning Research, 11(Apr):1517­1561, 2010.
Elias M Stein and Guido Weiss. Introduction to Fourier analysis on Euclidean spaces (PMS-32), volume 32. Princeton University Press, 2016.
John von Neumann. On rings of operators. reduction theory. Annals of Mathematics, pp. 401­485, 1949.
Felix X Yu, Ananda Theertha Suresh, Krzysztof M Choromanski, Daniel N Holtmann-Rice, and Sanjiv Kumar. Orthogonal random features. In Advances in Neural Information Processing Systems, pp. 1975­1983, 2016.
Yuchen Zhang, Percy Liang, and Moses Charikar. A hitting time analysis of stochastic gradient Langevin dynamics. arXiv preprint arXiv:1702.05575, 2017.
Martin Zinkevich. Online convex programming and generalized infinitesimal gradient ascent. In Proceedings of the 20th International Conference on Machine Learning (ICML-03), pp. 928­936, 2003.
10

Under review as a conference paper at ICLR 2018

A APPENDIX FOR EXPERIMENTS
Algorithm 2 gives a high-level outline of the essential components of our method. However, it conceals several hyperparameter choices and algorithmic heuristics, which are pertinent when applying our method in practice. We discuss a few more details in this section.

A.1 HYPERPARAMETER TUNING GUIDE
Throughout all experiments presented, we use hinge-loss SVM classifiers with C = 1. Note that the convergence of Algorithm 2 depends quadratically on C.
With regard to Langevin diffusion (Algorithm 1), we observe that the best samples arise from using high temperatures and Gaussian parallel initialization. For the latter, a rule-of-thumb is to initialize 500 parallel copies of Langevin dynamics, drawing the initial position {0} from a centered isotropic Gaussian with 1.5× the variance of the optimal RBF random features. (In turn, a common rule-of-thumb for this bandwidth is the median of pairwise Euclidean distances between data points.)
The step size in Algorithm 1 is tuned based on the magnitude of the gradient on v(), which can be significantly smaller than the upper bound derived in Section D. As is standard practice in Langevin Monte Carlo methods, the temperature is chosen so that the pertubation is roughly at the same magnitude as the gradient step. Empirically, running Langevin dynamics for 100 steps suffices to locate a reasonably good peak. To further improve efficiency, one can modify Algorithm 1 to pick the top k  10 samples, a k-fold speedup which does not degrade the features much.
The step size of online gradient ascent is set to balance between being conservative and promoting diverse samples; these steps should not saturate (thereby solving the dual SVM problem), in order to have the strongest regret bound. In our experiments, we find that the step size achieving the standard regret guarantee (scaling as 1/ T ) tends to be a little too conservative.
On the other hand, it never hurts (and seems important in practice) to saturate the peak-finding routine (Algorithm 1), since this contributes an additive improvement to the margin bound. Noting that the objective is very smooth (the k-th derivative scales as Rxk), it may be beneficial to refine the samples using a few steps of gradient descent with a very small learning rate, or an accelerated algorithm for finding approximate local minima of smooth non-convex functions; see, e.g. Agarwal et al. (2017).

A.2 PROJECTION ONTO THE SVM DUAL FEASIBLE SET
A quick note on projection onto the feasible set K = {0  C, yT  = 0} of the SVM dual convex program: it typically suffices in practice to use alternating projection. This feasible set is the intersection of a hyperplane and a hypercube; both of which admit a simple projection step. The alternation projection onto the intersection of two non-empty convex sets was originally proposed by von Neumann (1949). The convergence rate can be shown to be linear. To obtain the dual variables in our experiments, we use 10 such alternating projections. This results in a dual feasible solution up to hardware precision, and is a negligible component of the total running time (for which the parallel gradient computations are the bottleneck).

Algorithm 3 Alternating Projection for SVM Dual Constraints

Input:   Rn

Parameters: box constraint C, label vector y.

repeat

Project onto the box:  = clip(, 0, C)

Project

onto

the

hyperplane:







-

yT  n

y

until convergence

return 

11

Under review as a conference paper at ICLR 2018

A.3 SAMPLING SPHERICAL HARMONICS
As we note in Section 3.1, it is unclear how to define gradient Langevin dynamics on v(l, m) in the inner-product case, since no topology is available on the indices (l, m) of the spherical harmonics. One option is to emulate Langevin dynamics, by constructing a discrete Markov chain which mixes to (l, m)  ev(l,m).
However, we find in our experiments that it suffices to compute (l, m) by examining all values of v(l, m) with j no more than some threshold J. One should view this as approximating the kerneltarget alignment objective function via Fourier truncation. This is highly parallelizable: it involves approximately N (m, d) degree-J polynomial evaluations on the same sample data, which can be expressed using matrix multiplication. In our experiments, it sufficed to examine the first 1000 coefficients; we remark that it is unnatural in any real-world datasets to expect that v() only has large values outside the threshold J.
Under Fourier truncation, the domain of  becomes a finite-dimensional simplex. In the gametheoretic view of 4.1, an approximate Nash equilibrium becomes concretely achievable via Nesterov's excessive gap technique (Nesterov, 2005; Daskalakis et al., 2015), given that the kernel player's actions are restricted to a mixed strategy over a finite set of basis kernels.
Finally, we note a significant advantage to this setting, where we have a discrete set of Fourier coefficients: the same feature might be found multiple times. When a duplicate feature is found, it need not be concatenated to the representation; instead, the existing feature is scaled appropriately. This accounts for the drastically smaller support of features required to achieve near-perfect classification accuracy.

B MORE ON SPHERICAL HARMONICS
In this section, we go into more detail about the spherical harmonics in d dimensions. Although all of this material is standard in harmonic analysis, we provide this section for convenience, isolating only the relevant facts.

B.1 SPHERICAL HARMONIC EXPANSION OF A ROTATION-INVARIANT KERNEL

First, we provide a proof sketch for Theorem 2.2. We rely on the following theorem, an analogue of Bochner's theorem on the sphere, which characterizes rotation-invariant kernels:

Theorem B.1 (Schoenberg (1942)). A continuous rotation-invariant function k(x, x ) = k( x, x ) on Sd-1 × Sd-1 is positive semi-definite if and only if its expansion into Gegenbauer polynomials Pid has only non-negative coefficients, i.e.


k( x, x ) = mPmd ( x, x ),
m=0

(7)

with m  0, m  N+.

The Gegenbauer polynomials Pmd : [-1, 1]  R are a generalization of the Legendre and Chebyshev polynomials; they form an orthogonal basis on [-1, 1] under a certain weighting function (see Stein & Weiss (2016); Gallier (2009); Mu¨ller (2012) for details). Note that we adopt a different notation from Schoenberg (1942), which denotes our Pmd by Pm(d-1)/2.
Unlike Theorem 2.1, Theorem B.1 alone does not provide a clear path for constructing a feature map for inner-product kernel, because the inputs x, x of the kernel are still coupled after the expansion into Pmd , which acts on the inner product x, x instead of on x and x separately. Fortunately, (see, e.g., Proposition 1.18 in Gallier (2009)), the Gegenbauer polynomials evaluated on an inner product admits a decomposition into spherical harmonics Y d,m:

Pmd ( x, x

)

=

|Sd-1| N (d, )

N (d,

)
Y d,m(x)Y

d,m(x

)

x, x  Sd-1,

l=1

(8)

12

Under review as a conference paper at ICLR 2018

where |Sd-1| denotes the surface area of Sd-1, and N (d, ) = d-1+

-

d-1+ -2

. Here, we use

the normalization convention that Sd-1 |Y d,m(x)|2 dx = 1. From the existence of this expansion

follows the claim from Theorem 2.2. For a detailed reference, see Mu¨ller (2012).

B.2 PAIRING THE SPHERICAL HARMONICS

We now specify the involution   - on indices of spherical harmonics, which gives a pairing that takes the role of opposite Fourier coefficients in the X = Rd case. In particular, the Fourier transform  of a real-valued function k : Rn  R satisfies () = (-), so that the dual measure can be constrained to be symmetric.
Now, consider the X = Sd-1 case, where the Fourier coefficients are on the set  of valid indices of spherical harmonics. We would like a permutation on the indices  so that (()) = , and () = (()) whenever  is the spherical harmonic expansion of a real kernel.

For a fixed dimension d and degree , the spherical harmonics form an N := N (d, )-dimensional orthogonal basis for a vector space V of complex polynomials from Sd-1 to C, namely the homogeneous polynomials (with domain extended to Rn) which are harmonic (eigenfunctions of
the Laplace-Beltrami operator Sd-1 ). This basis is not unique; an arbitrary choice of basis may not contain pairs of conjugate functions.

Fortunately, such a basis exists constructively, by separating the Laplace-Beltrami operator over
spherical coordinates (1, . . . , d-1). Concretely, for a fixed d and , the d-dimensional spherical harmonic, indexed by | 1|  2  3  . . .  d-1, is defined as:

Y

1 ,...,

N

d=ef

1 ei 2

d-1
11 kP
k=2

d-1 k

(k

),

where the functions in the product come from a certain family of associated Legendre functions in sin . For a detailed treatment, we adopt the construction and conventions from Higuchi (1987).

In the scope of this paper, the relevant fact is that the desired involution is well-defined in all dimensions. Namely, consider the permutation  that sends a spherical harmonic indexed by  =
(d, , 1, 2, . . . , d-1) to () = (d, , - 1, 2, . . . , d-1). Then, Y-(x) d=ef Y()(x) = Y(x) for all , x.

The symmetry condition in Theorem 2.2 follows straightforwardly. By orthonormality, we know that every square-integrable function f : Rn  C has a unique decomposition into spherical harmonics,
with coefficients  = f, Y , so that - = f, Y = . When f is real-valued, we conclude that - = -, as claimed.

C PROOF OF THE MAIN THEOREM

In this section, we prove the main theorem, which quantifies convergence of Algorithm 2 to the Nash

equilibrium. We restate it here:

Theorem 4.1. Assume that during each timestep t, the call to Algorithm 1 returns an t-approximate

global maximizer measure ¯, which

t (i.e. satisfies

v^t (t)



maxK v^t () - t).

Then, Algorithm 2 returns a dual

max F (, ¯)  min max F (, ) +

K

L K

T t=1

t

T

+O

1 T

.

Alternatively with the assumption that at each timestep t, v^t (t)  , ¯, satisfies

max F (, ¯)   + O 1 .

K

T

If

Algorithm

2

is

used

on

a

l2-SVM,

the

regret

bound

can

be

improved

to

be

O(

log T

T

).

Proof. We will make use of the regret bound of online gradient ascent (see, e.g., (Hazan, 2016)).
Here we only prove the theorem in the case for l1-SVM with box constraint C, under the assumption of t-approximate optimality of Algorithm 1. Extending the proof to other cases is straightfoward.

13

Under review as a conference paper at ICLR 2018

Lemma C.1 (Regret bound for online gradient ascent). Let D be the diameter of the constraint set

K, and G a Lipschitz constant for an arbitrary sequence of concave functions ft() d=ef F (, t)

on

K.

Online

gradient ascent

on ft(), with step

size

schedule

t

=

G ,
Dt

guarantees

the

following

for all T  1:

1 T

T
ft(t)
t=1



max
K

1 T

T
ft() -
t=1

3GD . 2T

Here, D  Cn by the box constraint, and we have

G  sup 1 - 2Y Re( t, Yt t) 2

K,

Rd



 (1 + 2C) n.

Thus, our regret bound is 3n(C+2C2) ; that is, for all T  1,
2T

1 T

T
F (t, t
t=1

+

-t )



max
K

1 T

T
F (, t
t=1

+ -t )) -

3n(C+ 2C2) . 2T

Since at each timestep t, v^t (t)  maxK v^t () - t, we have by assumption

F

(t,

t

+

-t )



min
K

F

(t,



+

- )

+

t,

and by concavity of F in , we know that, for any fixed sequence 1, 2, . . . , T ,

min
L

max
K

F

(,

)



min
L

1 T

T

F (t, ),

t=1

it follows that

min
L

max
K

F

(,

)



min
L

1 T

T

F (t, )

t=1



1 T

T

min F (t,  + -)
K

t=1



1 T

T

F (t, t + -t ) -

t=1

T t=1

t

T



max
K

1 T

T
F (, t
t=1

+ -t ) -

3n(C+ 2C2) 2T

-

T t=1
T

t

.

To

complete

the

proof,

note

that

for

a

given





K,

1 2T

T t=1

F

(,

t

+

-t )

=

F

(,

¯)

by

lin-

earity

of

F

in

the

dual

measure;

here,

¯

=

1 2T

T t=1

t

+ -t

is

the

approximate

Nash

equilibrium

found by the no-regret learning dynamics.

D SAMPLE COMPLEXITY FOR THE FOURIER POTENTIAL

In this section, we prove the following theorem about concentration of the Fourier potential. It

suffices to disregard the reweighting vector ; to recover a guarantee in this case, simply replace  with /C2. Note that we only argue this in the translation-invariant case.

Theorem 4.4. Let S = {(xi, yi)}in=1 be a set of i.i.d. training samples. Then, if

n



8Rx2 R4 (d log

2R 

2

+ log

1 

)

,

we have that with probability at least 1 - ,

1 n2

v(n)()

-

videal()

  for all    such that

  R.

14

Under review as a conference paper at ICLR 2018

Let P(n), Q(n) denote the empirical measures from a sample S of size n, arising from i.i.d. samples from the true distribution, whose classes have measures P, Q, adopting the convention P(X ) + Q(X ) = 1. Then, in expectation over the sampling, and adopting the same normalization
conventions as in the paper, we have E[P(n)/n] = P and E[Q(n)/n] = Q for every n.

Let v(n)() denote the empirical Fourier potential, computed from P(n), Q(n), so that we have E[v(n)()/n2] = videal(). The result follows from a concentration bound on v(n)()/n2. We first show that it is Lipschitz:

Lemma D.1 (Lipschitzness of v(n) in ). The function

v(n)() =

n2
yie ,xi
i

(9)

is 2n2Rx-Lipschitz with respect to .

Proof. We have



v(n)() =  

yiyj e ,xi-xj 

i,j[n]

= yiyj i(xi - xj )e ,xi-xj  n2 · max ||xi - xj ||  2n2Rx.
i,j i,j[n]

Thus, the Lipschitz constant of v(n)()/n2 scales linearly with the norm of the data, a safe assumption. Next, we show Lipschitzness with respect to a single data point:
Lemma D.2 (Lipschitzness of v(n) in xi). v(n)() is 2nR-Lipschitz with respect to any xi.

Proof. Similarly as above:



xi v(n)() = xi 

yiyj e ,xi-xj 

i,j[n]

 2 yiyj ie ,xi-xj  2nR.
j[n]

Now, we complete the proof. By Lemma D.2, replacing one xi with another xi (whose norm is also bounded by Rx) changes v(n)()/n2 by at most 4RxR/n. Then, by McDiarmid's inequality
(McDiarmid, 1989), we have the following fact:

Lemma D.3 (Pointwise concentration of v(n)). For all    and  > 0,

Pr

1 n2

v(n)()

-

videal()



 exp

-n2 8Rx2 R2

.

Now, let W be an (/R)-net of the set {   :   R}.

Applying the union bound on Lemma D.3 with  ranging over each element of W , we have

Pr

1 n2

v

(n)

()

-

videal()

 ,

  R

 Pr

1 n2

v(n)()

-

videal()



 R

,

  W

 |W | · exp

-n2 8Rx2 R4



2R 

d
exp

-n2 8Rx2 R4

.

15

Under review as a conference paper at ICLR 2018

To make the LHS smaller than , it suffices to choose

n



8Rx2 R4 (d log

2R 

2

+ log

1 

)

,

which is the claimed sample complexity.

16

