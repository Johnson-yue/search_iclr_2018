Under review as a conference paper at ICLR 2018

GLOBAL CONVERGENCE OF POLICY GRADIENT METHODS FOR LINEARIZED CONTROL PROBLEMS
Anonymous authors Paper under double-blind review

ABSTRACT
Direct policy gradient methods for reinforcement learning and continuous control problems are a popular approach for a variety of reasons: 1) they are easy to implement without explicit knowledge of the underlying model 2) they are an "end-to-end" approach, directly optimizing the performance metric of interest 3) they inherently allow for richly parameterized policies. A notable drawback is that even in the most basic continuous control problem (that of linear quadratic regulators), these methods must solve a non-convex optimization problem, where little is understood about their efficiency from both computational and statistical perspectives. In contrast, system identification and model based planning in optimal control theory have a much more solid theoretical footing, where much is known with regards to their computational and statistical properties. This work bridges this gap showing that (model free) policy gradient methods globally converge to the optimal solution and are efficient (polynomially so in relevant problem dependent quantities) with regards to their sample and computational complexities.

1 INTRODUCTION

Recent years have seen major advances in the control of uncertain dynamical systems using reinforcement learning and data-driven approaches; examples range from allowing robots to perform more sophisticated controls tasks such as robotic hand manipulation (Tassa et al., 2012; Al Borno et al., 2013; Kumar et al., 2016; Levine et al., 2016; Tobin et al., 2017; Rajeswaran et al., 2017a), to sequential decision making in game domains, e.g. AlphaGo (Silver et al., 2016) and Atari game playing (Mnih et al., 2015). Deep reinforcement learning (DeepRL) are becoming increasingly popular for tackling such challenging sequential decision making problems.
Many of these successes have relied on sampling based reinforcement learning algorithms such as policy gradient methods, including the DeepRL approaches; here, there is little theoretical understanding of their efficiency, either from a statistical or a computational perspective. In contrast, control theory (optimal and adaptive control) has a rich body of tools, with provable guarantees, for related sequential decision making problems, particularly those that involve continuous control. These latter techniques are often model-based -- they estimate an explicit dynamical model first (e.g. system identification) and then design optimal controllers.
This work builds bridges between these two lines of work, namely, between optimal control theory and sample based reinforcement learning methods, using ideas from mathematical optimization.

1.1 THE OPTIMAL CONTROL PROBLEM

In the standard optimal control problem, the dynamics model ft, where ft is specified as

xt+1 = ft(xt, ut, wt) ,

maps a state xt  Rd, a control (the action) ut  Rk, and a disturbance wt, to the next state xt+1  Rd. The objective is to find the control input ut which minimizes the long term cost,

T

minimize

ct(xt, ut)

t=1

such that xt+1 = ft(xt, ut, wt) .

1

Under review as a conference paper at ICLR 2018

Here the ut are allowed to depend on the history of observed states.

In practice, this is often solved by considering the linearized control (sub-)problem where the dynamics are approximated by
xt+1 = Atxt + Btut + wt,
and the costs are approximated by a quadratic function in xt and ut, e.g. (Todorov & Li, 2004). This work considers an important special case: the time homogenous, infinite horizon problem referred to as the linear quadratic regulator (LQR) problem. The results herein can also be extended to the finite horizon, time in-homogenous setting, discussed in Section 5.

In the LQR problem, the objective is

minimize such that


E (xt Qxt + ut Rut)
t=0
xt+1 = Axt + But , x0  D .

where initial state x0  D is assumed to be randomly distributed according to distribution D; the matrices A  Rd×d and B  Rd×k are referred to as system (or transition) matrices; Q  Rd×d and R  Rk×k are both positive definite matrices that parameterize the quadratic costs. For clarity, this work does not consider a noise disturbance but only a random initial state. The importance of (some) randomization for analyzing direct methods is discussed in Section 3.

Throughout, assume that A and B are such that the optimal cost is finite (for example, the control-

lability of the pair (A, B) would ensure this). Optimal control theory (Anderson & Moore, 1990;

Evans, 2005; Bertsekas, 2011; 2017) shows that the optimal control input can be written as a linear

function in the state,

ut = -Kxt

where K  Rk×d.

Planning with a known model. Planning can be achieved by solving the algebraic Riccati equation,

P = AT P A + Q - AT P B(BT P B + R)-1BT P A ,

(1)

for a positive definite matrix P which parameterizes the "cost-to-go" (the optimal cost from a state going forward). The optimal control gain is then given as:

K = -(BT P B + R)-1BT P A.

(2)

There are both algebraic solution methods to find P and (convex) SDP formulations to solve for P . More broadly, even though there are convex formulations for planning, these formulations: 1) do not directly parameterize the policy 2) they are not "end-to-end" approaches in that they are not directly optimizing the cost function of interest and 3) it is not immediately clear how to utilize these approaches in the model-free setting, where the agent only has simulation access. These formulations are discussed in Section A, where there is a discussion of how the standard SDP formulation is not a direct method that minizes the cost over the set of feasible policies.

1.2 CONTRIBUTIONS OF THIS WORK
Even in the most basic case of the standard linear quadratic regulator model, little is understood as to how direct (model-free) policy gradient methods fare. This work provides rigorous guarantees, showing that, while in fact the approach is a non-convex one, directly using (model free) local search methods leads to finding the globally optimal policy. The main contributions are as follows:
· (Exact case) Even with access to exact gradient evaluation, little is understood about whether or not convergence to the optimal policy occurs, even in the limit, due to the non-convexity in the problem. This work shows that global convergence does indeed occur (and does so efficiently) for local search based methods.
· (Model free case) Without a model, this work shows how one can use simulated trajectories (as opposed to having knowledge of the model) in a stochastic policy gradient method where provable convergence to a globally optimal policy is guaranteed, with (polynomially) efficient computational and sample complexities.

2

Under review as a conference paper at ICLR 2018
· (The natural policy gradient) Natural policy gradient methods (Kakade, 2001) -- and related algorithms such as Trust Region Policy Optimization (Schulman et al., 2015) and the natural actor critic (Peters & Schaal, 2007) -- are some of the most widely used and effective policy gradient methods (see Duan et al. (2016)). While many results argue in favor of this method based on either information geometry (Kakade, 2001; Bagnell & Schneider, 2003) or based on connections to actor-critic methods (Deisenroth et al., 2013), these results do not provably show an improved convergence rate. This work is the first to provide a guarantee that the natural gradient method enjoys a considerably improved convergence rate over its naive gradient counterpart.
More broadly, the techniques in this work merge ideas from optimal control theory, mathematical (and zeroth order) optimization, and sample based reinforcement learning methods. These techniques may ultimately help in improving upon the existing set of algorithms, addressing issues such as variance reduction or improving upon the natural policy gradient method (with, say, a GaussNewton method). The Discussion touches upon some of these issues.
1.3 RELATED WORK
In the reinforcement learning setting, the model is unknown, and the agent must learn to act through its interactions with the environment. Here, solution concepts are typically divided into: modelbased approaches, where the agent attempts to learn a model of the world, and model-free approaches, where the agent directly learns to act and does not explicitly learn a model of the world. The related work on provably learning LQRs is reviewed from this perspective.
Model-based learning approaches. In the context of LQRs, the agent attempts to learn the dynamics of "the plant" (i.e. the model) and then plans, using this model, for control synthesis. Here, the classical approach is to learn the model with subspace identification (Ljung, 1999). Fiechter (1994) provides a provable learning (and non-asymptotic) result, where the quality of the policy obtained is shown to be near optimal (efficiency is in terms of the persistence of the training data and the controllability Gramian). Abbasi-Yadkori & Szepesva´ri (2011) also provides provable, nonasymptotic learning results (in a regret context), using a bandit algorithm that achieves lower sample complexity (by balancing exploration-exploitation more effectively); the computational efficiency of this approach is less clear.
More recently, Dean et al. (2017) expands on an explicit system identification process, where a robust control synthesis procedure is adopted that relies on a coarse model of the plant matrices (A and B are estimated up to some accuracy level, naturally leading to a "robust control" setup). Arguably, this is the most general (and non-asymptotic) result, that is efficient from both a statistical perspective (computationally, the method works with a finite horizon to approximate the infinite horizon). This result only needs the plant to be controllable; the work herein needs the stronger assumption that the initial policy in the local search procedure is a stable controller (an assumption which may be inherent to local search procedures, discussed in Section 5).
Model-free learning approaches. Model-free approaches that do not rely on an explicit system identification step typically either: 1) estimate value functions (or state-action values) through Monte Carlo simulation which are then used in some approximate dynamic programming variant (Bertsekas, 2011) or 2) directly optimize a (parameterized) policy, also through Monte Carlo simulation. Model-free approaches for learning optimal controllers is not well understood, from a theoretical perspective. Here, Bradtke et al. (1994) provides an asymptotic learnability result using a value function approach, namely Q-learning.
2 PRELIMINARIES AND BACKGROUND
2.1 EXACT GRADIENT DESCENT
This work seeks to characterize the behavior of (direct) policy gradient methods, where the policy is linearly parameterized, as specified by a matrix K  Rk×d which generates the controls:
ut = -Kxt
3

Under review as a conference paper at ICLR 2018

for t  0. The cost of this K is denoted as:



C(K) := Ex0D

(xt Qxt + ut Rut)

t=0

where {xt, ut} is the trajectory induced by following K, starting with x0  D. The importance of (some) randomization, either in x0 or noise through having a disturbance, for analyzing gradient methods is discussed in Section 3. Here, K is a minimizer of C(·).

Gradient descent on C(K), with a fixed stepsize , follows the update rule:

K  K - C(K) .

It is helpful to explicitly write out the functional form of the gradient. Define PK as the solution to: PK = Q + K RK + (A - BK) PK (A - BK) .
and, under this definition, it follows that C(K) can be written as:

C(K) = Ex0D x0 PK x0 .
Also, define K as the (un-normalized) state correlation matrix, i.e.

K = Ex0D xtxt .
t=0
Lemma 1. (Policy Gradient Expression) The policy gradient is:

C(K) = 2 (R + B PK B)K - B PK A K

Proof. Observe:
x0 PK x0 = x0 Q + K RK x0 + x0 (A - BK) PK (A - BK)x0 .
This implies:
x0 PK x0 = 2RKx0x0 - 2B PK (A - BK)x0x0 + x0 (A - BK) PK (A - BK)x0 = 2 (R + B PK B)K - B PK A x0x0 + x1 PK x1

= 2 (R + B PK B)K - B PK A xtxt
t=0
using recursion and that x1 = (A - BK)x0. Taking expectations completes the proof.

2.2 REVIEW: (MODEL FREE) SAMPLE BASED POLICY GRADIENT METHODS

Sample based policy gradient methods introduce some randomization for estimating the gradient.

REINFORCE. Let (u|x) be a parametric stochastic policy, where u  (·|x). The policy gradient of the cost, C(), is:



C() = E

Qt (xt, ut) log (ut|xt) , where Q (x, u) = E

ct|x0 = x, u0 = u ,

t=0 t=0

where the expectation is with respect to the trajectory {xt, ut} induced under the policy  and where Q (x, u) is referred to as the state-action value. The REINFORCE algorithm uses Monte Carlo estimates of the gradient obtained by simulating .
The natural policy gradient. The natural policy gradient (Kakade, 2001) follows the update:



   -  G- 1C() , where G = E

 log (ut|xt) log (ut|xt)

t=0

,

4

Under review as a conference paper at ICLR 2018

where G is the Fisher information matrix. There are numerous succesful related approaches (Peters & Schaal, 2007; Schulman et al., 2015; Duan et al., 2016). An important special case is using a linear
policy with additive Gaussian noise (Rajeswaran et al., 2017b), i.e.

K (x, u) = N (Kx, 2I)

(3)

where K  Rk×d and 2 is the noise variance. Here, the natural policy gradient of K (when  is considered fixed) takes the form:

K  K - C(K)K-1

(4)

To see this, one can verify that the Fisher matrix of size kd × kd, which is indexed as [GK ](i,j),(i ,j ) where i, i  {1, . . . k} and j, j  {1, . . . d}, has a block diagonal form where the only non-zeros
blocks are [GK ](i,·),(i,·) = K (this is the block corresponding to the i-th coordinate of the action, as i ranges from 1 to k). This form holds more generally, for any diagonal noise.

Zeroth order optimization. Zeroth order optimization is a generic procedure (Conn et al., 2009; Nesterov & Spokoiny, 2015) for optimizing a function f (x), using only query access to the function values of f (·) at input points x (and without explicit query access to the gradients of f ). This is also the approach in using "evolutionary strategies" (Salimans et al., 2017). The generic approach can be described as follows: define the perturbed function as

f2 (x) = EN (0,2I)[f (x + )]
For small , the smooth function is a good approximation to the original function. Due to the Gaussian smoothing, the gradient has the particularly simple functional form (see Conn et al. (2009); Nesterov & Spokoiny (2015)):
1 f2 (x) = 2 EN (0,2I)[f (x + )] . This expression implies a straightforward method to obtain an unbiased estimate of the f2 (x), through obtaining only the function values f (x + ) for random .

3 THE (NON-CONVEX) OPTIMIZATION LANDSCAPE
This section provides a brief characterization of the optimization landscape, in order to help provide intuition as to why global convergence is possible and as to where the analysis difficulties lie. Lemma 2. (Non-convexity) If d  3, there exists an LQR optimization problem, minK C(K), which is not convex, quasi-convex, and star-convex.
Section B provides a specific example. In general, for a non-convex optimization problem, gradient descent may not even converge to the global optima in the limit. For the case of LQRs, the following corollary (of Lemma 8) provides a characterization of the stationary points. Corollary 3. (Stationary point characterization) If C(K) = 0, then either K is an optimal policy or K is rank deficient.
This lemma is the motivation for using a distribution over x0 (as opposed to a deterministic starting point): Ex0Dx0x0 being full rank guarantees that K is full rank, which implies all stationary points are a global optima. An additive disturbance in the dynamics model also suffices.
The concept of gradient domination is important in the non-convex optimization literature (Polyak, 1963; Nesterov & Polyak, 2006; Karimi et al., 2016). A function f : Rd  R is said to be gradient dominated if there exists some constant , such that for all x,
f (x) - min f (x )   f (x) 2 .
x
If a function is gradient dominated, this implies that if the magnitude of the gradient is small at some x, then the function value at x will be close to that of the optimal function value.
The following corollary of Lemma 8 shows that C(K) is gradient dominated. Corollary 4. (Gradient Domination) Suppose Ex0Dx0x0 is full rank. Then C(K) is gradient dominated, i.e.
C(K) - C(K)   C(K), C(K) where  is a problem dependent constant (and ·, · denotes the trace inner product).

5

Under review as a conference paper at ICLR 2018

With gradient domination and no (spurious) local optima, one may hope that recent results on escaping saddle points (Nesterov & Polyak, 2006; Ge et al., 2015; Jin et al., 2017) immediately imply that gradient descent converges quickly. This is not the case due to that it is not straightforward to characterize the (local) smoothness properties of C(K); this is a difficulty well studied in the optimal control theory literature, related to robustness and stability. In fact, if it were the case that C(K) is a smooth function1 (in addition to being gradient dominated), then classical mathematical optimization results (Polyak, 1963) would not only immediately imply global convergence, these results would also imply convergence at a linear rate.

4 MAIN RESULTS

First, results on exact gradient methods are provided. From an analysis perspective, this is the natural starting point; once global convergence is established for exact methods, the question of using simulation-based, model-free methods can be approached with zeroth-order optimization methods.
Notation. Z denotes the spectral norm of a matrix Z; Tr(Z) denotes the trace of a square matrix; min(Z) denotes the minimal singular value of a square matrix Z. Also, it is helpful to define
µ := min(Ex0Dx0x0 )

4.1 MODEL-BASED OPTIMIZATION: EXACT GRADIENT METHODS

The following three exact update rules are considered:

Gradient descent: Kn+1 = Kn - C(Kn)

(5)

Natural policy gradient descent: Kn+1 = Kn - C(Kn)K-1n

(6)

Gauss-Newton: Kn+1 = Kn - (R + B PKn B)-1C(Kn)K-1n . (7)

The natural policy gradient descent direction is defined so that it is consistent with the stochastic

case, as per Equation 4. It is straightforward to verify that the policy iteration algorithm is a special

case of the Gauss-Newton method when  = 1 (for the case of policy iteration, convergence in the

limit is provided in Todorov & Li (2004); Ng et al. (2002); Liao & Shoemaker (1991), along with

local convergence rates.)

The Gauss-Newton method requires the most complex oracle to implement: it requires access to C(K), K, and R+B PKB; it also enjoys the strongest convergence rate guarantee. At the other extreme, gradient descent requires oracle access to only C(K) and has the slowest convergence rate. The natural policy gradient sits in between, requiring oracle access to C(K) and K, and having a convergence rate between the other two methods.
Theorem 5. (Global Convergence of Gradient Methods) Suppose C(K0) is finite and and µ > 0.

· Gauss-Newton case: For a stepsize  = 1 and for N > K log C(K0) - C(K) , µ
the Gauss-Newton algorithm (Equation 7) enjoys the following performance bound: C(KN ) - C(K)  

· Natural policy gradient case: For a stepsize

1

=

R+

B 2C(K0) µ

and for

N > K µ

R + B 2C(K0) log C(K0) - C(K) ,

min(R) µmin(R)



natural policy gradient descent (Equation 6) enjoys the following performance bound:

C(KN ) - C(K)   .

1A differentiable function f (x) is said to be smooth if the gradients of f are continuous.

6

Under review as a conference paper at ICLR 2018

Algorithm 1 Model-Free Policy Gradient (and Natural Policy Gradient) Estimation
1: Input: K, number of trajectories m, roll out length , smoothing parameter r, dimension d 2: for i = 1, · · · m do
3: Sample a policy Ki = K + Ui, where Ui is drawn uniformly at random over matrices whose (Frobenius) norm is r.
4: Simulate Ki for steps starting from x0  D. Let Ci and i be the empirical estimates:

Ci = ct , i = xtxt
t=1 t=1

where ct and xt are the costs and states on this trajectory. 5: end for
6: Return the (biased) estimates:

C(K) = 1 m

m

d r2 CiUi ,

i=1

1m K = m i
i=1

· Gradient descent case: For an appropriate (constant) setting of the stepsize ,

 = poly

µmin(Q) , C (K0 )

1 A

,

1 B

,

1 R

, min(R)

and for

N  K log C(K0) - C(K)  poly C(K0) , A , B , R , 1

µ

µmin(Q)

min(R)

gradient descent (Equation 5) enjoys the following performance bound:

C(KN ) - C(K)   .

,

In comparison to model-based approaches, these results require the (possibly) stronger assumption that the initial policy is a stable controller, i.e. C(K0) is finite (an assumption which may be inherent to local search procedures). The Discussion mentions this as direction of future work.

4.2 MODEL FREE OPTIMIZATION: SAMPLE BASED POLICY GRADIENT METHODS

In the model free setting, the controller has only simulation access to the model; the model parameters, A, B, Q and R, are unknown. The standard optimal control theory approach is to use system identification to learn the model, and then plan with this learned model This section proves that model-free, policy gradient methods also lead to globally optimal policies, with both polynomial computational and sample complexities (in the relevant quantities).
Using a zeroth-order optimization approach (see Section 2.2), Algorithm 1 provides a procedure to
find (controllably biased) estimates, C(K) and K, of both C(K) and K. These can then be used in the policy gradient and natural policy gradient updates as follows:

Gradient descent: Kn+1 = Kn - C(Kn)

(8)

Natural policy gradient descent: Kn+1 = Kn - C(Kn)K-1n ,

(9)

where Algorithm 1 is called at every iteration to provide the estimates of C(Kn) and Kn .

The choice of using zeroth order optimization vs using REINFORCE (with Gaussian additive noise, as in Equation 3) is primarily for technical reasons2. It is plausible that the REINFORCE estimation
procedure has lower variance. One additional minor difference, again for technical reasons, is that
Algorithm 1 uses a perturbation from the surface of a sphere (as opposed to a Gaussian perturbation).

2The correlations in the state-action value estimates in REINFORCE are more challenging to analyze.

7

Under review as a conference paper at ICLR 2018

Theorem 6. (Global Convergence in the Model Free Setting) Suppose C(K0) is finite, µ > 0, and that x0  D has norm bounded by L almost surely. Also, for both the policy gradient method and
the natural policy gradient method, suppose Algorithm 1 is called with parameters:

m, , 1/r = poly

11 C(K0), µ , min(Q) ,

A

,

B

,

R

, 1 , d, 1/ , L2/µ min(R)

.

· Natural policy gradient case: For a stepsize

1

=

R+

B 2C(K0) µ

and for

N > K µ

R + B 2C(K0) log 2(C(K0) - C(K)) ,

min(R) µmin(R)



then, with high probability, i.e. with probability greater than 1 - exp(-d), the natural policy gradient descent update (Equation 9) enjoys the following performance bound:

C(KN ) - C(K)   .

· Gradient descent case: For an appropriate (constant) setting of the stepsize ,

 = poly

µmin(Q) , C (K0 )

1 A

,

1 B

,

1 R

, min(R)

and if N satisfies

N  K log C(K0) - C(K)  poly C(K0) , A , B , R , 1

,

µ

µmin(Q)

min(R)

then, with high probability, gradient descent (Equation 8) enjoys the following performance

bound:

C(KN ) - C(K)   .

5 CONCLUSIONS AND DISCUSSION
This work has provided provable guarantees that model-based gradient methods and model-free (sample based) policy gradient methods convergence to the globally optimal solution, with finite polynomial computational and sample complexities. Taken together, the results herein place these popular and practical policy gradient approaches on a firm theoretical footing, making them comparable to other principled approaches (e.g. subspace ID methods and algebraic iterative approaches).
Finite C(K0) assumption, noisy case, and finite horizon case. These methods allow for extensions to the noisy case and the finite horizon case. This work also made the assumption that C(K0) is finite, which may not be easy to achieve in some infinite horizon problems. The simplest way to address this is to model the infinite horizon problem with a finite horizon one; the techniques developed in Section D.1 shows this is possible. This is an important direction for future work.
Open Problems.
· Variance reduction: This work only proved efficiency from a polynomial sample size perspective. An interesting future direction would be in how to rigorously combine variance reduction methods and model-based methods to further decrease the sample size.
· A sample based Gauss-Newton approach: This work showed how the Gauss-Newton algorithm improves over even the natural policy gradient method, in the exact case. A practically relevant question for the Gauss-Newton method would be how to both: a) construct a sample based estimator b) extend this scheme to deal with (non-linear) parametric policies.
· Robust control: In model based approaches, optimal control theory provides efficient procedures to deal with (bounded) model mis-specification. An important question is how to provably understand robustness in a model free setting.

8

Under review as a conference paper at ICLR 2018
REFERENCES
Yasin Abbasi-Yadkori and Csaba Szepesva´ri. Regret bounds for the adaptive control of linear quadratic systems. Conference on Learning Theory, 2011. ISSN 15337928.
M. Al Borno, M. de Lasa, and A. Hertzmann. Trajectory Optimization for Full-Body Movements with Complex Contacts. IEEE Transactions on Visualization and Computer Graphics, 2013.
Brian D. O. Anderson and John B. Moore. Optimal Control: Linear Quadratic Methods. PrenticeHall, Inc., Upper Saddle River, NJ, USA, 1990. ISBN 0-13-638560-5.
J. Andrew Bagnell and Jeff Schneider. Covariant policy search. In Proceedings of the 18th International Joint Conference on Artificial Intelligence, IJCAI'03, pp. 1019­1024, San Francisco, CA, USA, 2003. Morgan Kaufmann Publishers Inc. URL http://dl.acm.org/citation. cfm?id=1630659.1630805.
V. Balakrishnan and L. Vandenberghe. Semidefinite programming duality and linear time-invariant systems. IEEE Transactions on Automatic Control, 48(1):30­41, 2003.
Dimitri P. Bertsekas. Approximate policy iteration: A survey and some new methods. Journal of Control Theory and Applications, 9(3):310­335, 2011. ISSN 16726340. doi: 10.1007/ s11768-011-1005-3.
Dimitri P. Bertsekas. Dynamic Programming and Optimal Control. Athena Scientific, 2017.
S.J. Bradtke, B.E. Ydstie, and a.G. Barto. Adaptive linear quadratic control using policy iteration. Proceedings of American Control Conference, 3(2):3475­3479, 1994. doi: 10.1109/ACC.1994. 735224.
E.F. Camacho and C. Bordons. Model Predictive Control. Advanced Textbooks in Control and Signal Processing. Springer London, 2004. ISBN 9781852336943.
A.R. Conn, K. Scheinberg, and L.N. Vicente. Introduction to derivative-free optimization, volume 8 of MPS/SIAM Series on Optimization. Society for Industrial and Applied Mathematics (SIAM), Philadelphia, PA; Mathematical Programming Society (MPS), Philadelphia, PA, 2009.
S. Dean, H. Mania, N. Matni, B. Recht, and S. Tu. On the sample complexity of the linear quadratic regulator. ArXiv e-prints, 2017.
Marc Peter Deisenroth, Gerhard Neumann, and Jan Peters. A survey on policy search for robotics. Found. Trends Robot, 2(1&#8211;2):1­142, August 2013. ISSN 1935-8253. doi: 10.1561/2300000021. URL http://dx.doi.org/10.1561/2300000021.
Y. Duan, X. Chen, R. Houthooft, J. Schulman, and P. Abbeel. Benchmarking deep reinforcement learning for continuous control. In ICML, 2016.
Lawrence C. Evans. An introduction to mathematical optimal control theory. University of California, Department of Mathematics, pp. 126, 2005. ISSN 14712334. doi: 10.1186/ 1471-2334-10-32.
Claude-Nicolas Fiechter. PAC adaptive control of liner systems. In Proceeding COLT '94 Proceedings of the seventh annual conference on Computational learning theory, pp. 88­97, 1994.
Abraham D Flaxman, Adam Tauman Kalai, and H Brendan McMahan. Online convex optimization in the bandit setting: gradient descent without a gradient. In Proceedings of the sixteenth annual ACM-SIAM symposium on Discrete algorithms, pp. 385­394. Society for Industrial and Applied Mathematics, 2005.
Rong Ge, Furong Huang, Chi Jin, and Yang Yuan. Escaping from saddle points - online stochastic gradient for tensor decomposition. Proceedings of The 28th Conference on Learning Theory, COLT 2015, Paris, France, July 3-6, 2015, 2015.
Chi Jin, Rong Ge, Praneeth Netrapalli, Sham M. Kakade, and Michael I. Jordan. How to escape saddle points efficiently. In Proceedings of the 34th International Conference on Machine Learning, ICML 2017, Sydney, NSW, Australia, 6-11 August 2017, pp. 1724­1732, 2017.
9

Under review as a conference paper at ICLR 2018
S. Kakade. A natural policy gradient. In NIPS, 2001.
S. Kakade and J. Langford. Approximately optimal approximate reinforcement learning. In ICML, 2002.
S. M. Kakade. On the sample complexity of reinforcement learning. PhD thesis, Gatsby Computational Neuroscience Unit, University College, London, 2003.
Hamed Karimi, Julie Nutini, and Mark Schmidt. Linear convergence of gradient and proximalgradient methods under the polyak-lojasiewicz condition. Machine Learning and Knowledge Discovery in Databases: European Conference, ECML PKDD 2016, Riva del Garda, Italy, September 19-23, 2016, Proceedings, Part I, pp. 795­811, 2016.
D. L. Kleinman. On an iterative technique for Riccati equation computations. IEEE Transactions on Automatic Control, 13(1):114­115, 1968. ISSN 0018-9286. doi: 10.1109/TAC.1968.1098829.
V. Kumar, E. Todorov, and S. Levine. Optimal control with learned local models: Application to dexterous manipulation. In ICRA, 2016.
P. Lancaster and L. Rodman. Algebraic Riccati Equations. Oxford science publications. Clarendon Press, 1995. ISBN 9780191591259.
Sergey Levine, Chelsea Finn, Trevor Darrell, and Pieter Abbeel. End-to-end training of deep visuomotor policies. JMLR, 17(39):1­40, 2016.
L. Z. Liao and C. A. Shoemaker. Convergence in unconstrained discrete-time differential dynamic programming. IEEE Transactions on Automatic Control, 36, 1991.
Lennart Ljung (ed.). System Identification (2Nd Ed.): Theory for the User. Prentice Hall PTR, Upper Saddle River, NJ, USA, 1999. ISBN 0-13-656695-2.
Karl Ma°rtensson. Gradient methods for large-scale and distributed linear quadratic control. Ph.D. Theses, 2012.
Karl Ma°rtensson and Anders Rantzer. Gradient methods for iterative distributed control synthesis. Conference on Decision and Control, pp. 1­6, 2009.
Volodymyr Mnih, Koray Kavukcuoglu, David Silver, Andrei A. Rusu, Joel Veness, Marc G. Bellemare, Alex Graves, Martin Riedmiller, Andreas K. Fidjeland, Georg Ostrovski, Stig Petersen, Charles Beattie, Amir Sadik, Ioannis Antonoglou, Helen King, Dharshan Kumaran, Daan Wierstra, Shane Legg, and Demis Hassabis. Human-level control through deep reinforcement learning. Nature, 518, 2015.
Yurii Nesterov and Boris T. Polyak. Cubic regularization of newton method and its global performance. Math. Program., pp. 177­205, 2006.
Yurii Nesterov and Vladimir Spokoiny. Random gradient-free minimization of convex functions. Foundations of Computational Mathematics, pp. 1­40, 2015. ISSN 1615-3383.
Chi-Kong Ng, Li-Zhi Liao, and Duan Li. A globally convergent and efficient method for unconstrained discrete-time optimal control. J. Global Optimization, 23:401­421, 2002.
J. Peters and S. Schaal. Natural actor-critic. Neurocomputing, 71:1180­1190, 2007.
E. Polak. An Historical Survey of Computational Methods in Optimal Control. SIAM Review, 15 (2):pp. 553­584, 1973. ISSN 00361445. doi: 10.1137/1015071.
B. T. Polyak. Gradient methods for minimizing functionals. USSR Computational Mathematics and Mathematical Physics, 3(4):864878, 1963.
Aravind Rajeswaran, Vikash Kumar, Abhishek Gupta, John Schulman, Emanuel Todorov, and Sergey Levine. Learning complex dexterous manipulation with deep reinforcement learning and demonstrations. CoRR, abs/1709.10087, 2017a. URL http://arxiv.org/abs/1709. 10087.
10

Under review as a conference paper at ICLR 2018
Aravind Rajeswaran, Kendall Lowrey, Emanuel Todorov, and Sham Kakade. Towards generalization and simplicity in continuous control. CoRR, abs/1703.02660, 2017b. URL http://arxiv. org/abs/1703.02660.
J.B. Rawlings and D.Q. Mayne. Model Predictive Control: Theory and Design. Nob Hill Pub., 2009. ISBN 9780975937709.
Tim Salimans, Jonathan Ho, Xi Chen, and Ilya Sutskever. Evolution strategies as a scalable alternative to reinforcement learning. ArXiv e-prints, 2017.
J. Schulman, S. Levine, P. Moritz, M. Jordan, and P. Abbeel. Trust region policy optimization. In ICML, 2015.
David Silver, Aja Huang, Chris J. Maddison, Arthur Guez, Laurent Sifre, George van den Driessche, Julian Schrittwieser, Ioannis Antonoglou, Veda Panneershelvam, Marc Lanctot, Sander Dieleman, Dominik Grewe, John Nham, Nal Kalchbrenner, Ilya Sutskever, Timothy Lillicrap, Madeleine Leach, Koray Kavukcuoglu, Thore Graepel, and Demis Hassabis. Mastering the game of go with deep neural networks and tree search. Nature, 529, 2016.
Y. Tassa, T. Erez, and E. Todorov. Synthesis and stabilization of complex behaviors through online trajectory optimization. International Conference on Intelligent Robots and Systems, 2012.
Josh Tobin, Rachel Fong, Alex Ray, Jonas Schneider, Wojciech Zaremba, and Pieter Abbeel. Domain randomization for transferring deep neural networks from simulation to the real world. ArXiv e-prints, 2017.
Emanuel Todorov and Weiwei Li. A generalized iterative lqg method for locally-optimal feedback control of constrained nonlinear stochastic systems. In American Control Conference, 2004.
11

Under review as a conference paper at ICLR 2018
A PLANNING WITH A MODEL
This section briefly reviews some parameterizations and solution methods for the classic LQR and related problems from control theory.
Finite horizon LQR. First, consider the finite horizon case. The basic approach is to view it as a dynamic program with the value function xTt Ptxt, where
Pt-1 = Q + AT PkA - AT PtB(R + BT PtB)-1BT PtA,
which in turn gives optimal control
ut = -Ktxt = -(R + BT Pt+1B)-1BT Pt+1Axt
(recursions run backward in time).
Another approach is to view the LQR problem as a linearly-constrained Quadratic Program in all xt and ut (where the constraints are given by the dynamics, and the problem size equals the horizon). The QP is clearly a convex problem, but this observation is not useful by itself as the problem size grows with the horizon, and naive use of quadratic programming scales badly. However, the special structure due to linear dynamics allows for simplifications and control-theoretic interpretation as follows: the Lagrange multipliers can be interpreted as "co-state" variables, and they follow a recursion that runs backwards in time known as the "adjoint system". Using Lagrange duality, one can show that this approach is equivalent to solving the Riccati recursion mentioned above.
Popular use of the LQR in control practice is often in the receding horizon LQR, Camacho & Bordons (2004); Rawlings & Mayne (2009): at time t, an input sequence is found that minimizes the T -step ahead LQR cost starting at the current time, then only the first input in the sequence is used. The resulting static feedback gain converges to the infinite horizon optimal solution as horizon T becomes longer.
Infinite horizon LQR. Here, the constrained optimization view (QP) is not informative as the problem is infinite dimensional; the dynamic programming viewpoint readily extends. Suppose the system A, B is controllable (which guarantees optimal cost is finite). It turns out that the value function and the optimal controller are static (do not depend on t) and can be found by solving the Algebraic Riccati Equation (ARE) given in (1). The optimal K can then be found from equation (2).
The main computational step is solving the ARE, which is extensively studied (e.g. (Lancaster & Rodman, 1995)). One approach due to Kleinman (1968) is to simply run the recursion Pk+1 = Q + AT PkA - AT PkB(R + BT PkB)-1BT PkA with P1 = Q, which converges to the unique positive semidefinite solution of the ARE (since the fixed-point iteration is contractive). Other approaches are direct and based on linear algebra, which carry out an eigenvalue decomposition on a certain block matrix followed by a matrix inversion (Lancaster & Rodman, 1995).
Direct computation of the control input has also been considered in the optimal control literature, e.g., gradient updates in function spaces (Polak, 1973). For the linear quadratic setup, direct iterative computation of the feedback gain has been examined in (Ma°rtensson & Rantzer, 2009), and explored further in (Ma°rtensson, 2012) with a view towards distributed implementations. There methods are presented as local search heuristics without provable guarantees of reaching the optimal policy.
SDP formulation. The LQR problem can also be expressed as a semidefinite program (SDP) with variable P , as given in (Balakrishnan & Vandenberghe, 2003) (section 5, equation (34), this is for a continuous-time system but there are similar discrete-time versions). This SDP can be derived by relaxing the equality in the Riccati equation to an inequality, then using the Schur complement formula to rewrite the resulting Riccati inequality as linear matrix inequality; the objective in the case of LQR is the trace of the positive definite matrix variable. This formulation and its dual has been explored in (Balakrishnan & Vandenberghe, 2003).
It is important to note that while the optimal solution of this SDP is the unique positive semidefinite solution to the Riccati equation, which in turn gives the optimal policy K, other feasible P (not equal to P ) do not necessarily correspond to a feasible, stabilizing policy K. This means that the feasible set of this SDP is not a convex characterization of all P that correspond to stabilizing K. Thus it also implies that if one uses any optimization algorithm that maintains iterates in the
12

Under review as a conference paper at ICLR 2018

feasible set (e.g. interior point methods), no useful policy can be extracted from the iterates before convergence to P . For this reason, this convex formulation is not helpful for parametrizing the space of policies K in manner that supports the use of local search methods (those that directly lower the cost function of interest), which is the focus of this work.

B NON-CONVEXITY OF THE SET OF STABILIZING STATE FEEDBACK GAINS

Let K(A, B) denote the set of state feedback gains K such that A - BK is stable, i.e., its eigen-
values are inside the unit circle in the complex plane. This set is generally nonconvex. A concise counterexample to convexity is provided here. Let A and B be 3 × 3 identity matrices and

1 0 -10
K1 = -1 1 0 00 1

1 -10 0
and K2 = 0 1 0 . -1 0 1

Then the spectra of A - BK1 and A - BK2 are both concentrated at the origin, yet two of the
eigenvalues of A - BK with K = (K1 + K2)/2, are outside of the unit circle in the complex plane.

C ANALYSIS: THE EXACT CASE

This section provides the analysis of the convergence rates of the (exact) gradient based methods. First, some helpful lemmas for the analysis are provided.
Throughout, it is convenient to use the following definition:
EK := (R + B PK B)K - B PK A . The policy gradient can then be written as:
C(K) = 2 (R + B PK B)K - B PK A K =

C.1 HELPER LEMMAS

Define the value VK (x), the state-action value QK (x, u), and the advantage AK (x, u). VK (x, t) is the cost of the policy starting with x0 = x and proceeding with K onwards:



VK (x) :=

xt Qxt + ut Rut

t=0

= x PK x .

QK (x, u) is the cost of the policy starting with x0 = x, taking action u0 = u and then proceeding with K onwards:
QK (x, u) := x Qx + u Ru + VK (Ax + Bu)
The advantage AK (x, u) is:

AK (x, u) = QK (x, u) - VK (x) .

The advantage can be viewed as the change in cost starting at state x and taking a one step deviation from the policy K.

The next lemma is identical to that in (Kakade & Langford, 2002; Kakade, 2003) for Markov decision processes.
Lemma 7. (Cost difference lemma) Suppose K and K have finite costs. Let {xt} and {ut} be state and action sequences generated by K , i.e. starting with x0 = x and using ut = -K xt. It holds that:
VK (x) - VK (x) = AK (xt, ut) .
t
Also, for any x, the advantage is:

AK (x, K x) = 2x (K - K) EK x + x (K - K) (R + B PK B)(K - K)x . (10)

13

Under review as a conference paper at ICLR 2018

Proof. Let ct be the cost sequence generated by K . Telescoping the sum appropriately:

VK (x) - VK (x) =

ct - VK (x)

t=0

= (ct + VK (xt) - VK (xt)) - VK (x)
t=0

= (ct + VK (xt+1) - VK (xt))
t=0

= AK (xt, ut)
t=0

which completes the first claim. For the second claim, observe that:

VK (x) = x Q + K RK x + x (A - BK) PK (A - BK)x

And, for u = K x,

AK (x, u) = QK (x, u) - VK (x) = x Q + (K ) RK x + x (A - BK ) PK (A - BK )x - VK (x) = x Q + (K - K + K) R(K - K + K) x + x (A - BK - B(K - K)) PK (A - BK - B(K - K))x - VK (x) = 2x (K - K) (R + B PK B)K - B PK A x + x (K - K) (R + B PK B)(K - K))x ,

which completes the proof.

This lemma is helpful in proving that C(K) is gradient dominated.
Lemma 8. (Gradient domination) Let K be an optimal policy. Suppose K has finite cost and µ > 0. It holds that:

C(K) - C(K)  K Tr(EK (R + B PK B)-1EK )



K min(R)

Tr(EK

EK

)



µ2

K min(R)

Tr(C

(K

)

C (K ))

For a lower bound, it holds that:

C(K) - C(K) 

µ R + B PK B

Tr(EK EK )

Proof. From Equation 10 and by completing the square,

QK (x, K x) - VK (x) = 2Tr(xx (K - K) EK ) + Tr(xx (K - K) (R + B PK B)(K - K))

= Tr(xx K - K + (R + B PK B)-1EK
-Tr(xx EK (R + B PK B)-1EK )  -Tr(xx EK (R + B PK B)-1EK )

(R + B PK B) K - K + (R + B PK B)-1EK ) (11)

with equality when K = K - (R + B PK B)-1EK .

14

Under review as a conference paper at ICLR 2018

Let xt and ut be the sequence generated under K. Using this and Lemma 7,

C(K) - C(K) = -E AK (xt, ut)
t

 E Tr(xt (xt ) EK (R + B PK B)-1EK )

t

= Tr(K EK (R + B PK B)-1EK )

 K Tr(EK (R + B PK B)-1EK )

 K (R + B PK B)-1 Tr(EK EK )



K min(R)

Tr(EK

EK

)

=

K min(R)

Tr(-K1

C

(K

)

C (K )K-1 )



µ2

K min(R)

Tr(C

(K

)

C (K ))

which completes the proof of the upper bound.

For the lower bound, consider K = K -(R+B PK B)-1EK where equality holds in Equation 11. Let xt and ut be the sequence generated under K . Using that C(K)  C(K ),
C(K) - C(K)  C(K) - C(K )

= -E AK (xt, ut)
t
= E Tr(xt(xt) EK (R + B PK B)-1EK )
t
 Tr(K EK (R + B PK B)-1EK ) µ
 R + B PK B Tr(EK EK )

which completes the proof.

Recall that a function f is said to be smooth (or C1-smooth) if it satisfies for some finite , it

satisfies:

|f (x) - f (y) - f (y) (x - y)|   x - y 2 . 2

(12)

for all x, y (equivalently, it is smooth if the gradients of f are continuous).

Lemma 9. ("Almost" smoothness) C(K) satisfies:

C(K ) - C(K) = -2Tr(K (K - K ) EK ) + Tr(K (K - K ) (R + B PK B)(K - K ))

To see why this is related to smoothness (e.g. compare to Equation 12), suppose K is sufficiently

close to K so that:

K  K + O( K - K )

(13)

and the leading order term 2Tr(K (K - K) EK) would then behave as Tr((K - K) C(K)). The challenge in the proof (for gradient descent) is quantifying the lower order terms in this argu-

ment.

Proof. The claim immediately results from Lemma 7, by using Equation 10 and taking an expectation.

The next lemma spectral norm bounds on PK and K are helpful:

Lemma 10. It holds that:

PK



C (K ) ,

µ

K

 C(K) min(Q)

15

Under review as a conference paper at ICLR 2018

Proof. For the first claim, C(K) is lower bounded as: C(K) = Ex0Dx0 PK x0  PK min(Ex0x0 )
Alternatively, C(K) can be lower bounded as: C(K) = Tr(K (Q + K RK))  Tr(K )min(Q)  K min(Q) ,
which proves the second claim.

C.2 GAUSS-NEWTON ANALYSIS

The next lemma bounds the one step progress of Gauss-Newton.

Lemma 11. Suppose that:

If   1, then

K = K - (R + B PK B)-1C(K)K-1 , . C(K ) - C(K)  1 - µ (C(K) - C(K))
K

Proof. Observe K = K - (R + B PK B)-1EK . Using Lemma 9 and the condition on ,
C(K ) - C(K) = -2Tr(K EK (R + B PK B)-1EK ) + 2Tr(K EK (R + B PK B)-1EK )  -Tr(K EK (R + B PK B)-1EK )  -min(K )Tr(EK (R + B PK B)-1EK )  -µTr(EK (R + B PK B)-1EK )  - µ (C(K) - C(K)) , K
where the last step uses Lemma 8.

With this lemma, the proof of the convergence rate of the Gauss Newton algorithm is immediate.

Proof. (of Theorem 5, Gauss-Newton case) The theorem is due to that  = 1 leads to a contraction

of 1 -

µ K

at every step.

C.3 NATURAL POLICY GRADIENT DESCENT ANALYSIS

The next lemma bounds the one step progress of the natural policy gradient.

Lemma 12. Suppose:

K = K - C(K)-K1

and that  

1 R+B PK B

. It holds that:

C(K ) - C(K) 

µ 1 - min(R) K

(C(K) - C(K))

Proof. Since K = K - EK, Lemma 9 implies: C(K ) - C(K) = -2Tr(K EK EK ) + 2Tr(K EK (R + B PK B)EK )
The last term can be bounded as:
Tr(K EK (R + B PK B)EK ) = Tr((R + B PK B)EK K EK )  R + B PK B Tr(EK K EK ) = R + B PK B Tr(K EK EK ) .

16

Under review as a conference paper at ICLR 2018

Continuing and using the condition on ,
C(K ) - C(K)  -2Tr(K EK EK ) + 2 R + B PK B Tr(K EK EK )  -Tr(K EK EK )  -min(K )Tr(EK EK )  -µTr(EK EK )  - µmin(R) (C(K) - C(K)) K
using Lemma 8.

With this lemma, the proof of the natural policy gradient convergence rate can be completed.

Proof. (of Theorem 5, natural policy gradient case) Using Lemma 10,

11

1

R + B PK B



R + B 2 PK



R

+

B 2C(K) µ

The proof is completed by induction: C(K1)  C(K0), since Lemma 12 can be applied. The proof proceeds by arguing that Lemma 12 can be applied at every step. If it were the case that C(Kt)  C(K0), then

1 11



R+

B 2C(K0) 
µ

R

+

B 2C(Kt) 
µ

R + B PKt B

and by Lemma 12:

C(Kt+1) - C(K) 

µ 1-
K

which completes the proof.

min(R)

R

+

B

2

C µ

(K0

)

)

(C(Kt) - C(K))

C.4 GRADIENT DESCENT ANALYSIS
As informally argued by Equation 13, the proof seeks to quantify how K changes with . Then the proof bounds the one step progress of gradient descent.

K PERTURBATION ANALYSIS

This subsections aims to prove the following:

Lemma 13. (K perturbation) Suppose K is such that:

K -K

 min(Q)µ 4C(K) B ( A - BK

+ 1)

It holds that:

K - K

4

C (K ) min(Q)

2 B ( A - BK + 1) K - K µ

The proof proceeds by starting with a few technical lemmas. First, define a linear operator on

symmetric matrices, TK(·), which can be viewed as a matrix on

d+1 2

dimensions.

Define this

operator on a symmetric matrix X as follows:


TK (X) := (A - BK)tX[(A - BK) ]t
t=0

Also define the induced norm of T as follows:

TK

= sup
X

TK (X) X

(14)

17

Under review as a conference paper at ICLR 2018

where the supremum is over all symmetric matrices X (whose spectral norm is non-zero).

Also, define

0 = Ex0x0

.

Lemma 14. (TK norm bound) It holds that

TK

 C(K) µ min(Q)

Proof. For a unit norm vector v  Rd and unit spectral norm matrix X,



v (TK (X))v =

v (A - BK)tX[(A - BK) ]tv

t=0



= Tr([(A - BK) ]tvv (A - BK)tX)

t=0 
= Tr([01/2(A - BK) ]tvv (A - BK)t10/20-1/2X0-1/2)
t=0 
 Tr([01/2(A - BK) ]tvv (A - BK)t10/2) 0-1/2X-0 1/2
t=0
= 0-1/2X0-1/2 v TK (0)v
1  min(Ex0x0 ) TK (0)
1 = µ K

using that TK (0) = K . The proof is completed using the upper bound on K in Lemma 10.

Also, with respect to K, define another linear operator on symmetric matrices:
FK (X) = (A - BK)X(A - BK) .
Let I to denote the identity operator on the same space. Define the induced norm · of these operators as in Equation 14. Note these operators are related to the operator TK as follows: Lemma 15. When (A - BK) has spectral radius smaller than 1,
TK = (I - FK )-1.

Proof. When (A - BK) has spectral radius smaller than 1, TK is well defined and is the solution of TK = I + TK  FK . Therefore TK  (I - FK ) = I and TK = (I - FK )-1.

Since,

K = TK (0) = (I - FK )-1(0) .

The proof of Lemma 13 seeks to bound:

K - K = (TK - TK )(0) = ((I - FK )-1 - (I - FK )-1)(0) .

The following two perturbation bounds are helpful in this.

Lemma 16. It holds that:

FK - FK  2 A - BK B K - K + B 2 K - K 2.

18

Under review as a conference paper at ICLR 2018

Proof. Let  = K - K . For every matrix X,

(FK - FK )(X) = (A - BK)X(B) + (B)X(A - BK) - (B)X(B) .
The operator norm of FK - FK is the maximum possible ratio in spectral norm of (FK - FK )(X) and X. Then the claim follows because AX  A X .

Lemma 17. If then

TK FK - FK  1/2 ,
(TK - TK ) ()  2 TK FK - FK TK () .  2 TK 2 FK - FK  .

Proof. Define A = I - FK , and B = FK - FK . In this case A-1 = TK and (A - B)-1 = TK . Hence, the condition TK FK - FK  1/2 translates to the condition A-1 B  1/2.

Observe: (A-1 - (A - B)-1)() = (I - (I - A-1  B)-1)(A-1()) = (I - (I - A-1  B)-1)(TK ()) . Since (I - A-1  B)-1 = I + A-1  B  (I - A-1  B)-1,

(I - A-1  B)-1  1 + A-1  B (I - A-1  B)-1  1 + 1/2 (I - A-1  B)-1 which implies (I - A-1  B)-1  2. Hence,

I-(I-A-1B)-1 = A-1B(I-A-1B)-1  A-1 B (I-A-1B)-1 = 2 A-1 B .

and so

I - (I - A-1  B)-1  2 A-1 B = 2 TK FK - FK .

Combining these two,

(TK - TK ) ()  (I - (I - A-1  B)-1) TK ()  2 TK FK - FK

TK () .

This proves the main inequality. The last step of the inequality is just applying definition of the norm of TK : TK ()  TK  .

With these Lemmas, the proof is completed as follows:

Proof. (of Lemma 13) First, the proof shows TK FK - FK  1/2, which is the desired condition in Lemma 17. First, observe that under the assumed condition on K - K , implies that

B

K -K

 min(Q)µ 4C(K) ( A - BK

 1 min(Q)µ  1 + 1) 4 C(K) 4

using

that

min (Q)µ C (K )



1

due

to

Lemma

10.

Using

Lemma

16,

FK - FK  2 A - BK B K - K + B 2 K - K

 2 B ( A - BK + 1) K - K

2

(15)

Using this and Lemma 14,

TK

FK - FK

 C(K) 2 B ( A - BK + 1) K - K min(Q)µ

where the last step uses the condition on K - K .

1 2

Thus,

K - K  2 TK FK - FK TK (0)

 2 C(K) (2 B ( A - BK + 1) K - K ) C(K)

min(Q)µ

min(Q)

using Lemmas 10 and 16.

19

Under review as a conference paper at ICLR 2018

GRADIENT DESCENT PROGRESS

Equipped with these lemmas, the one step progress of gradient descent can be bounded.

Lemma 18. Suppose that

K = K - C(K) ,

where

  1 min 16

min(Q)µ 2

C (K )

B

1 C(K) (1 +

A - BK

, min(Q) ) 2C(K) R + B PK B

It holds that:

C(K ) - C(K) 

1 - min(R)

µ2 K

(C(K) - C(K))

. (16)

Proof. By Lemma 9,

C(K ) - C(K)

= -2Tr(K K EK EK ) + 2Tr(K K K EK (R + B PK B)EK )

 -2Tr(K EK EK K ) + 2 K - K Tr(K EK EK )

+2 K R + B PK B Tr(K K EK EK )



-2Tr(K EK EK K ) + 2

K - K min(K )

Tr(K EK EK K )

+2 K R + B PK B Tr(K EK EK K )

=

-2

1-

K - K min(K )

- 2

K

R + B PK B

Tr(C(K) C(K))



-2 µ2min(R) K

1-

K - K µ

- 2

K

R + B PK B

(C(K) - C(K))

where the last step uses Lemma 8.

By Lemma 13,

K - K  4

C (K )

2
B ( A - BK + 1)) C(K)  1/4

µ min(Q)µ

using the assumed condition on .

Using this last claim and Lemma 10,

K



K - K

+

K

µ C(K)

+



4 min(Q)

K 4

C (K ) +
min(Q)

and so K



4C(K) 3min (Q)

.

Hence,

1-

K - K µ

- 2

K

R+B

PK B

 1 - 1/4 -  4C(K) 2 3min(Q)

R+B

PK B

using the condition on .

 1/2

In order to prove a gradient descent convergence rate, the following bounds are helpful: Lemma 19. It holds that

C(K)  C(K) min(Q)

R + B PK B (C(K) - C(K)) µ

and that:



K



1 min(R)





R+B

PK B

(C(K) - C(K)) +
µ

B

PK A 

20

Under review as a conference paper at ICLR 2018

Proof. Using Lemma 10,

C(K) 2  Tr(K EK EK K )  K 2Tr(EK EK ) 

C(K) 2 min(Q) Tr(EK EK )

By Lemma 8,

Tr(EK EK ) 

R+B

PK B (C(K) - C(K)) µ

which proves the first claim.

Again using Lemma 8, K 

=

(R + B PK B)-1 (R + B PK B)K

1 min(R) (R + B PK B)K

1 min(R)

(R + B PK B)K - B PK A + B PK A

EK + B PK A min(R) min(R)



Tr(EK EK ) +

B

PK A

min(R)

min(R)

=

(C(K) - C(K)) R + B 

PK B

+

B

PK A

µmin(R)

min(R)

which proves the second claim.

With these lemmas, the proof of the gradient descent convergence rate follows:

Proof. (of Theorem 5, gradient descent case) First, the following argues that progress is made at

t = 1. Based on Lemma 10 and Lemma 19, by choosing  to be an appropriate polynomial in

C

1 (K0

)

,

1 A

,

1 B

,

1 R

, min(R), min(Q) and µ, the stepsize condition in Equation 16 is satisfied.

Hence, by Lemma 18,

C(K1) - C(K) 

µ2 1 - min(R) K

(C(K0) - C(K))

which implies that the cost decreases at t = 1. Proceeding inductively, now suppose that C(Kt)  C(K0), then the stepsize condition in Equation 16 is still satisfied (due to the use of C(K0) in bounding the quantities in Lemma 19). Thus, Lemma 18 can again be applied for the update at time
t + 1 to obtain:

C(Kt+1) - C(K) 

µ2 1 - min(R) K

(C(Kt) - C(K)) .

Provided

T



K µ2min(R)

log

C(K0) - C(K) 

,

then C(KT ) - C(K)  , and the result follows.

D ANALYSIS: THE MODEL-FREE CASE

This section shows how techniques from zeroth order optimization allow the algorithm to run in

the model-free setting with only black-box access to a simulator. The dependencies on various

parameters are not optimized, and the notation h is used to represent different polynomial factors in

the

relevant

factors

( C(K0)
µmin (Q)

,

A

,

B

,

R

, 1/min(R)). When the polynomial also depend on

dimension d or accuracy 1/ , this is specified as parameters (h(d, 1/ )).

The section starts by showing how the infinite horizon can be approximated with a finite horizon.

21

Under review as a conference paper at ICLR 2018

D.1 APPROXIMATING C(K) AND K WITH FINITE HORIZON

This section shows that as long as there is an upper bound on C(K), it is possible to approximate both C(K) and (K) with any desired accuracy.

Lemma 20. For any K with finite C(K), let (K)

=

E[

-1 i=0

xi

xi

]

and

C( )(K)

=

E[

-1 i=0

xi

Qxi

+ ui

Rui]

=

(Kt), Q + K

RK . If



d · C2(K) µm2 in(Q) ,

then K( ) - K  . Also, if



d

·

C2(K)( Q + R µm2 in(Q)

K 2)

then C(K)  C( )(K)  C(K) - .

Proof. First, the bound on K is proved. Define the operators TK and FK as in Section C.4, observe K = TK (0) and (K) = K - (FK ) (K ).
If X Y , then FK (X) FK (Y ), this follows immediately from the form of FK (X) = (A + BK)X(A + BK) . If X is PSD then W XW is also PSD for any W .

Now, since

-1 

d · C(K)

tr( F
i=0

(0))  tr( F
i=0

(0)) = tr(K ) 

. min(Q)

(Here the last step is by Lemma 10), and all traces are nonnegative, then there must exists j <

such that tr(FKj (0)) 

d·C (K ) min (Q)

.

Also, since K

C (K ) µmin (Q)

0

,

tr(FKj (K ))



C (K ) µmin(Q)

tr(FKj

(0))



d · C2(K) tµm2 in(Q) .

Therefore as long as



dC 2 (K ) µm2 in(Q) ,

it follows that:

K - (K)  K - K(j) = F j (K )  .

Here the first step is again because of all the terms are PSD, so using more terms is always better. The last step follows because F j(K) is also a PSD matrix so the spectral norm is bounded by
trace. In fact, it holds that tr(K - (K)) is smaller than .

Next, observe C( )(K) = K( ), Q + K RK and C(K) = K , Q + K RK , therefore

C(K) - C( )(K)  tr(K - K( ))( Q + R K 2).

Therefore if



d

·

C2(K)( Q + R µm2 in(Q)

K 2) ,

then tr(K - K( ))  /( Q + R K 2) and hence C(K) - C( )(K)  .

22

Under review as a conference paper at ICLR 2018

D.2 PERTURBATION OF C(K) AND C(K)

The next lemma show that the function value and its gradient are approximate preserved if a small perturbation to the policy K is applied.

Lemma 21. (CK perturbation) Suppose K is such that:

K - K  min

min(Q)µ

,K

4C(K) B ( A - BK + 1)

then:

|C(K ) - C(K)|  6 K R E x0 2

C(K) 2 ( K B A - BK + K
µ min(Q)

B + 1) K - K

Proof. As in the proof of Lemma 16, the assumption implies that TK FK - FK  1/2, and, from Equation 15, that
FK - FK  2 B ( A - BK + 1) K - K
First, observe:
C(K ) - C(K)  Tr(Ex0x0 ) TK (Q + (K ) RK ) - TK (Q + K RK) = E x0 2 TK (Q + (K ) RK ) - TK (Q + K RK)

Hence,
TK (Q + (K ) RK ) - TK (Q + K RK)  TK (Q + (K ) RK ) - TK (Q + (K ) RK )
- TK (Q + K RK) - TK (Q + (K ) RK ) = TK (Q + (K ) RK ) - TK (Q + (K ) RK ) - TK  (K RK - (K ) RK )  2 TK 2 FK - FK (K ) RK ) + TK K RK - (K ) RK )  2 TK 2 FK - FK (K ) RK ) - K RK + K RK)
+ TK K RK - (K ) RK )  TK (K ) RK ) - K RK + 2 TK 2 FK - FK K RK
+ TK K RK - (K ) RK ) = 2 TK (K ) RK ) - K RK + 2 TK 2 FK - FK K RK
For the first term, 2 TK (K ) RK ) - K RK  2 TK 2 K R K - K + R K - K 2  2 TK (3 K R K - K )
using the assumption that K - K  K . For the second term,
2 TK 2 FK - FK K RK  2 TK 2 2 B ( A - BK + 1) K - K K 2 R .
Combining the two terms completes the proof.

The next lemma shows the gradient is also stable after perturbation.

Lemma 22. (CK perturbation) Suppose K is such that:

K - K  min

min(Q)µ

,K

4C(K) B ( A - BK + 1)

then

there

is

a

polynomial

hgrad

in

,C(K0)
µmin (Q)

A

,

B

,

R

,

1 min (R)

such

that

|C(K ) - C(K)|  hgrad K - K .

23

Under review as a conference paper at ICLR 2018

Proof. Recall C(K) = 2EK K where EK = (R + B PK B)K - B PK A. Therefore C(K ) - C(K) = 2EK K - 2EK K = 2(EK - EK )K + 2EK (K - K ).

Let's first look at the second term. By Lemma 8,

Tr(EK EK ) 

R+B

PK B

(C(K) - C(K)) ,

µ

then by Lemma 13

K - K

4

C (K ) min(Q)

2 B ( A - BK + 1) K - K µ

Therefore the second term is bounded by

8

C (K ) min(Q)

2 ( R+B

PK B (C(K) - C(K))) B µ2

( A - BK

+ 1)

K -K

.

Now the first term is bounded. Since K - K is small enough, K



K

+

C (K ) min (Q)

.

For EK - EK , a bound on PK - PK is provided. By the previous lemma,

PK -PK = 6

C (K )

2
K 2 R B ( A - BK + 1) +

C (K )

KR

µ min(Q)

µ min(Q)

K-K .

Therefore

EK - EK = R(K - K) + B (PK - PK )A + B (PK - PK )BK + B PK B(K - K).
Since K  2 K , and K can be bounded by C(K) (Lemma 19), all the terms can be bounded by polynomials of related parameters multiplied by K - K .

D.3 SMOOTHING AND THE GRADIENT DESCENT ANALYSIS
This section analyzes the smoothing procedure and completes the proof of gradient descent. Although Gaussian smoothing is more standard, the objective C(K) is not finite for every K, therefore technically EuN (0,2I)[C(K + u)] is not well defined. This is avoidable by smoothing in a ball.
Let Sr represent the uniform distribution over the points with norm r (boundary of a sphere), and Br represent the uniform distribution over all points with norm at most r (the entire sphere). When applying these sets to matrix a U , the Frobenius norm ball is used. The algorithm performs gradient descent on the following function

Cr(K) = EUBr [C(K + U )].

The next lemma uses the standard technique (e.g. in (Flaxman et al., 2005)) to show that the gradient

of Cr(K) can be estimated just with an oracle for function value.

Lemma 23.

Cr(K) =

d r2

EUSr [C(K

+

U )U ].

This is the same as Lemma 2.1 in Flaxman et al. (2005), for completeness the proof is provided below.

Proof. By Stokes formula,

U

 C(K + U )dx = C(K + u)

dx.

Br Sr U F

By definition,

Cr(K) =

Br C(K + U )dx , vold ( Br )

24

Under review as a conference paper at ICLR 2018

Also,

EU Sr

[C (K

+

U )U

]

=

rEUSr [C(K

+

U)

U r

]

=

r

·

Sr C(K + U )

U U

F

dx

.

vold-1 ( Sr )

The Lemma follows from combining these equations, and use the fact that

vold ( Br )

=

vold-1 ( Sr )

·

r .
d

From the lemma above and standard concentration inequalities, it is immediate that it suffices to use a polynomial number of samples to approximate the gradient.

Lemma 24. Given an , there are fixed polynomials hr(1/ ), hsample(d, 1/ ) such that when r  1/hr(1/ ), with m  hsample(d, 1/ ) samples of U1, ..., Un  Sr, with high probability (at least 1 - (d/ )-d) the average

^ = 1 m

m

d r2 C(K + Ui)Ui

i=1

is close to C(K).

Further, if for x  D, x  L almost surely, there are polynomials h ,grad(d, 1/ ), hr,trunc(1/ ), hsample,trunc(d, 1/ , , L2/µ) such that when m  hsample,trunc(d, 1/ , L2/µ),
 h ,grad(d, 1/ ), let xij, uij(0  j  ) be a single path sampled using K + Ui, then the average

~ = 1 m

m

d r2 [

-1
(xij )

Qxji + (uij )

Ruji ]Ui

i=1 j=0

is also close to C(K) with high probability.

Proof. For the first part, the difference is broken into two terms:

^ - C(K) = (Cr(K) - C(K)) + (^ - Cr(K)).

For the first term, choose hr(1/ ) = min{1/r0, 2hgrad/ } (r0 is chosen later). By Lemma 22 when r is smaller than 1/hr(1/ ) = /2hgrad, every point u on the sphere have C(K + U ) - C(K)  /4. Since Cr(K) is the expectation of C(K + U ), by triangle inequality Cr(K) - C(K)  /2.

The proof also makes sure that r  r0 such that for any U  Sr, it holds that C(K + U )  2C(K). By Lemma 21, 1/r0 is a polynomial in the relevant factors.

For the second term, by Lemma 23, E[^ ] = Cr(K), and each individual sample has norm

bounded by 2dC(K)/r, so by Vector Bernstein's Inequality, know with m  hsample(d, 1/ ) =



d

dC(K) 2 r

log d/

samples, with high probability (at least 1 - (d/ )-d) ^ - E[^ ]  /2.

Adding these two terms and apply triangle inequality gives the result.

For the second part, the proof breaks it into more terms.

Let 

be equal to

1 m

Ui)Ui (where C( ) is defined as in Lemma 20), then

~ - C(K) = (~ -  ) + ( - ^ ) + (^ - C(K)).

m i=1

d r2

C

(

)(K

+

The third term is just what was bounded earlier, using hr,trunc(1/ ) = hr(2/ ) and making sure hsample,trunc(d, 1/ )  hsample(d, 2/ ), this guarantees that it is smaller than /2.

For the second term, choose

 16d2·C2(K)( Q + R
rµm2 in(Q)

K 2) =: h ,grad(d, 1/ ). By Lemma 20, for

any K with C(K )  2C(K), it holds that

C( )(K ) - C(K )



r 4d

.

Therefore by triangle

inequality

1 m

m

d r2

C(

)(K

+

Ui)Ui

-

1 m

m

d r2 C(K + Ui)Ui



/4.

i=1 i=1

25

Under review as a conference paper at ICLR 2018

Finally for the first term it is easy to see that E[~ ] =  where the expectation is taken over the

randomness of the initial states xi0. Since x0i  L, (x0i )(x0i )

L2 µ

E[x0x0

],

as

a

result

the

sum

-1
[ (xij )

Qxji + (uij )

Ruij ]



L2 C (K
µ

+

Ui).

j=0

Therefore, ~ -  is again a sum of independent vectors with bounded norm, so by Vector Bernstein's inequality, when hsample,trunc(d, 1/ , L2/µ) is a large enough polynomial, ~ -   /4
with high probability. Adding all the terms finishes the proof.

Theorem 25. There are fixed polynomials hGD,r(1/ ), hGD,sample(d, 1/ , L2/µ), hGD, (d, 1/ ) such that if every step the gradient is computed as Lemma 24 (truncated at step ), pick step size 
and T the same as the gradient descent case of Theorem 5, it holds that C(KT ) - C(K )  with high probability (at least 1 - exp(-d)).

Proof. By Lemma 18, when   1/hGD, for some fixed polynomial hGD,(given in Lemma 18),

then

C(K ) - C(K) 

µ2 1 - min(R) K

(C(K) - C(K))

Let ~ be the approximate gradient computed, and let K = K - ~ be the iterate that uses the approximate gradient. The proof shows given enough samples, the gradient can be estimated with enough accuracy that makes sure

1 µ2 |C(K ) - C(K )|  2 min(R) K · . This means as long as C(K) - C(K)  , it holds that

C(K ) - C(K) 

1 1 - 2 min(R)

µ2 K

(C(K) - C(K)).

Then the same proof of Theorem 5 gives the convergence guarantee.

Now C(K ) - C(K ) is bounded. By Lemma 21, if K - K



1 2

min

(R)

µ2 K

·

· 1/hfunc

(hfunc is the polynomial in Lemma 21), then C(K ) - C(K ) is small enough. To get that, observe

K - K = ( - ~ ), therefore it suffices to make sure

 - ~



1 2 min(R)

µ2 K

·

· 1/hfunc

By Lemma 22, it suffices to pick hGD,r(1/ ) = hr,trunc(2hfunc K /(µ2min(R) )), hGD,sample(d, 1/ , L2/µ) = hsample,trunc(d, 2hfunc K /(µ2min(R) ), L2/µ), and hGD, (d, 1/ ) = h ,grad(d, 2hfunc K /(µ2min(R) )). This gives the desired upper-bound on
 - ~ with high probability (at least 1 - ( /d)-d).
Since the number of steps is a polynomial, by union bound with high probability (at least 1 - T ( /d)-d  1 - exp(-d)) the gradient is accurate enough for all the steps, so

C(K ) - C(K) 

1 µ2 1 - 2 min(R) K

(C(K) - C(K)).

The rest of the proof is the same as Theorem 5. Note that in the smoothing, because the function value is monotonically decreasing and the choice of radius, all the function value encountered is bounded by 2C(K0), so the polynomials are indeed bounded throughout the algorithm.

26

Under review as a conference paper at ICLR 2018

D.4 THE NATURAL GRADIENT ANALYSIS
Before the Theorem for natural gradient is proven, the following lemma shows the variance can be estimated accurately.
Lemma 26. If for x  D, x  L almost surely, there exists polynomials hr,var(1/ ), hvarsample,trunc(d, 1/ , L2/µ) and h ,var(d, 1/ ) such that if ^ K is estimated using at least m  hvarsample,trunc(d, 1/ , L2/µ) initial points x01, ..., x0m, m random perturbations Ui  Sr where r  1/hr,var(1/ ), all of these initial points are simulated using K^i = K + Ui to  h ,var(d, 1/ ) iterations, then with high probability (at least 1 - (d/ )-d) the following estimate

satisfies

~ - K

~ = 1 m m

-1
xji (xji ) .

i=1 j=0

 . Further, when  µ/2, it holds that min(^ K )  µ/2.

Proof.

This is broken into three terms: let K( ) be defined as in Lemma 20, let ^ =

1 m

and

^ (

)

=

1 m

m i=1

(K)+Ui

,

then

it

holds

that

~ - K = (~ - ^ ( )) + (^ ( ) - ^ ) + (^ - K ).

m i=1

K+Ui

First, r is chosen small enough so that C(K + Ui)  2C(K). This only requires an inverse polynomial r by Lemma 21.

For the first term, note that E[~ ] = ^ ( ) where the expectation is taken over the initial points x0i .

Since xi0  L, (xi0)(x0i )

L2 µ

E[x0x0

],

and

as

a

result

the

sum

-1
xij (xij ) Q
j=0

L2 µ K+Ui .

Therefore, standard concentration bounds show that when hvarsample,trunc is a large enough polynomial, ~ - ^ ( )  /2 holds with high probability.

For the second term, Lemma 20 is applied. Because C(K + Ui)  2C(K), choosing 

h ,var(d, 1/ ) =

,8d·C 2 (K )
µm2 in(Q)

the

error

introduced

by

truncation

^ ( ) - ^

is then bounded by

/4.

For the third term, Lemma 13 is applied. When r 

·

min (Q) C (K )

2

16

B

(

µ A-BK

+1) ,

K+Ui -

K  /4. Since ^ is the average of K+Ui , by the triangle inequality, ^ - K  /4.

Adding these three terms gives the result.

Finally, the bound on min(~ K ) follows simply from Weyl's Theorem.

Theorem 27. Suppose C(K0) is finite and and µ > 0. The natural gradient follows the update

rule:

Kt+1 = Kt - C(Kt)K-1t

Suppose the stepsize is set to be:

1

=

R+

B 2C(K0) µ

If the gradient and variance are estimated as in Lemma 24, Lemma 26 with r = 1/hNGD,r(1/ ), with m  hNGD,sample(d, 1/ , L2/µ) samples, both are truncated to hNGD, (d, 1/ ) iterations, then with high probability (at least 1 - exp(-d)) in T iterations where

T > K µ

R + B 2C(K0) log 2(C(K0) - C(K))

min(R) µmin(R)



then the natural gradient satisfies the following performance bound:

C(KT ) - C(K)  

27

Under review as a conference paper at ICLR 2018

Proof. By Lemma 12,

C(K ) - C(K) 

µ 1 - min(R) K

(C(K) - C(K))

Let ~ be the estimated gradient, ~ K be the estimated K , and let K = K - ~ ~K -1. The proof shows that when both the gradient and the covariance matrix are estimated accurately enough, then
µ |C(K ) - C(K )|  2 min(R) K .
This implies when C(K) - C(K )  ,

C(K ) - C(K) 

1µ 1 - 2 min(R) K

(C(K) - C(K))

which is sufficient for the proof.

By Lemma 21, if K - K



2hfunc min(R)

µ K

the desired bound on |C(K ) - C(K )|

holds. To achieve this, it suffices to have

~ ~ K-1 - C(K)K-1

µ  2hfunc min(R) K

.

This is broken into two terms ~ ~ -K1 - C(K)K-1  ~ -  ~ K-1 + C(K) ~ -K1 - -K1 .

For the first term, by Lemma 26 we know when the number of samples is

large enough ~ -K1  2/µ. Therefore it suffices to make sure ~ -  

8hfunc min(R)

µ2 K

,

this

can

be

done

by

Lemma

24

by

setting

hNGD,grad,r(1/ )

=

h (r,trunc

8hf unc K µ2 min (R)

),

hNGD,gradsample(d, 1/ , L/µ2)

=

hsample,trunc(d,

8hf unc K µ2 min (R)

, L/µ2)

and

hN GD,

,grad(d, 1/

)

=

h

,grad(d,

8hf unc K µ2 min (R)

).

For the second term, it suffices to make sure ~ -K1 - K-1



4hfunc min(R) K

µ C (K )

..

By standard matrix perturbation, and min(K )  µ, ~ -K1 - -K1  2 ~ K - K /µ2

(when ~ K - K  µ/2). Therefore by Lemma 26 it suffices to choose

hNGD,var,r(1/ )

=

h ( 8hfunc K C(K)

var,r

µ3 min (R)

),

hNGD,varsample(d, 1/ , L/µ2)

=

hvarsample,trunc(d,

8hfunc K C(K) µ3 min (R)

, L/µ2)

and

hNGD, ,var(d, 1/ )

=

h

,var (d,

8hfunc K C(K) µ3 min (R)

).

This is indeed a polynomial because

C (K )

is bounded

by Lemma 19.

Finally, choose hNGD,r = max{hNGD,grad,r, hNGD,var,r}, hNGD,sample = max{hNGD,gradsample, hNGD,varsample}, and hNGD, = max{hNGD, ,grad, hNGD, ,var}.
This ensures all the bounds mentioned above hold and that

C(K ) - C(K) 

1µ 1 - 2 min(R) K

(C(K) - C(K))

The rest of the proof is the same as Theorem 5. Note again that in the smoothing, because the function value is monotonically decreasing and the choice of radius, all the function values encountered are bounded by 2C(K0), so the polynomials are indeed bounded throughout the algorithm.

28

