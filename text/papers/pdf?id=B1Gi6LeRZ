Under review as a conference paper at ICLR 2018
LEARNING FROM BETWEEN-CLASS EXAMPLES FOR DEEP SOUND RECOGNITION
Anonymous authors Paper under double-blind review
ABSTRACT
Deep learning methods have achieved high performance in sound recognition tasks. Deciding how to feed the training data is important for further performance improvement. We propose a novel learning method for deep sound recognition: learning from between-class examples (BC learning). Our strategy is to learn a discriminative feature space by recognizing the between-class sounds as betweenclass sounds. We generate between-class sounds by mixing two sounds belonging to different classes with a random ratio. We then input the mixed sound to the model and train the model to output the mixing ratio. The advantages of BC learning are not limited only to the increase in variation of the training data; BC learning leads to an enlargement of Fisher's criterion in the feature space and a regularization of the positional relationship among the feature distributions of the classes. The experimental results show that BC learning improves the performance on various sound recognition networks, datasets, and data augmentation schemes, in which BC learning proves to be always beneficial. Furthermore, we construct a new deep sound recognition network (DSRNet) and train it with BC learning. As a result, the performance of DSRNet surpasses the human level.
1 INTRODUCTION
Sound recognition has been conventionally conducted by applying classifiers, such as SVM or GMM, to local features, such as MFCC or log-mel features (Logan et al., 2000; Vacher et al., 2007; Lopatka et al., 2010). Convolutional neural networks (CNNs) (LeCun et al., 1998), which have achieved success in image recognition tasks (Krizhevsky et al., 2012; Simonyan & Zisserman, 2015; He et al., 2016), have recently proven to be effective in tasks related to series data, such as speech recognition (Abdel-Hamid et al., 2014; Sainath et al., 2015a;b) and natural language processing (Kim, 2014; Zhang et al., 2015). Some researchers applied CNNs to sound recognition tasks and achieved high performance: applying a CNN to local features (Piczak, 2015a) and learning directly from raw waveforms (Aytar et al., 2016; Dai et al., 2017; Tokozume & Harada, 2017).
The amount and quality of training data and how to feed it are important for machine learning, particularly for deep learning. Various approaches have been proposed to improve the sound recognition performance. The first approach is to efficiently use limited training data with data augmentation. Researchers proposed increasing the training data variation by altering the shape or property of sounds or adding a background noise (Tokozume & Harada, 2017; Salamon & Bello, 2017). Researchers also proposed using additional training data created by mixing multiple training examples (Parascandolo et al., 2016; Takahashi et al., 2016). The second approach is to use external data or knowledge. Aytar et al. (Aytar et al., 2016) proposed learning rich sound representations using a large amount of unlabeled video datasets and pre-trained image recognition networks. The sound dataset expansion was also conducted (Salamon et al., 2014; Piczak, 2015b; Gemmeke et al., 2017).
In this paper, as a novel third approach we propose a learning method for deep sound recognition: learning from between-class examples (BC learning). Our strategy is to learn a discriminative feature space by recognizing the between-class sounds as between-class sounds. We generate betweenclass sounds by mixing two sounds belonging to different classes with a random ratio. We then input the mixed sound to the model and train the network to output the mixing ratio. Our method focuses on the characteristic of the sound, from which we can generate a new sound simply by adding the waveform data of two sounds. The advantages of BC learning are not limited only to the increase
1

Under review as a conference paper at ICLR 2018
in variation of the training data; BC learning leads to an enlargement of Fisher's criterion (Fisher, 1936) (i.e., the ratio of the between-class distance to the within-class variance) in the feature space, and a regularization of the positional relationship among the feature distributions of the classes.
The experimental results show that BC learning improves the performance on various sound recognition networks, datasets, and data augmentation schemes, in which BC learning proves to be always beneficial. Furthermore, we constructed a new deep sound recognition network (DSRNet) and trained it with BC learning. As a result, we achieved a 15.10% error rate on a benchmark dataset ESC-50 (Piczak, 2015b), which surpasses the human level.
We argue that our approach is different from the so-called data augmentation methods we introduced above. In general, the problem to be solved is the same in both training and testing phase. Data augmentation methods aim to improve the generalization ability by generating additional training data which is likely to appear in testing phase. Thus, the most important thing is the training data variation. On the other hand, our BC learning aims to learn a classification problem by solving the problem of predicting the mixing ratio between to different classes. Our method only uses mixed data and labels for training, without using the original pure data and labels, while the model solves a single-label classification problem in the testing phase. We believe that the key point of BC learning is not the increase in data variation but the learning method itself. To the best of our knowledge, this is the first time a learning method that employs a mixing ratio between different classes has been proposed. Hence, our BC learning is a novel learning method.
2 RELATED WORK
2.1 SOUND RECOGNITION NETWORKS
We introduce recent deep learning methods for sound recognition. Piczak (2015a) proposed the extraction of log-mel features from raw waveforms and the application of CNNs to them. The log-mel feature is calculated for each frame of sound and represents the magnitude of each frequency area, considering human auditory perception (Davis & Mermelstein, 1980). Piczak created a 2-D featuremap by arranging the log-mel features of each frame along the time axis and calculated the delta log-mel feature, which was the first temporal derivative of the static log-mel feature. Piczak then classified these static and delta feature-maps with 2-D CNN, treating them as a two-channel input in a manner quite similar to the RGB inputs of the image. The log-mel feature-map exhibits locality in both time and frequency domains (Abdel-Hamid et al., 2014). Therefore, we can accurately classify this feature-map with CNN. We refer to this method as Logmel-CNN.
Some researchers also proposed methods to learn the sounds directly from 1-D raw waveforms, including feature extraction. Aytar et al. (2016) proposed a sound recognition network using 1D convolutional and pooling layers named SoundNet and learned the sound feature using a large amount of unlabeled videos (we describe the details of it in the next section). Dai et al. (2017) also proposed a network using 1-D convolutional and pooling layers, but they stacked more layers. They reported that the network with 18 layers performed the best. Tokozume & Harada (2017) proposed a network using both 1-D and 2-D convolutional and pooling layers named EnvNet. First, EnvNet extracts a frequency feature of each short duration of section with 1-D convolutional and pooling layers and obtain a 2-D feature-map. Next, it classifies this feature-map with 2-D convolutional and pooling layers in a similar manner to Logmel-CNN. Learning from the raw waveform is still a challenging problem because it is difficult to learn raw waveform features from limited training data. However, the performance of these systems is close to that of Logmel-CNN.
2.2 APPROACHES TO ACHIEVE HIGH PERFORMANCE
We describe the approaches to achieve high sound recognition performance from two views: approaches involving efficient use of limited training data and those involving external data/knowledge. First, we describe data augmentation as an approach of efficiently using limited training data. One of the most standard and important data augmentation methods is cropping (Piczak, 2015a; Aytar et al., 2016; Tokozume & Harada, 2017). The training data variation increases, and we are able to more efficiently train the network when the short section (approximately 1­2 s) of the training sound cropped from the original data to the network, and not the whole section, is inputted. A similar method is generally used in the test phase. Multiple sections of test data are input with a stride,
2

Under review as a conference paper at ICLR 2018

Random Select & Augment

x1

Dog Bird
Cat
Training Dataset

x2

mixr (x1 ,

x2)

=

ppx1 + (1 p2 + (1

p) x2 p)2

where

p

=

1

+

1 10 G1 G2
20

· 1rr

mixr(x1, x2)
r  U (0, 1)

Input

KL
Output Model

Dog 0.7 Cat 0.3 Bird 0
Label
r t1 + (1 r) t2

Figure 1: BC learning: learning from between-class examples. We create each training example by mixing two sounds belonging to different classes with a random ratio. We input the mixed sound to the model and train the model to output the mixing ratio using the KL loss.

and the average of the output predictions is used to classify the test sound. Salamon & Bello (2017) proposed the usage of additional training data created by time stretching (slow down or speed up the sounds), pitch shifting (raise or lower the pitch of sounds), dynamic range compression (compress the dynamic range of sounds), and adding background noise chosen from an external dataset. Researchers also proposed using additional training data created by mixing multiple training examples. Parascandolo et al. (2016) applied this method to polyphonic sound event detection. Takahashi et al. (2016) applied this method to single-label sound event classification, but only the sounds belonging to the same class were mixed. Both of them treated the mixed data as additional training data, and only focused on the increase in data variation. To the best of our knowledge, there has been no method that employs a mixing ratio between different classes for training.
Next, we describe the approaches of utilizing external data/knowledge. Aytar et al. (2016) proposed to learn rich sound representations using pairs of image and sound included in a large amount of unlabeled video dataset. They transferred the knowledge of pre-trained large-scale image recognition networks into sound recognition network by minimizing the KL-divergence between the output predictions of the image recognition networks and that of the sound network. They used the output of the hidden layer of the sound recognition network as the feature when applying to the target sound classification problem. They then classified it with linear SVM. They could train a deep sound recognition network (SoundNet8) and achieve a 74.2% accuracy on a benchmark dataset, ESC-50 (Piczak, 2015b), with this method.

3 BC LEARNING: LEARNING FROM BETWEEN-CLASS EXAMPLES
3.1 OVERVIEW
In this section, we propose a novel learning method for deep sound recognition BC learning. Fig. 1 shows the pipeline of the BC learning. In standard learning, we select a single training example from the dataset and input it to the model. We then train the model to output 0 or 1. By contrast, in BC learning, we select two training examples from different classes and mix these two examples using a random ratio. We then input the mixed data to the model and train the model to output the mixing ratio. BC learning uses only mixed data and labels, and thus never uses pure data and labels. First, we provide the details of BC learning in Section 3.2. We mainly explain the method of mixing two sounds, which should be carefully designed to achieve a good performance. Then, in Section 3.3, we explain why BC learning leads to a discriminative feature space.
3.2 METHOD DETAILS
3.2.1 MIXING METHOD
BC learning optimizes a model using mini-batch stochastic gradient descent the same way the standard learning does. Each data and label of a mini-batch is generated by mixing two training examples belonging to different classes. Here, we describe how to mix two training examples.

3

Under review as a conference paper at ICLR 2018

Let x1 and x2 be two sounds belonging to different classes randomly selected from the training dataset, and t1 and t2 be their one-hot labels. Note that x1 and x2 may have already been preprocessed or applied data augmentation, and they have the same length as that of the input of
the network. We generate a random ratio r from U (0, 1) , and mix two sets of data and labels with this ratio. We mix two labels simply by r t1 + (1 - r) t2 , because we aim to train the model to output the mixing ratio. We then explain how to mix x1 and x2 . The simplest method is r x1 + (1 - r) x2 . However, the following mixing formula is slightly better, considering that sound energy is proportional to the square of the amplitude:

mixr (x1 ,

x2)

=

rx1 + (1 - r) x2 . r2 + (1 - r)2

(1)

However, auditory perception of a sound mixed with Eqn. (1) would not be x1 : x2 = r : (1 - r)

if the difference of the sound pressure level of x1 and x2 is large. For example, if the amplitude

of x1 is 10 times as large as that of x2 and we mix them with 0.2 : 0.8, the sound of x1 would still be dominant in the mixed sound. In this case, training the model with a label of {0.2, 0.8}

is inappropriate. We then consider using a new coefficient p(r, G1, G2) instead of r , and mix

two sounds by

px1 + (1 - p) x2 , where
p2 + (1 - p)2

G1

and

G2

is the sound pressure level of

x1

and

x2

[dB],

respectively. We define p so that the auditory perception of the mixed sound becomes r : (1 - r).

We hypothesize that the ratio of auditory perception for the network is the same as the ratio of

amplitude and then solve

p

·

10

G1 20

:

(1

-

p)

·

10 G2 20

= r : (1 - r) . Finally, we obtain the proposed

mixing method:

mixr (x1 ,

x2)

=

px1 + (1 - p) x2 p2 + (1 - p)2

1

where

p=

1+

10 G1-G2 20

.

·

1-r r

We show this mixing method performs better than Eqn. (1) in the experiments.

(2)

We calculate the sound pressure level G1 and G2 using A-weighting, considering that human auditory perception is not sensitive to low and high frequency areas. We can also use simpler sound pres-
sure metrics such as root mean square (RMS) energy instead of an A-weighting sound pressure level. However, the performance worsens, as we show in the experiments. We create short windows ( 0.1 s) on the sound and calculate a time series of A-weighted sound pressure levels {g1, g2, . . . , gt} . Then, we define G as the maximum of those time series ( G = max{g1, g2, . . . , gt} ).

3.2.2 OPTIMIZATION

We define the f and  as the model function and the model parameters, respectively. We input the generated mini-batch data {xi}ni=1 and obtain the output {f(xi)}in=1. Some distance metrics can be found between {f(xi)}ni=1 and mini-batch label {ti}ni=1. We expect that our ratio labels represent the expected class probability distribution. Therefore, we use the KL-divergence between the labels
and the model outputs as the loss function. We optimize KL-divergence with back-propagation and
stochastic gradient descent because it is differentiable:

L

=

n
i=1

DKL (ti f (xi ))

=

n
i=1

m
j=1

tij

log tij {f (xi )}j

,

(3)







-



L ,



(4)

where m is the number of classes, and  is the learning rate.

3.3 HOW BC LEARNING WORKS
3.3.1 ENLARGEMENT OF FISHER'S CRITERION
BC leaning leads to an enlargement of the Fisher's criterion (i.e., the ratio of the between-class distance to the within-class variance). We explain the reason in Fig. 2. In deep neural networks, linearly-separable features are learned in a hidden layer close to the output layer (An et al., 2015).

4

Under review as a conference paper at ICLR 2018

mixr(x1, x2)

x1

class A

x2
class B

f Standard learning f(x1) BC learning (ours) f(x1)

f (mixr(x1, x2))

f (mixr(x1, x2))

A

A f(x2) mixr(A, B)

f (x2)

mixr(A, B)

Input space

BB
Feature Space

Figure 2: BC learning enlarges the Fisher's criterion in the feature space, by training the model to output the mixing ratio between two different classes. We hypothesize that a mixed sound mixr(x1, x2) is projected into the point near the internally dividing point of f (x1) and f (x2) , considering the characteristic of sounds. Middle: When the Fisher's criterion is small, some mixed examples are projected into one of the classes, and BC learning gives a large penalty. Right: When the Fisher's criterion is large, most of the mixed examples are projected into between-class points, and BC learning gives a small penalty. Therefore, BC learning leads to such a feature space.

Besides, we can generate a new sound simply by adding the 20

waveform data of two sounds, and humans can recognize both

of two sounds and perceive which of two sounds is louder or 10 softer from the mixed sound. Therefore, it is expected that

r=1

an internally dividing point of the input space almost corresponds to that of the semantic feature space, at least for 0

sounds. Then, the feature distribution of the mixed sounds

r = 0.8

r=0

of class A and class B with a certain ratio would be located -10

near the internally dividing point of the original feature distri-

bution of class A and B, and the variance of the feature dis- -20

dog bark rain

tribution of the mixed sounds is proportional to the original

others mixed

feature distribution of class A and B. To investigate whether -30

this hypothesis is correct or not, we visualized the feature dis- -30 -20 -10 0 10 20

tributions of the standard-learned model using PCA. The results are shown in Fig. 3. The magenta circles represent the feature distribution of the mixed sounds of dogbark and rain with a ratio of 0.8 : 0.2, and the black dotted line represents the trajectory of the feature when we input a mixture of two

Figure 3: Visualization of the feature space using PCA. The features of the mixed sounds are distributed between two classes.

particular sounds to the model changing the mixing ratio from 0 to 1. This figure shows that the

mixture of two sounds is projected into the point near the internally dividing point of two features,

and the features of the mixed sounds are distributed between two classes, as we expected.

If the Fisher's criterion is small, the feature distribution of the mixed sounds becomes large, and would have a large overlap with one or both of the feature distribution of class A and B (Fig. 2(middle)). In this case, some mixed sounds are projected into one of the classes as shown in this figure, and the model cannot output the mixing ratio. BC learning gives a penalty to this situation because BC learning trains a model to output the mixing ratio. If the Fisher's criterion is large, on the other hand, the overlap becomes small (Fig. 2(right)). The model becomes able to output the mixing ratio, and BC learning gives a small penalty. Therefore, BC learning enlarges the Fisher's criterion between any two classes in the feature space.

3.3.2 REGULARIZATION OF POSITIONAL RELATIONSHIP AMONG FEATURE DISTRIBUTIONS
We expect that BC learning also has the effect of regularizing the positional relationship among the class feature distributions. In standard learning, there is no constraint on the positional relationship among the classes, as long as the features of each two classes are linearly separable. We found that a standard-learned model sometimes misclassifies a mixed sound of class A and class B as a class other than A or B. Fig. 4(lower left) shows an example of transition of output probability of standard-learned model when we input a mixture of two particular training sounds (dog bark and rain) to the model changing the mixing ratio from 0 to 1. The output probability of dog bark

5

Under review as a conference paper at ICLR 2018

monotonically increases and that of rain monotonically decreases as we expected, but the model classifies the mixed sound as baby cry when the mix-

Standard learning C

r=1

BC learning (ours) C

ing ratio is within the range of 0.45 ­ 0.8. This is an undesirable state because there is little possi-

A r=1 A

bility that a mixed sound of two classes becomes

a sound of other classes. In this case, we assume that the features of each class are distributed as in

r=0 B

r=0 B

Fig. 4(upper left). The decision boundary of class 1

1

prediction prediction

C appears between class A and class B, and the tra- 0.8 0.6
jectory of the features of the mixed sounds crosses 0.4

0.8 0.6 0.4

the decision boundary of class C. BC learning can avoid the situation in which the

A: dog bark 0.2 B: rain

0.2 A: dog bark

C: baby cry

B: rain

0 0 0.2 0.4 0.6 0.8

1

0 0 0.2 0.4 0.6 0.8

1

mixing ratio

mixing ratio

decision boundary of other class appears between two classes, because BC learning trains a model to output the mixing ratio instead of misclassifying the mixed sound as different classes. We show the transition of the output probability in Fig. 4(lower right), when using the same two examples as that used in Fig. 4(lower left). We assume that the features of each class are distributed as in Fig. 4(upper

Figure 4: BC learning regularizes the positional relationship of the classes in the feature space, by training the model not to misclassify the mixed sound as different classes. BC learning avoids the situation in which the decision boundary of other class appears between any two classes.

right). The feature distributions of the three classes make an acute-angled triangle, and the decision

boundary of class C does not appear between class A and class B. In this way, BC learning enlarges

the Fisher's criterion, and at the same time, regularizes the positional relationship among the classes

in the feature space. Hence, BC learning improves the generalization ability.

4 EXPERIMENTS
4.1 COMPARISON BETWEEN STANDARD LEARNING AND BC LEARNING
In this section, we train various types of sound recognition networks with both standard and BC learning, and demonstrate the effectiveness of BC learning.
Datasets We used ESC-50, ESC-10 (Piczak, 2015b), and UrbanSound8K (Salamon et al., 2014) to train and evaluate the models. ESC-50, ESC-10, and UrbanSound8K contain a total of 2,000, 400, and 8,732 examples consisting of 50, 10, and 10 classes, respectively. We removed completely silent sections in which the value was equal to 0 at the beginning or end of examples in the ESC-50 and ESC-10 datasets. We converted all sound files to monaural 16-bit WAV files. We evaluated the performance of the methods using a K-fold cross-validation (K = 5 for ESC-50 and ESC-10, and K = 10 for UrbanSound8K), using the original fold settings. We performed cross-validation 5 times for ESC-50 and ESC-10, and showed the standard error.
Preprocessing and data augmentation We used a simple preprocessing and data augmentation scheme. Let T be the input length of a network [s]. In the training phase, we padded T /2 s of zeros on each side of a training sound and randomly cropped a T -s section from the padded sound. We mixed two cropped sounds with a random ratio when using BC learning. In the testing phase, we also padded T /2 s of zeros on each side of a test sound and cropped 10 T -s sections from the padded sound at regular intervals. We then input these 10 crops to the network and averaged all softmax outputs. Each input data was regularized into a range of from -1 to +1 by dividing it by 32,768, that is, the full range of 16-bit recordings.
Learning settings All models were trained with Nesterov's accelerated gradient using a momentum of 0.9, weight decay of 0.0005, and mini-batch size of 64. The only difference in the learning settings between standard and BC learning is the number of training epochs. BC learning tends to require more training epochs than does standard learning, while standard learning tends to overfit with many training epochs. To validate the comparison, we first identified an appropriate standard learning setting for each network and dataset (details are provided in the appendix A), and we dou-

6

Under review as a conference paper at ICLR 2018

Table 1: Comparison between standard learning and our BC learning. We performed K-fold cross validation using the original fold settings. We performed cross-validation 5 times for the ESC-50 and ESC-10 datasets, and show the standard error. BC learning improves the performance of all models on all datasets, even when we use a strong data augmentation scheme. Our DSRNet trained with BC learning performs the best and surpasses the human performance on ESC-50.

Model EnvNet (Tokozume & Harada, 2017) SoundNet5 (Aytar et al., 2016) M18 (Dai et al., 2017) Logmel-CNN (Piczak, 2015a) + BN DSRNet (ours)

Learning
Standard BC (ours)
Standard BC (ours)
Standard BC (ours)
Standard BC (ours)
Standard BC (ours)

Error rate (%) on

ESC-50

ESC-10 UrbanSound8K

29.20 ± 0.13 12.8 ± 0.4 24.11 ± 0.21 11.3 ± 0.6

33.66 28.89

33.76 ± 0.18 16.4 ± 0.9 27.43 ± 0.25 13.9 ± 0.4

33.26 30.23

31.53 ± 0.53 18.2 ± 0.5 26.67 ± 0.15 14.2 ± 0.9

28.79 26.52

27.57 ± 0.21 13.2 ± 0.4 23.10 ± 0.27 9.4 ± 0.4

25.32 23.51

25.56 ± 0.29 14.2 ± 0.9 18.19 ± 0.20 10.6 ± 0.6

30.91 23.37

DSRNet (ours) + strong augment

Standard 21.17 ± 0.30 10.9 ± 0.6 BC (ours) 15.10 ± 0.15 8.6 ± 0.1

24.90 21.71

SoundNet8 + Linear SVM (Aytar et al., 2016) Human (Piczak, 2015b)

25.8 18.7

7.8 4.3

-

error rate (%) error rate (%)
error rate (%)

45 45 DSRNet standard DSRNet BC
40 40 DSRNet standard + augment
35 35 DSRNet BC + augment

30 30

25 25

20
15
10 0

EnvNet standard EnvNet BC (ours)
300 600 epochs

900

1200

20
15
10 0

300

600

900

1200

1500

1800

epochs

Figure 5: Training curves of EnvNet and DSRNet on ESC-50 (average of all trials).

0 36
34
32

300 600 900 1200 36

EnvNet standard EnvNet BC (ours)

34

32

30 30

28 28

26 26

24 24

22 0

300 600 900 total epochs

1200

22

Figure 6: Error rate vs. # of training epochs on ESC-50.

bled the number of training epochs when using BC learning. Later in this section, we examine the relationship between the number of training epochs and the performance.

4.1.1 EXPERIMENT ON EXISTING NETWORKS
First, we trained various types of existing networks. We selected EnvNet (Tokozume & Harada, 2017) as a network using both 1-D and 2-D convolutions, SoundNet5 (Aytar et al., 2016) and M18 (Dai et al., 2017) as networks using only 1-D convolution, and Logmel-CNN (Piczak, 2015a) + BN as a network using log-mel features. Logmel-CNN + BN is an improved version of LogmelCNN that we designed in which, to convolutional layers, we apply batch normalization to the output and remove the dropout. Note that all networks and training codes are our implementation. We implemented them using Chainer v1.24 (Tokui et al., 2015).
The results are summarized in the upper half of Table 1. Our BC learning improves the performance of all networks on all datasets. The performance on ESC-50, ESC-10, and UrbanSound8K is improved by 4.47­6.33%, 1.5­4.0%, and 1.81­4.77%, respectively. We show the training curves of EnvNet on ESC-50 in Fig. 5(left). Note that the curves show the average of all trials.
7

Under review as a conference paper at ICLR 2018
4.1.2 EXPERIMENT ON A DEEPER NETWORK
To investigate the effectiveness of BC learning on deeper networks, we constructed a deep sound recognition network based on EnvNet, which we refer to as DSRNet, and trained it with both standard and BC learning. The main differences between EnvNet and DSRNet are as follows: 1) EnvNet uses a sampling rate of 16 kHz for the input waveforms, whereas DSRNet uses 44.1 kHz; and 2) EnvNet consists of 7 layers, whereas DSRNet consists of 13 layers. A detailed configuration is provided in the appendix B.
The results are also shown in the upper half of Table 1, and the training curves on ESC-50 are given in Fig. 5(right). The performance also improves with BC learning, and the degree of the improvement is greater than other networks (7.37%, 3.6%, and 7.54% on ESC-50, ESC-10, and UrbanSound8K, respectively). The error rate of DSRNet trained with BC learning is the lowest on ESC-50 and UrbanSound8K among all the models including Logmel-CNN + BN, which uses powerful handcrafted features. Moreover, the error rate on ESC-50 (18.19%) is comparable to human performance reported by Piczak (2015b) (18.7%). The point is not that our DSRNet is well designed, but that our BC learning successfully elicits the true value of a deep sound recognition network.
4.1.3 EXPERIMENT WITH STRONG DATA AUGMENTATION
We compared the performances of standard and BC learning when using a stronger data augmentation scheme. In addition to zero padding and random cropping, we used scale augmentation with a factor randomly selected from [0.8, 1.25] and gain augmentation with a factor randomly selected from [-6 dB, +6 dB]. Scale augmentation was performed before zero padding (thus, before mixing when employing BC learning) using linear interpolation, and gain augmentation was performed just before inputting to the network (thus, after mixing when using BC learning).
The results for DSRNet are shown in the lower half of Table 1, and the training curves on ESC-50 are given in Fig. 5(right). With BC learning, the performance significantly improves even when we use a strong data augmentation scheme. Furthermore, the performance on ESC-50 (15.10%) surpasses the human performance (18.7%). BC learning performs well on various networks, datasets, and data augmentation schemes, and using BC learning is always beneficial.
4.1.4 RELATIONSHIP BETWEEN # OF TRAINING EPOCHS
We investigated the relationship between the performance and the number of training epochs, because the previously described experiments were conducted using different numbers of training epochs (we used 2x training epochs for BC learning). Fig. 6 shows the error rate of EnvNet on ESC-50 with various numbers of training epochs. This figure shows that for standard learning, approximately 600 training epochs are sufficient. However, this number is insufficient for BC learning. Although BC learning performs significantly better than standard learning with 600 epochs, improved performance is achieved when using more training epochs. However, if the number of training epochs is small, the performance of BC learning is lower than that of standard learning. We can say that BC learning always improves the performance as long as we use a sufficiently large number of training epochs. Empirically, BC learning requires at least the same number of training epochs sufficient for standard learning, and the performance would further improve when using more training epochs.
4.2 ABLATION ANALYSIS
To understand the part that is important for BC learning, we conducted an ablation analysis. We trained EnvNet on ESC-50 using various settings. All results are shown in Table 2. We also performed 5-fold cross-validation five times and show the standard error.
Mixing methods We compared the mixing formula (Eqn. 1 vs. Eqn. 2, which consider the sound pressure levels of two sounds) and the calculation method for sound pressure levels (RMS vs. Aweighting). As shown in Table 2, the proposed mixing method using Eqn. 2 and A-weighting performs the best. Considering the difference of the sound pressure levels of two sounds is important for BC learning, and the method used to define the sound pressure levels also has an effect on the performance.
8

Under review as a conference paper at ICLR 2018

Table 2: Ablation analysis. We trained EnvNet using various settings on ESC-50. The results show that the training data variation is not the only matter.

Comparison of Mixing method Label # of mixed classes
Where to mix

Setting
Eqn. (1) Eqn. (2) + RMS Eqn. (2) + A-weighting (proposed)
Single Multi Ratio (proposed)
N =1 N = 1 or 2 N = 2 (proposed) N = 2 or 3 N =3
Input (proposed) pool2 pool3 pool4 fc5 fc6

Error rate (%)
26.80 ± 0.07 26.51 ± 0.19 24.11 ± 0.21
26.53 ± 0.16 25.02 ± 0.31 24.11 ± 0.21
27.28 ± 0.22 24.81 ± 0.33 24.11 ± 0.21 24.07 ± 0.21 25.32 ± 0.24
24.11 ± 0.21 27.10 ± 0.28 28.73 ± 0.27 28.83 ± 0.21 28.48 ± 0.15 28.63 ± 0.22

Standard learning

29.20 ± 0.13

Label We compared the different labels that we applied to the mixed sound. As shown in Table 2, the proposed ratio label of t = r t1 + (1 - r) t2 performs the best. When we apply a single label of the dominant sound (i.e., t = t1 if r > 0.5, otherwise t = t2) and train the model using softmax cross entropy loss, the performance also improves compared to that of standard learning. However, the degree of improvement is small. When we apply a multi-label (i.e., t = t1 + t2) and train the model using sigmoid cross entropy loss, the performance is better than when using a single label. However, the performance is worse than when using our ratio label. The model can learn the between-class examples more efficiently when using our ratio label.
Number of mixed classes We investigated the relationship between the performance and the number of classes of sounds that we mixed. N = 1 in Table 2 means that we mixed two sounds belonging to the same class, which is similar to Takahashi et al. (2016). N = 1 or 2 means that we completely randomly selected two sounds to be mixed; sometimes these two sounds were the same class. N = 2 means that we mixed two sounds belonging to different classes (proposed). N = 2 or 3 means that we mixed two and three sounds belonging to different classes with probabilities of 0.5 and 0.5, respectively. N = 3 means that we mixed three sounds belonging to different classes. When we mixed three sounds, we used a mixing method that is an extended version of Eqn. 2 for three classes, and we generated the mixing ratio from Dir(1, 1, 1). As shown in Table 2, the proposed N = 2 performes well. Although N = 2 or 3 is marginally better than N = 2, it does not represent a significant difference. It is interesting to note that the performance of N = 3 is worse than that of N = 2 despite the larger variation in training data. We believe that the most important factor is not the training data variation but rather the enlargement of Fisher's criterion and the regularization of the positional relationship among the feature distributions. Mixing more than two sounds leads to increased training data variation, but we expect that cannot efficiently achieve them.
Where to mix Finally, we investigated what occurs when we mix two examples within the network. We input two sounds to be mixed into the model and performed the forward calculation to the mixing point. We then mixed the activations of two sounds at the mixing point and performed the rest of the forward calculation. We mixed two activations h1 and h2 simply by r h1 + (1 - r) h2 . As shown in Table 2, the performance tends to improve when we mix two examples at the layer near the input layer. The performance is the best when we mix in the input space. Mixing in the input space is the best choice, not only because it performs the best, but also because it does not require

9

Under review as a conference paper at ICLR 2018
additional forward/backward computation. It is also easier to implement than when mixing within the network.
5 CONCLUSION
We proposed a novel learning method for deep sound recognition, called BC learning. Our method improved the performance on various networks, datasets, and data augmentation schemes. Moreover, we achieved a performance surpasses the human level by constructing a new deep sound recognition network named DSRNet and training it with BC learning. BC learning is a simple and powerful method that improves various sound recognition methods and elicits the true value of large-scale networks. Furthermore, BC learning is innovative in that a discriminative feature space can be learned from between-class examples, without inputting pure examples. We assume that the core idea of BC learning is generic and could contribute to the improvement of the performance of tasks of other modalities.
REFERENCES
Ossama Abdel-Hamid, Abdel-rahman Mohamed, Hui Jiang, Li Deng, Gerald Penn, and Dong Yu. Convolutional neural networks for speech recognition. IEEE/ACM TASLP, 22(10):1533­1545, 2014.
Senjian An, Farid Boussaid, and Mohammed Bennamoun. How can deep rectifier networks achieve linear separability and preserve distances? In ICML, 2015.
Yusuf Aytar, Carl Vondrick, and Antonio Torralba. Soundnet: Learning sound representations from unlabeled video. In NIPS, 2016.
Wei Dai, Chia Dai, Shuhui Qu, Juncheng Li, and Samarjit Das. Very deep convolutional neural networks for raw waveforms. In ICASSP, 2017.
Steven B Davis and Paul Mermelstein. Comparison of parametric representations for monosyllabic word recognition in continuously spoken sentences. IEEE TASSP, 28(4):357­366, 1980.
Ronald A Fisher. The use of multiple measurements in taxonomic problems. Annals of eugenics, 7(2):179­188, 1936.
Jort F. Gemmeke, Daniel P. W. Ellis, Dylan Freedman, Aren Jansen, Wade Lawrence, R. Channing Moore, Manoj Plakal, and Marvin Ritter. Audio set: An ontology and human-labeled dataset for audio events. In ICASSP, 2017.
Kaiming He, Xiangyu Zhang, Shaoqing Ren, and Jian Sun. Deep residual learning for image recognition. In CVPR, 2016.
Sergey Ioffe and Christian Szegedy. Batch normalization: Accelerating deep network training by reducing internal covariate shift. In ICML, 2015.
Yoon Kim. Convolutional neural networks for sentence classification. In EMNLP, 2014.
Alex Krizhevsky, Ilya Sutskever, and Geoffrey E Hinton. Imagenet classification with deep convolutional neural networks. In NIPS, 2012.
Yann LeCun, Le´on Bottou, Yoshua Bengio, and Patrick Haffner. Gradient-based learning applied to document recognition. In IEEE, 1998.
Beth Logan et al. Mel frequency cepstral coefficients for music modeling. In ISMIR, 2000.
Kuba Lopatka, Pawel Zwan, and Andrzej Czyzewski. Dangerous sound event recognition using support vector machine classifiers. In Advances in Multimedia and Network Information System Technologies, pp. 49­57. 2010.
Giambattista Parascandolo, Heikki Huttunen, and Tuomas Virtanen. Recurrent neural networks for polyphonic sound event detection in real life recordings. In ICASSP, 2016.
Karol J Piczak. Environmental sound classification with convolutional neural networks. In MLSP, 2015a.
Karol J Piczak. Esc: Dataset for environmental sound classification. In ACM Multimedia, 2015b.
10

Under review as a conference paper at ICLR 2018
Tara N Sainath, Oriol Vinyals, Andrew Senior, and Hasim Sak. Convolutional, long short-term memory, fully connected deep neural networks. In ICASSP, 2015a.
Tara N Sainath, Ron J Weiss, Andrew Senior, Kevin W Wilson, and Oriol Vinyals. Learning the speech frontend with raw waveform cldnns. In Interspeech, 2015b.
Justin Salamon and Juan Pablo Bello. Deep convolutional neural networks and data augmentation for environmental sound classification. IEEE SPL, 24(3):279­283, 2017.
Justin Salamon, Christopher Jacoby, and Juan Pablo Bello. A dataset and taxonomy for urban sound research. In ACMMM, 2014.
Karen Simonyan and Andrew Zisserman. Very deep convolutional networks for large-scale image recognition. In ICLR, 2015.
Nitish Srivastava, Geoffrey Hinton, Alex Krizhevsky, Ilya Sutskever, and Ruslan Salakhutdinov. Dropout: A simple way to prevent neural networks from overfitting. JMLR, 15(Jun):1929­1958, 2014.
Naoya Takahashi, Michael Gygli, Beat Pfister, and Luc Van Gool. Deep convolutional neural networks and data augmentation for acoustic event detection. In Interspeech, 2016.
Yuji Tokozume and Tatsuya Harada. Learning environmental sounds with end-to-end convolutional neural network. In ICASSP, 2017.
Seiya Tokui, Kenta Oono, and Shohei Hido. Chainer: a next-generation open source framework for deep learning. In NIPS Workshop on Machine Learning Systems, 2015.
Michel Vacher, Jean-Franc¸ois Serignat, and Stephane Chaillol. Sound classification in a smart room environment: an approach using gmm and hmm methods. In SPED, 2007.
Xiang Zhang, Junbo Zhao, and Yann LeCun. Character-level convolutional networks for text classification. In NIPS, 2015.
11

Under review as a conference paper at ICLR 2018

A LEARNING SETTINGS

Table 3 shows the detailed learning settings of standard learning. We trained the model by beginning with a learning rate of Initial LR, and then divided the learning rate by 10 at the epoch listed in LR schedule. To improve convergence, we used a 0.1x smaller learning rate for the first Warmup epochs. We then terminated training after # of epochs epochs. We doubled # of epochs and LR schedule when using BC learning, as we mentioned in the paper.

Table 3: Details of learning settings.

Dataset ESC-50 ESC-10 UrbanSound8K

Model
EnvNet SoundNet5 M18 Logmel-CNN DSRNet
EnvNet SoundNet5 M18 Logmel-CNN DSRNet
EnvNet SoundNet5 M18 Logmel-CNN DSRNet

# of epochs
600 300 400 300 1,000
600 300 400 300 600
400 200 300 200 600

Initial LR
0.01 0.1 0.1 0.01 0.1
0.01 0.1 0.1 0.01 0.01
0.01 0.1 0.1 0.01 0.1

LR schedule
{300, 450} {150, 225} {200, 300} {150, 225} {300, 600, 900}
{300, 450} {150, 225} {200, 300} {150, 225} {300, 450}
{200, 300} {100, 150} {150, 225} {100, 150} {180, 360, 540}

Warmup
0 0 0 0 10
0 0 0 0 0
0 0 0 0 10

B DSRNET: DEEP SOUND RECOGNITION NETWORK
Table 4 shows the configuration of our DSRNet used in the experiments. DSRNet consists of 10 convolutional layers, 3 fully connected layers, and 5 max-pooling layers. We use a sampling rate of 44.1 kHz, which is the standard recording setting, and a higher resolution than existing networks (Piczak, 2015a; Aytar et al., 2016; Dai et al., 2017; Tokozume & Harada, 2017), in order to use rich high-frequency information. The basic idea is motivated by EnvNet (Tokozume & Harada, 2017), but the advantages of other successful networks are incorporated. First, we extract short-time frequency features with the first two temporal convolutional layers and a pooling layer (conv1­pool2). Second, we swap the axes and convolve in time and frequency domains with the later layers (conv3­ pool10). In this part, we hierarchically extract the temporal features by stacking the convolutional and pooling layers with decreasing their kernel size in a similar manner to SoundNet (Aytar et al., 2016). Furthermore, we stack multiple convolutional layers with a small kernel size in a similar manner to M18 (Dai et al., 2017) and VGG (Simonyan & Zisserman, 2015), to extract more rich features. Finally, we produce output predictions with fc11­fc13 and the following softmax activation. Single output prediction is calculated from 66,650 input samples (approximately 1.5 s at 44.1 kHz). We do not use padding in convolutional layers. We apply ReLU activation for all the hidden layers and batch normalization (Ioffe & Szegedy, 2015) to the output of conv1­conv10. We also apply dropout (Srivastava et al., 2014) to the output of fc11 and fc12.

12

Under review as a conference paper at ICLR 2018

Table 4: Configuration of DSRNet. Data shape represents the dimension in (channel, frequency, time).

Layer
Input
conv1 conv2 pool2
swapaxes
conv3, 4 pool4
conv5, 6 pool6
conv7, 8 pool8
conv9, 10 pool10
fc11 fc12 fc13

ksize
(1, 64) (1, 16) (1, 64)
(8, 8) (5, 3) (1, 4) (1, 2) (1, 2) (1, 2) (1, 2) (1, 2)
-

stride
(1, 2) (1, 2) (1, 64)
(1, 1) (5, 3) (1, 1) (1, 2) (1, 1) (1, 2) (1, 1) (1, 2)
-

# of filters
32 64
32 64 128
256
4096 4096 # of classes

Data shape (1, 1, 66,650)
(64, 1, 260) (1, 64, 260)
(32, 10, 82)
(64, 10, 38)
(128, 10, 18)
(256, 10, 8) (4,096, ) (4,096, )
(# of classes, )

13

