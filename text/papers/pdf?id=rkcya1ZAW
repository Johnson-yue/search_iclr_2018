Under review as a conference paper at ICLR 2018
CONTINUOUS-TIME FLOWS FOR EFFICIENT INFERENCE AND DENSITY ESTIMATION
Anonymous authors Paper under double-blind review
ABSTRACT
Two fundamental problems in unsupervised learning are efficient inference for latent-variable models and robust density estimation based on large amounts of unlabeled data. For efficient inference, normalizing flows have been recently developed to approximate a target distribution arbitrarily well. In practice, however, normalizing flows only consist of a finite number of deterministic transformations, and thus they possess no guarantee on the approximation accuracy. For density estimation, the generative adversarial network (GAN) has been advanced as an appealing model, due to its often excellent performance in generating samples. In this paper, we propose the concept of continuous-time flows (CTFs), a family of diffusion-based methods that are able to asymptotically approach a target distribution. Distinct from normalizing flows and GANs, CTFs can be adopted to achieve the above two goals in one framework, with theoretical guarantees. Our framework includes distilling knowledge from a CTF for efficient inference, and learning an explicit energy-based distribution with CTFs for density estimation. Experiments on various tasks demonstrate promising performance of the proposed CTF framework, compared to related techniques.
1 INTRODUCTION
Efficient inference and robust density estimation are two important goals in unsupervised learning. In fact, inference and density estimation can be unified from the perspective of learning desired target distributions. In inference problems, one is given an unnormalized distribution (e.g., the posterior distribution), and the goal is to learn a distribution that is close to the unnormalized distribution. In density estimation, one tries to learn an unknown data distribution given samples from it. It is also helpful to make a distinction between two types of representations for learning distributions: explicit and implicit methods (Mohamed & Lakshminarayanan, 2017). Explicit methods provide a prescribed parametric form for the distribution, while implicit methods learn a stochastic procedure to directly generate samples from the unknown distribution.
Existing deep generative models can easily be identified from this taxonomy. For example, the standard variational autoencoder (VAE) (Kingma & Welling, 2014; Rezende et al., 2014) is an important example of an explicit inference method. Within the inference arm (encoder) of a VAE, recent research has focused on improving the accuracy of the approximation to the posterior distribution on latent variables (codes) using normalizing flow (Rezende & Mohamed, 2015). Normalizing flow is particularly interesting due to its ability to approximate the posterior distribution arbitrarily well, while maintaining explicit parametric forms. On the other hand, Stein VAE (Feng et al., 2017; Pu et al., 2017b) is an implicit inference method, as it only learns to draw samples to approximate posteriors, without assuming an explicit form for the distribution.. For density estimation on observed data, the generative adversarial network (GAN) can be regarded as an implicit density estimation method (Ranganath et al., 2016; Huszár, 2017; Mohamed & Lakshminarayanan, 2017), in the sense that one may sample from the distribution (regarded as a representation of the unknown distribution), but an explicit form for the distribution is not estimated. GAN has recently been augmented by Flow-GAN (Grover et al., 2017) to incorporate a likelihood term for explicit density estimation. Further, there also are some works trying to perform inference within the implicit density estimation framework, e.g., the real-valued non-volume preserving (real NVP) transformations algorithm (Dinh et al., 2017) was proposed as a tractable yet expressive approach to model high-dimensional data.
1

Under review as a conference paper at ICLR 2018
Some aforementioned methods rely on the concept of flows. A flow defines a series of transformations for a random variable (RV), such that the distribution of the RV evolves from a simple distribution to a more complex distribution. When the sequence of transformations are indexed on a discrete-time domain (e.g., indexed with integers) with a finite number of transformations, this method is referred to as a normalizing flow (Rezende & Mohamed, 2015). Various efficient implementations of normalizing flows have been proposed, such as the planar, radial (Rezende & Mohamed, 2015), Householder (Tomczak & Welling, 2016), and inverse autoregressive flows (Kingma et al., 2016). One theoretical limitation of existing normalizing flows is that there is no guarantee on the approximation accuracy due to the finite number of transformations.
By contrast, little work has explored the applicability of continuous-time flows (CTFs) in deep generative models, where a sequence of transformations are indexed on a continuous-time domain (e.g., indexed with real numbers). There are at least two reasons encouraging research in this direction: i) CTFs are more general than traditional normalizing flows in terms of modeling flexibility, due to the intrinsic infinite number of transformations; ii) CTFs are more theoretically grounded, in the sense that they are guaranteed to approach a target distribution asymptotically (details provided in Section 2.2). Unfortunately, these advantages also bring challenges for efficient learning, in that: i) it is difficult to optimize over the variational lower bound in the inference framework, due to the extra randomness introduced in CTFs; ii) it is difficult to design algorithms for efficient learning of CTF-based models, due to the induced infinite number of transformations.
In this paper, we propose efficient ways to apply CTFs for the two motivating tasks. Based on the CTF, our framework learns to drawn samples directly from desired distributions (e.g., the unknown posterior and data distributions) for both inference and density estimation tasks. In addition, we are able to learn an explicit form of the unknown data distribution for density estimation. This shares a similar flavor as Wang & Liu (2017); Feng et al. (2017). Specifically, i) for efficient inference, we first show that optimizing the variational lower bound with CTFs can be achieved by decomposing the optimization problem into a sequence of sub-optimization problems, based on a variational formulation of the Fokker-Planck equations from statistical physics (Jordan et al., 1998). Based on this decomposition, we derive bounds on the approximation errors when applying numerical methods to solve a CTF. For computational efficiency, we generalize ideas from Gershman & Goodman (2014) to distill knowledge of a CTF into an efficient inference network; ii) for density estimation, we propose to use a flexible Gibbsian-style distribution (implemented by a deep neural network) to model an unknown data distribution, whose samples can be drawn by learning a stochastic generator with our CTF framework. The Gibbsian-style data distribution and the stochastic generator are learned alternatively, leading to a learning procedure that is connected to the GAN framework (Goodfellow et al., 2014), but that yields an explicit distribution for the data. We conduct a number of experiments on real datasets, demonstrating excellent performance of the proposed framework, relative to existing representative approaches.
2 PRELIMINARIES
We first review related techniques of performing efficient inference and density estimation in the machine learning literature. We then introduce the general concept of continuous-time flows.
2.1 EFFICIENT INFERENCE AND DENSITY ESTIMATION
Efficient inference with normalizing flows Consider a probabilistic generative model with observation x  RD and latent variable z  RL such that x | z  p(x | z) with z  p(z). For efficient inference of z, the VAE (Kingma & Welling, 2014) introduces the concept of an inference network (recognition model or encoder), q(z | x), as a variational distribution in the VB framework. An inference network is typically a stochastic (nonlinear) mapping from the input x to the latent z, with associated parameters . For example, one of the simplest inference networks is defined as q(z | x) = N (z; µ(x), diag(2(x))), where the mean function µ(x) and the standardderivation function (x) are specified via deep neural networks parameterized by . Parameters are learned by minimizing the evidence lower bound (ELBO), i.e., the KL divergence between p(x, z)
Although the density is represented as an energy-based distribution with an intractable normalizer.
2

Under review as a conference paper at ICLR 2018

and q(z | x): KL (q(z | x) p(x, z)) Eq(z | x) [log q(z | x) - log p(x, z)], via stochastic gradient descent (Bottou, 2012).

One limitation of the VAE framework is that q(z | x) is often restricted to simple distributions for feasibility, e.g., the normal distribution discussed above, and thus the gap between q(z | x) and p(z | x) is typically large for complicated posterior distributions. Normalizing flows is a recently proposed VB-based technique designed to mitigate this problem (Rezende & Mohamed, 2015). The idea is to augment z via a sequence of deterministic invertible transformations {Tk : RL  RL}kK=1, such that: z0  q(·| x), z1 = T1(z0), · · · , zK = TK (zK-1).

Note the transformations {Tk} are typically endowed with different parameters, and we absorb

them into . Because the transformations are deterministic, the distribution of zK can be written as

q(zK ) = q(z0 | x)

K k=1

det

Tk  zk

-1
via the change of variable formula. As a result, the ELBO for

normalizing flows becomes:

KL (q(zK | x) p(x, z)) = Eq (z0 | x) [log q (z0 | x)] - Eq (z0 | x) [log p(x, zK )] - Eq (z0 | x)

K
log
k=1

det

Tk  zk

(1) .

Typically, transformations Tk of a simple parametric form are employed to make the computations tractable (Rezende & Mohamed, 2015). Our method for inference generalizes these discrete-time
transformation to continuous-time transformations, ensuring convergence of the transformations to
the target distribution.

Density estimation overview There exist implicit and explicit density-estimation methods. Implicit density models such as GAN provide a flexible way to draw samples directly from unknown data distributions (via a deep neural network (DNN) called a generator with stochastic inputs) without explicitly modeling their density forms; whereas explicit models such as the pixel RNN/CNN (van den Oord et al., 2016) define and learn explicit forms of the unknown data distributions. This gives the advantage that the likelihood for a test data point can be explicitly evaluated. However, the generation of samples is typically time-consuming due to the sequential generation nature.
Similar to Wang & Liu (2017), our CTF-based approach in Section 4 provides an alternative way for this problem, by simultaneously learning an explicit Gibbsian-style data distribution (estimated density) and a generator whose generated samples match the learned Gibbsian distribution. This not only gives us the advantage of explicit density modeling but also provides an efficient way to generate samples.

2.2 CONTINUOUS-TIME FLOWS

We notice two potential limitations with traditional normalizing flows: i) given specified transformations {Tk}, there is no guarantee that the distribution of zK could exactly match p(x, z); ii) the randomness is only introduced in z0 (from the inference network), limiting the representation power. We specify CTFs where the transformations are indexed by real numbers, thus they could be
considered as consisting of an infinite number of transformations. Further, we consider stochastic
flows where randomness is injected in a continuous-time manner. In fact, the concept of CTFs
(such as the Hamiltonian flow) has been introduced in Rezende & Mohamed (2015), without further
development on efficient inference.

We consider a flow on RL, defined as the mapping T : RL × R  RL such that we have T (Z, 0) = z and T (T (Z, t), s) = T (Z, s + t), for all Z  RL and s, t  R. A typical example of this family is defined as T (Z, t) = Zt, where Zt is driven by a diffusion of the form:

d Zt = F (Zt)dt + V (Zt)dW .

(2)

We reuse the notation T as transformations from the discrete case above for simplicity, and use Z instead of z (reserved for the discrete-time setting) to denote the random variable in the continuous-time setting.
Note we define continuous-time flows in terms of latent variable Z in order to incorporate it into the setting
of inference. However, the same description applies when we define the flow in data space, which is the setting
of density estimation in Section 4.

3

Under review as a conference paper at ICLR 2018

Here F : RL  RL, V : RL×L  RL are called the drift term and diffusion term, re-

spectively; W is the standard L-dimensional Brownian motion. In the context of inference, we

seek to make the stationary distribution of Zt approach p(z | x). One solution for this is to set

F (Zt)

=

1 2

z

log p(x, z

=

Zt)

and

V

(Zt)

=

IL

with

IL

the

L

×

L

identity

matrix.

The

resulting

diffusion is called Langevin dynamics Welling & Teh (2011). Denoting the distribution of Zt as t, it

is well known Risken (1989) that t is characterized by the Fokker-Planck (FP) equation:

t t

= -z · (tF (Zt)) + zz :

tV (Zt)V

(Zt)

,

(3)

where a · b a b for vectors a and b, A : B trace(A B) for matrices A and B.

For simplicity, we consider the flow defined by the Langevin dynamics specified above, though our results generalize to other stochastic flows Dorogovtsev & Nishchenko (2014). In the following, we specify the ELBO under a CTF, which can then be readily solved by a discretized numerical scheme, based on the results from Jordan et al. (1998). An approximation error bound for the scheme is also derived. We defer proofs of our theoretical results to the Supplementary Material (SM) for conciseness.

3 CONTINUOUS-TIME FLOWS FOR INFERENCE

We first give an overview of our CTF-based method for efficient inference. We adopt the VAE/normalizing-flow framework with an encoder-decoder structure. An important difference is that instead of feeding data to an encoder and sampling a latent representation in the output as in VAE, we concatenate the data with independent noise as input and directly generate output samples§. These output samples are then driven by the CTF to approach the true posterior distribution. In the learning process, the implicit transformations from the CTF are distilled into the inference network sequentially by amortized learning, making the inference network flexible enough to represent the true posterior distribution. In the following subsections, we specify our framework in detail.

3.1 THE VARIATIONAL LOWER BOUND AND DISCRETIZED APPROXIMATION

There are two steps in inference with CTFs. First, an initial z0 is drawn from the inference network q(·| x); second, z0 is evolved via a diffusion such as (2) for time T , resulting in ZT . Under a perfect simulation, i.e., there is no numerical error in ZT , we can prove that the CTF is volume preserving in
expectation, stated in Proposition 1.

Proposition 1 (Volume Preservation). Under a perfect simulation, the CTF is volume preserving,

i.e.,

the

Jacobian

matrix

defined

by

E[ZT ]  z0

equals

to

the

identity

matrix,

where

the

expectation

is

taken over all the randomness of the CTF.

Based on Proposition 1, the Jacobian term in the ELBO of standard normalizing flows in (1) vanishes for CTFs. Furthermore, because the randomness of the CTF comes from both z0 and Zt (t  (0, T ]), the ELBO for CTF can be written as

F (x) = Eq(z0 | x)Et:t(0,T ] [log T - log p(x, ZT )] Eq(z0 | x) [F1(x, z0)] .

(4)

Note the term F1(x, z0) is intractable to calculate since t does not have an explicit form. Fortunately, a reformulation of the results from Jordan et al. (1998) leads to a nice way to approximate t.

Lemma 2. Assume that log p(x, z)  C1 is infinitely differentiable, and z log p(x, z)  C2 (1 + C1 - log p(x, z)) ( x, z) for some constants {C1, C2}. Let T = hK with K being an

integer, 0 q(z0 | x), and {~k}kK=1 be the solution of the functional optimization problem:

~k

= arg min KL (
K

p(x, z)) +

1 2h

W22

(~k-1

,

)

,

(5)

where W22 (µ1, µ2)

inf pP(µ1,µ2)

x-y

2 2

p(d

x,

d

y),

W2 (µ1, µ2) is the 2nd-order Wasser-

stein distance, with P(µ1, µ2) being the space of joint distributions of {µ1, µ2}. K is the space of

probability distributions with finite 2nd-order moment. Then ~K converges to T in the limit of

h  0, i.e., limh0 ~K = T , where T is the solution of the FP equation (3) at time T .

§Such structure can represent much more complex distributions than a parametric form, useful for following procedures. We argue an explicit distribution form is not as important in inference as that in density estimation.

4

Under review as a conference paper at ICLR 2018

Lemma 2 reveals an interesting way to compute T via a sequence of functional optimization problems. By comparing it with the objective of the traditional normalizing flow, which minimizes the KL-divergence between 0 and p(x, z), at each sub-optimization-problem in Lemma 2, it minimizes the KL-divergence between ~k and p(x, z), plus a regularization term as the Wasserstein distance between ~k-1 and ~k. The extra Wasserstein-distance term arises naturally due to the fact that the Langevin diffusion can be explained as a gradient flow equipped with a geometric
associated with the Wasserstein distance (Otto, 1998). From another point of view, it is known
that the Wasserstein distance is a better metric for probability distributions than the KL-divergence,
especially in the case of non-overlapping domains (Arjovsky & Bottou, 2017; Arjovsky et al., 2017).
By using the Wasserstein term as a regularizer, the CTF alleviates the issue in non-overlapping
domains by introducing the Brownian-motion (noise) term in the evolution (2). This relates to the
idea in (Arjovsky & Bottou, 2017), in which noise is added in parameter updates to alleviate the
intrinsic drawback of the KL-divergence metric.

Lemma 2 also suggests a natural way to solve T by discretization. Starting from z0, zk (k = 0, · · · , K - 1) is fed into a transformation Tk (specified below), resulting in zk+1 whose distribution
coincides with ~k+1. The discretization procedure is illustrated in Figure 1. We must specify the transformations Tk. For each k, let t = hk; we can conclude from Lemma 2 that limh0 ~k = t.
From FP theory, t is obtained by solving the diffusion (2) with initial condition Z0 = z0. It is thus reasonable to specify the transformation Tk as the k-th step of a numerical integrator for (2). Specifically, we specify Tk as a stochastic transformation:

zk = Tk(zk-1) zk-1 +F (zk-1)h + V (zk-1)k ,

where k  N (0, hIL) is drawn from an isotropic normal; h here is interpreted as the step size. Note

the transformation defined here is stochastic, thus we only get samples from ~K at the end. A natural

way

to

approximate

~K

is

to

use

the

empirical

sample

distribution,

i.e.,

~K



1 K

K k=1

zk

¯T

with z a point mass at z. Afterwards, ~K (thus ¯T ) will be used to approximate the true T from (3).

Consequently, the F1(x, z0) term in the ELBO (4) can be approximated by substituting T with ¯T .

Z0

ZT

z0 z1 z2

zK 1 zK

continuous-time flows

T1 T2



TK 1







4.5 4 3.5 3 2.5 2 1.5 1 0.5
0
0 0.5 1 1.5 2 2.5 3

"# (%&|()

*+ ((|%)

Inference network Generative model

"# (%&|()

*+ ((|%)

Inference network Generative model

Figure 1: Discretized approximation (right) of a continuous-time flow (left). Densities {~k} of {zk} evolve via transformations {Tk}, with ~k  hk when h  0 for each k due to Lemma 2.

In the following, we study how well ¯T approximates T . Following literature on numerical

approximation for Itô diffusions (Vollmer et al., 2016; Chen et al., 2015), we consider a 1-Lipschitz test function  : RL  R, and use the mean square error (MSE) bound to measure the closeness of ¯T and T , defined as: MSE(¯T , T ; ) E (z)(~T - T )(z)d z 2, where the expectation is taken over all the randomness in the construction of ~T . Note that our goal is related but different

from the standard setup as in Vollmer et al. (2016); Chen et al. (2015), which studies the closeness

of ¯T to p(x, z). We need to adopt the assumptions from Vollmer et al. (2016); Chen et al. (2015),

which are described in the Supplementary Material (SM). The assumptions are somewhat involved

but essentially require coefficients of the diffusion (2) to be well-behaved. We derive the following

bound for the MSE of the sampled approximation, ¯T , and the true distribution.

Theorem 3. Under Assumption 1 in the SM, assume that T (z)p-1(x, z)d z <  and there exists

a

constant

C

such

that

dW22(T ,p (x,z)) dt



CW22 (T , p(x, z)),

the

MSE

is

bounded

as

MSE(¯T , T ; ) = O

1 hK

+ h2

+ e-2ChK

.

5

Under review as a conference paper at ICLR 2018

The last assumption in Theorem 3 requires T to evolve fast through the FP equation, which is a standard assumption used to establish convergence to equilibrium for FP equations (Bolley
et al., 2012). The MSE bound consists of three terms, the first two terms come from numerical
approximation of the continuous-time diffusion, whereas the third term comes from the convergence
bound of the FP equation in terms of the Wasserstein distance (Bolley et al., 2012). When the time T = hK is large enough, the third term may be ignored due to its exponential-decay rate. Moreover, in the infinite-time limit, the bound endows a bias proportional to h; this, however, can be removed by adopting a decreasing-step-size scheme in the numerical method, as in standard stochastic gradient
MCMC methods (Teh et al., 2016; Chen et al., 2015).
Remark 4. To examine the optimal bound in Theorem 3, we drop out the term e-2ChK in the long-time case (when hK is large enough) for simplicity because it is in a much lower order term than the other terms. The optimal MSE bound (over h) decreases at a rate of O K-2/3 , meaning that O -3/2 steps of transformations in Figure 1 (right) are needed to reach an -accurate approximation, i.e., MSE  . This is computationally expensive. An efficient way for inference is thus imperative, developed in the next section.

3.2 EFFICIENT INFERENCE VIA AMORTIZATION

We adopt the idea of "amortized learning" (Gershman & Goodman, 2014) for efficient inference with continuous-time flows for the VAE. To explain the idea, we first approximate the ELBO (4) for a CTF-based VAE with samples:



F(x) 



[log ¯T - log p(x, zK )] ,

z0q (z0 | x),z1T1(z0) z2T2(z1),··· ,zK TK (zK-1)

(6)

where ¯T is the empirical distribution of the samples defined in Section 3.1. As mentioned previously, we will learn an implicit distribution of q(z0 | x) (i.e., learn how to draw samples from q(z0 | x)
instead of its explicit form), as it allows us to chose a candidate distribution from a much larger distribution space, compared to explicitly defining q¶. Consequently, q(z0 | x) is implemented by a stochastic generator (a DNN parameterized by ) Q(z0 | x, ) with input as the concatenation of x and , where  is a sample from an isotropic Gaussian distribution q0(). Our goal now is to update the parameter  of Q(z0 | x, ) to  such that the distribution of {z0 = Q (z0 | x, )} with   q0() matches that of z1 in the original generating process with  in Figure 1. In this way, the generating process of z1 via T1 is distilled into the parameterized generator Q(·), eliminating the need to do a specific transformation via T1 in testing, and thus is very efficient. Specifically, we update  such that

 = arg min D


{z0(i)}, {z1(i)}

,

(7)

where {z0(i)}Si=1 are a set of samples generated from q (z0 | x) via Q(·), and {z(1i)}Si=1 are samples drawn by i  q0(), z~i0 = Q(·| x, i), z(1i)  T1(z~i0); D(·, ·) is a metric between samples such as the simple Euclidean distance or the more advanced Wasserstein distance (Arjovsky et al., 2017).
The optimization is done by applying standard stochastic gradient descent. We call this procedure distilling knowledge from T1 to Q(·).
After distilling knowledge from T1, we apply the same procedure for other transformations Tk(k > 1) sequentially. The final inference network, represented by q(·| x), can then well approximate the continuous-time flows, e.g., the distribution of z0  q(·| x) is close to T from the CTF. This concept is illustrated in Figure 2. According to Theorem 3, the number of updates for  in training is still bounded by O( -3/2) for an -accurate MSE, however, inference in testing is significantly boosted since we do not need to simulate a long-time transformations as shown in Figure 1 (right).

To sum up, there are three main steps in learning a CTF-based VAE:

1. Generate a sample path (z0, · · · , zK ) according to q(z0 | x) and the discretized flow with transformations {Tk};
¶This is distinct from our density-estimation framework described in the next section, where an explicit form is assumed at the beginning for practical needs.

6

Under review as a conference paper at ICLR 2018

*+ ('|$) 
!"($%|')
*+ ('|$) 
 !"($%|')
*+ ('|$)  
 !"($%|')

$% $- $.

$,



step 1

$% $.

$,



 step K

$%

Figure 2: Amortized learning for variational auto-encoder with continuous-time flows. From left to
right: the initial architecture with K-step transformations; the architecture after 1-step update; the architecture after K-step updates. At the end, the CTF is distilled into q(·).

2. Optimize  by minimizing the ELBO (6) with the generated sample path; 3. Update  according to (7).
In testing, we use only the finally learned q(z0 | x) for inference (into which the CTF has been distilled), and hence testing is like the standard VAE. Since the discretized-CTF model is essentially a Markov chain, we call our model Markov-chain-based VAE (MacVAE).

4 CONTINUOUS TIME FLOWS FOR EXPLICIT DENSITY ESTIMATION

We describe the second problem for the proposed CTF framework ­ density estimation on observed

data. We consider models that directly describe the observations without an explicit latent variable,

i.e., we assume that the density of the observation x is described by a parametric Gibbsian-style

probability

model

p (x)

=

Z

1 ()

p~

(x)

1 Z ()

eU (x;) ,

where

p~ (x)

is

an

unnormalized

version

of

p(x) with parameter , U (x; ) log p~(x) is called the energy function (Zhao et al., 2017), and

Z() p~(x)d x is the normalizer. Note this form of distributions constitutes a very large class of

distributions as long as the capacity of the energy function is large enough. This is easily achieved

by using a DNN to implement U (x; ), the setting we considered in this paper. Note our model can

be placed in between existing implicit and explicit density estimation methods, because we model

the data density with an explicit distribution form up to an intractable normalizer. Such distributions

have been proved to be useful in real applications, e.g., Haarnoja et al. (2017) used them to model

policies in deep reinforcement learning.

Our goal is to learn  given observations {xi}iN=1. A standard way for this is via the maximum likelihood estimator (MLE):

N
 = arg max log p(xi)
 i=1

arg max M({xi}; )


The optimization is done by applying standard gradient descent, resulting in the following gradient formula:

M({xi}; ) 

=

1 N

N

U (xi; 

)

-

Ep (x)

U (x; ) 

i=1

(8)

The gradient formula requires an integration over the model distribution p(x), which can be approximated by Monte Carlo integration with samples. The sampling problem has been well studied
for some particular energy-based distributions, for example, via contrastive divergence in restricted
Boltzmann machines (Hinton, 2002). However, this does not fit into our setting directly. Here we
adopt the idea of CTFs and propose to use a deep neural network guided by a CTF, which we call a generator, to generate approximate samples from the original model p(x). Specifically, we require that samples from the generator should well approximate the target p(x). This can be done by adopting the CTF idea above, i.e., distilling knowledge of a CTF (which approaches p(x)) to the generator. In testing, instead of generating samples from p(x) via MCMC (which is complicated and time consuming), we generate samples from the generator directly. Furthermore, when evaluating the likelihood for test data, the unknown constant Z() of p(x) can also be approximated by Monte Carlo integration with samples drawn from the generator.

7

Under review as a conference paper at ICLR 2018

Algorithm 1 Continuous-time flows for generative models at the k-th iteration. D(·, ·) is the same as

(7).

Input: parameters from last step (k-1), (k-1) Output: updated parameters (k), (k) 1. Generate samples {x1,s}Ss=1 via a discretized CTF: x0,s  q(k-1) (x0), x1,s  T1(x0,s); 2. Update the generator by minimizing ({x0,s}Ss=1 are generated with the updated parameter (k)):

(k) = arg min D


{x1,s}, {x0,s}

.

3. Update the energy-based model k by maximum likelihood, with gradient as (8) except replacing

Exp(x) with Exq (x);

In (8), the first term to the right of the equality is a model fit to observed data, and the (negative)
second term is a model fit to synthetic data drawn from p(x); this is very much in the GAN (Arjovsky et al., 2017) spirit, but comes directly from the MLE. More connections are discussed below.

4.1 LEARNING VIA AMORTIZATION

%&

%,


4.5 4 3.5 3 2.5 2 1.5 1 0.5 0
0 0.5 1 1.5 2 2.5 3

Our goal is to learn a generator whose generated samples

match those from the original model p(x), by adopting the amortization idea with CTF in the inference section above.

continuous-time flows

Similar to inference, the generator is learned implicitly.

However, we also learn an explicit density model for the

data by SGD, with samples from the implicit generator to estimate gradients in (8). Note that in this case, the CTF is performed directly on the data space, instead of on latent-

"# (%&; ()
Generator

*+ (%)
Energy-basedmodel

variable space as in previous sections. Specifically, the

sampling procedure from the generator plus a continuous- Figure 3: Learning a generator with

time-flow transformation are written as:

CTF. The goal is to match the samples

x0  q(x0), xT  T (x0, T ) .

x0 from q to those after a CTF (xT ), or equivalently samples from p.

Here T (·, ·) is the continuous-time flow; a sample x0 from q(·) is implemented by a deep neural network (generator) G() with input   q0(), where q0 is a simple distribution for a noise random variable, e.g., the standard isotropic normal distribution. The procedure is illustrated in Figure 3. Note the CTF cannot be replaced by standard normalizing flow (Rezende & Mohamed, 2015) in this model, because there is no objective function to guide the update of parameters in normalizing flows, which is not necessary for CTFs.

Specifically, denote the parameters in the k-th step of our algorithm with subscript "(k)". For efficient
sample generation, in the k-th step, we again adopt the amortization idea from Section 3.2 to update (k-1) of the generator network G(·), such that samples from the updated generator match those from the current generator followed by a one-step transformation T1(·). After that,  is updated by drawing samples from q(·) to estimate the expectation in (8). The detailed algorithm is presented in
Algorithm 1.

4.2 CONNECTIONS TO WASSERSTEIN GAN (WGAN) AND MLE

There is an interesting relation between our model and the WGAN framework (Arjovsky et al., 2017). To see this, let pr be the data distribution. Substituting p(x) with q(x) for the expectation in the gradient formula (8) and integrating out , we have that our objective is

max Expr [U (x; )] - Exq [U (x; )]

(9)

The objective is an instance of the general integral probability metrics (Arjovsky & Bottou, 2017). When U is chosen to be 1-Lipschitz functions, it recovers WGAN. This connection motivates us to introduce weight clipping (Arjovsky et al., 2017) or alternative regularizers (Gulrajani et al., 2017)
8

Under review as a conference paper at ICLR 2018

when updating  for a better theoretical property. For this reason, we call our model Markov-chainbased GAN (MacGAN).

Furthermore, it can be shown by Jensen's inequality that the MLE is bounded by (detailed derivations are provided in Section C of the SM)

max

1 N

N

log p(xi)  max Expr [U (x; )] - Exq [U (x; )] - Exq [log q] .

i=1

(10)

By inspecting (9) and (10), it is clear that: i) when learning the energy-based model parameters ,
the objective can be interpreted as maximizing an upper bound of the MLE shown in (10); ii) when optimizing the parameter  of the inference network, we adopt the amortized learning procedure presented in Algorithm 1, whose objective is min KL (q p), coinciding with the last two terms in (10). In other words, both  and  are optimized by maximizing the same upper bound of the MLE,
guaranteeing convergence of the algorithm. Particularly, we can conclude that

Proposition 5. The optimal solution of MacGAN is the maximum likelihood estimator.

Note another difference between MacGAN and standard GAN framework is the way of learning the generator q. We adopt the amortization idea, which directly guides q to approach p; whereas in GAN, the generator is optimized via a min-max procedure to make it approach the empirical data distribution pr. By explicitly learning p, MacGAN is able to evaluate likelihood for test data (at least up to a constant).

5 RELATED WORK
Our framework extends the idea of normalizing flows (Rezende & Mohamed, 2015) to continuoustime flows, by developing theoretical properties on the convergence behavior. Inference based on CTFs has been studied in Salimans et al. (2015) based on the auxiliary-variable technique. However, Salimans et al. (2015) directly uses discrete approximations for the flow, and the approximation accuracy is unclear. Moreover, the inference network requires simulating a long Markov chain for the auxiliary model, thus is less efficient than ours. Finally, the inference network is implemented as a parametric distribution (e.g., the Gaussian distribution), limiting the representation power, a common setting in existing auxiliary-variable based models (Tran et al., 2016). The idea of amortization (Gershman & Goodman, 2014) has recently been explored in various research topics for Bayesian inference such as in variational inference (Kingma & Welling, 2014; Rezende et al., 2014) and Markov chain Monte Carlo (Wang & Liu, 2017; Li et al., 2017; Pu et al., 2017a). Both Wang & Liu (2017) and Pu et al. (2017a) extend the idea of Stein variational gradient descent (Liu & Wang, 2016) with amortized inference for a GAN-based and a VAE-based model, respectively, which resemble our proposed MacVAE and MacGAN in concept. Li et al. (2017) applies amortization to distill knowledge from MCMC to learn a student network. The ideas in Li et al. (2017) are similar to ours, but the motivation and underlying theory are different from that developed here.

6 EXPERIMENTS

We conduct experiments to test our CTF-based framework for efficient inference and density estimation described above, and compared them with related methods.

6.1 CTFS FOR INFERENCE

Synthetic experiment We examine our amortized learning framework with a toy experiment.

Following Rezende & Mohamed (2015), we use MacVAE to approximate samples from a two di-

mensional distribution on z = {z1, z2}: p(z)  e-U(z) with U (z)

1 2

(

z -2 0.4

)2

-

ln(e-

1 2

[

z1 -2 0.6

]2

+

e ).-

1 2

[

z1 +2 0.6

]2

The

inference

network

q

is

defined

to

be

a

2-layer

MLP

with

isotropic

normal

random

variables as input. Figure 4 (top) plots the densities estimated with the samples from transformations

{TK=100} (before optimizing ), as well as with samples generated directly from q (after optimizing ). It is clear that the amortized learning is able to distill knowledge from the CTF to the inference

network.

9

Under review as a conference paper at ICLR 2018

-86

-88

ELBO

z0  q (z0)

zK  TK (zK 1)

-90 -92 -94 -96
0

MacVAE VAE VAE+NF(T=1) VAE+NF(T=10)
20 40 60 80 100 Epoch

Figure 4: Knowledge distillation from the CTF (left) and ELBO versus epochs on MNIST (right). VAE with 80-layer NF is not included because it has much more parameters.

MacVAE on MNIST Following Rezende & Mohamed (2015); Tomczak & Welling (2016), we define the inference network as a deep neural network with two fully connected layers of size 300 with softplus activation functions. We compare MacVAE with the standard VAE and the VAE with normalizing flow, where testing ELBOs are reported (Section D.1 of the SM describes how to calculate the ELBO). We do not compare with other state-of-the-art methods such as the inverse autoregressive flow (Kingma et al., 2016), because they typically endowed more complicated inference networks (with more parameters), unfair for comparison. We use the same inference network architecture for all the models. Figure 4 (bottom) plots the testing ELBO versus training epochs. MacVAE outperforms VAE and normalizing flows with a better ELBO (around -85.62).

6.2 CTFS FOR DENSITY ESTIMATION

We test MacGAN on three datasets: MNIST, CIFAR-10

and CelabA. Following GAN-related methods, the model is evaluated by observing its ability to draw samples from the 6.5

Inception Score

learned data distribution. Inspiring by Wang & Liu (2017), 6

we define a parametric form of the energy-based model as p(x)  exp{- x -DEC (ENC(x)) 2}, where ENC(·) and DEC(·) are encoder and decoder defined

5.5 5

MacGAN WGAN-I SteinGAN DCGAN

by using deep convolutional neural networks and deconvo- 4.5 lutional neural networks, respectively, parameterized by .

For simplicity, we adopt the popular DCGAN architecture
(Radford et al., 2016) for the encoder and decoder. The generator G is defined as a 3-layer convolutional neural network with the ReLU activation function (except for the
top layer which uses tanh as the activation function, see

4 0 20 40 60 80 100 Epoch
Figure 6: Inception score versus epochs for different models.

SM

D

for

details).

Following

Wang

&

Liu

(2017),

the

stepsizes

are

set

to

(me -e)×lr me -50

,

where

e

indexes

the epoch, me is the total number of epochs, lr = 1e-4 when updating , and lr = 1e-3 when

updating . The stepsize in L1 is set to 1e-3.

We compare MacGAN with DCGAN (Radford et al., 2016), the improved WGAN (WGAN-I) (Gulrajani et al., 2017) and SteinGAN (Wang & Liu, 2017). We plot images generated with MacGAN and its most related method SteinGAN in Figure 5 for CelebA and CIFAR-10 datasets. More results are provided in SM Section D. We observe that visually MacGAN is able to generate clear-looking images. Following Wang & Liu (2017), we also plot the images generated by a random walk in the  space in Figure 5.

Qualitatively evaluating a GAN-like model is challenging. We follow literature and use the inception score (Salimans et al., 2016) to measure the quantity of the generated images. Figure 6 plots inception scores versus training epochs for different models. MacGAN obtains competitive inception scores with the popular DCGAN model. Quantitatively, we get a final inception score of 6.49 for MacGAN, compared to 6.35 for SteinGAN, 6.25 for WGAN-I and 6.58 for DCGAN.

10

Under review as a conference paper at ICLR 2018
airplane automobile
bird cat deer dog frog horse ship truck
!
Figure 5: Generated images for CIFAR-10 (top) and CelebA (middle) datasets with MacGAN (left) and SteinGAN (right). The bottom are images generated by a random walk on the  space for the generator of MacGAN, i.e., t = t-1 + 0.03 × rand([-1, 1]).
7 CONCLUSION
We study the problem of applying CTFs for efficient inference and explicit density estimation in deep generative models, two important tasks in unsupervised machine learning. Compared to discrete-time normalized flows, CTFs are more general and flexible due to the fact that their stationary distributions can be controlled without extra flow parameters. We develop theory on the approximation accuracy when adopting a CTF to approximate a target distribution. We apply CTFs on two classes of deep generative models, a variational autoencoder for efficient inference, and a GAN-like density estimator for explicit density estimation and efficient data generation. Experiments show encouraging results of our framework in both models compared to existing techniques. One interesting direction of future work is to explore more efficient learning algorithms for the proposed CTF-based framework.
REFERENCES
M. Arjovsky and L. Bottou. Towards principled methods for training generative adversarial networks. In ICLR, 2017.
11

Under review as a conference paper at ICLR 2018
M. Arjovsky, S. Chintala, and L. Bottou. Wasserstein GAN. Technical Report arXiv:1701.07875, March 2017.
F. Bolley, I. Gentil, and A. Guillin. Convergence to equilibrium in wasserstein distance for fokker­planck equations. Journal of Functional Analysis, 263(8):2430­2457, 2012.
L. Bottou. Stochastic gradient descent tricks. Technical report, Microsoft Research, Redmond, WA, 2012.
C. Chen, N. Ding, and L. Carin. On the convergence of stochastic gradient MCMC algorithms with high-order integrators. In NIPS, 2015.
Laurent Dinh, Jascha Sohl-Dickstein, and Samy Bengio. Density estimation using real nvp. ICLR, 2017.
A. A. Dorogovtsev and I. I. Nishchenko. An analysis of stochastic flows. Communications on Stochastic Analysis, 8(3):331­342, 2014.
Y. Feng, D. Wang, and Q. Liu. Learning to draw samples with amortized Stein variational gradient descent. In UAI, 2017.
S. J. Gershman and N. D. Goodman. Amortized inference in probabilistic reasoning. In Annual Conference of the Cognitive Science Society, 2014.
C. R. Givens and R. M. Shortt. A class of wasserstein metrics for probability distributions. Michigan Math. J., 31, 1984.
I. Goodfellow, J. Pouget-Abadie, M. Mirza, B. Xu, D. Warde-Farley, S. Ozair, A. Courville, and Y. Bengio. Generative adversarial nets. In NIPS, 2014.
A. Grover, M. Dhar, and S. Ermon. Flow-GAN: Bridging implicit and prescribed learning in generative models. Technical Report arXiv:1705.08868, 2017.
I. Gulrajani, F. Ahmed, M. Arjovsky, V. Dumoulin, and A. Courville. Improved training of Wasserstein GAN. Technical Report arXiv:1704.00028, March 2017.
T. Haarnoja, H. Tang, P. Abbeel, and S. Levine. Reinforcement learning with deep energy-based policies. In ICML, 2017.
G. E. Hinton. Training products of experts by minimizing contrastive divergence. Neural Computation, 14(8):1771­1800, 2002.
F. Huszár. Variational inference using implicit distributions. Technical Report arXiv:1702.08235, 2017.
R. Jordan, D. Kinderlehrer, and F. Otto. The variational formulation of the Fokker-Planck equation. SIAM J. MATH. ANAL., 29(1):1­17, 1998.
D. Kingma, T. P. Salimans, and M. Welling. Improving variational inference with inverse autoregressive flow. In NIPS, 2016.
D. P. Kingma and M. Welling. Auto-encoding variational Bayes. In ICLR, 2014.
Y. Li, R. E. Turner, and Q. Liu. Approximate inference with amortised MCMC. Technical Report arXiv:1702.08343, 2017.
Q. Liu and D. Wang. Stein variational gradient descent: A general purpose Bayesian inference algorithm. In NIPS, 2016.
J. C. Mattingly, A. M. Stuart, and M. V. Tretyakov. Construction of numerical time-average and stationary measures via Poisson equations. SIAM Journal on Numerical Analysis, 48(2):552­577, 2010.
S. Mohamed and B. Lakshminarayanan. Learning in implicit generative models. Technical Report arXiv:1610.03483, 2017.
12

Under review as a conference paper at ICLR 2018
F. Otto. Dynamics of Labyrinthine pattern formation in magnetic fluids: A mean-field theory. Arch. Rational Mech. Anal., pp. 63­103, 1998.
Y. Pu, Z. Gan, R. Henao, C. Li, S. Han, and L. Carin. Stein variational autoencoder. Technical Report arXiv:1704.05155, 2017a.
Y. Pu, Z. Gan, R. Henao, C. Li, S. Han, and L. Carin. Vae learning via stein variational gradient descent. In NIPS, 2017b.
A. Radford, L. Metz, and S. Chintala. Unsupervised representation learning with deep convolutional generative adversarial networks. Technical Report arXiv:1511.06434, January 2016.
R. Ranganath, J. Altosaar, D. Tran, and D. M. Blei. Operator variational inference. In NIPS, 2016. D. J. Rezende and S. Mohamed. Variational inference with normalizing flows. In ICML, 2015. D. J. Rezende, S. Mohamed, and D. Wierstra. Stochastic backpropagation and approximate inference
in deep generative models. In ICML, 2014. H. Risken. The Fokker-Planck equation. Springer-Verlag, New York, 1989. T. Salimans, D. P. Kingma, and M. Welling. Markov chain Monte Carlo and variational inference:
Bridging the gap. In ICML, 2015. T. Salimans, I. Goodfellow, W. Zaremba, V. Cheung, A. Radford, and X. Chen. Improved techniques
for training GANs. Technical Report arXiv:1606.03498, June 2016. Y. W. Teh, A. H. Thiery, and S. J. Vollmer. Consistency and fluctuations for stochastic gradient
Langevin dynamics. JMLR, 17(1):193­225, 2016. J. M. Tomczak and M. Welling. Improving variational auto-encoders using Householder flow.
Technical Report arXiv:1611.09630, November 2016. D. Tran, R. Ranganath, and D. M. Blei. The variational gaussian process. In ICLR, 2016. A. van den Oord, N. Kalchbrenner, and K. Kavukcuoglu. Pixel recurrent neural networks. In ICML,
2016. S. J. Vollmer, K. C. Zygalakis, and Y. W. Teh. (exploration of the (Non-)asymptotic bias and variance
of stochastic gradient Langevin dynamics. JMLR, 1:1­48, 2016. D. Wang and Q. Liu. Learning to draw samples: With application to amortized MLE for generative
adversarial learning. In ICLR workshop, 2017. M. Welling and Y. W. Teh. Bayesian learning via stochastic gradient Langevin dynamics. In ICML,
2011. J. Zhao, M. Mathieu, and Y. LeCun. Energy-based generative adversarial networks. In ICLR, 2017.
13

Under review as a conference paper at ICLR 2018
SUPPLEMENTARY MATERIAL FOR: CONTINUOUS-TIME FLOWS FOR EFFICIENT
INFERENCE AND DENSITY ESTIMATION

A ASSUMPTIONS OF THEOREM 3

First, let us define the infinitesimal generator of the diffusion (2). Formally, the generator L of the diffusion (2) is defined for any compactly supported twice differentiable function f : RL  R, such that,

Lf (Zt)

lim
h0+

E [f (Zt+h)] h

-

f (Zt)

=

F (Zt)

·



+

1 2

G(Zt)G(Zt)T

: T

f (Zt) ,

where a · b aT b, A : B tr(AT B), h  0+ means h approaches zero along the positive real axis.

Given an ergodic diffusion (2) with an invariant measure (Z), the posterior average is defined

as: ¯ (Z)(Z)d Z for some test function (Z) of interest. For a given numerical method

with

generated

samples

(zk )Kk=1 ,

we

use

the

sample

average

^

defined

as

^K

=

1 K

K k=1

 (zk )

to

approximate ¯. We define a functional ~ that solves the following Poisson Equation:

L~(zk) = (zk) - ¯

(11)

We make the following assumptions on ~. Assumption 1. ~ exists, and its up to 4rd-order derivatives, Dk~, are bounded by a function V, i.e., Dk~  CkVpk for k = (0, 1, 2, 3, 4), Ck, pk > 0. Furthermore, the expectation of V on {zk} is bounded: supl EVp(zk) < , and V is smooth such that sups(0,1) Vp (s z + (1 - s) y)  C (Vp (z) + Vp (y)),  z, y, p  max{2pk} for some C > 0.

B PROOFS FOR SECTION 3

Proof of Proposition 1. Consider the flow map T : RL × R  RL. T (x0, ) denotes evolving a flow with initial value x0 for some time . We denote T (x0, ) as T (x0) for simplicity in the following. According to Chen et al. (2015), For a time period , we have

T (x0) = e L(x0) = I + L + O( 2) (x0) ,

where L is the corresponding infinitesimal generator of the flow. Now divide in to n intervals of

length n , the above equation can be written as

T (x0) = e n L · · ·

=

x0

+O(

1 n

)

e n L(x0) =

I + nL + O(

2)

n
(x0)

So

the

Jacobian

can

be

written

as

J

=

I

+O(

1 n

).

Taking

the

limit

of

n



,

we

have

J

=

I,

which

means the CTF is volume preserving.

Sketch Proof of Lemma 2. First note that (5) in Lemma 2 corresponds to eq.13 in Jordan et al. (1998), where F (p) in Jordan et al. (1998) is in the form of KL( p(x, z)) in our setting.
Proposition 4.1 in Jordan et al. (1998) then proves that (5) has a unique solution. Theorem 5.1 in Jordan et al. (1998) then guarantees that the solution of (5) approach the solution of the Fokker-Planck equation in (3), which is T in the limit of h  0.
Since this is true for each k (thus each t in t), we conclude that ~k = hk in the limit of h  0.

14

Under review as a conference paper at ICLR 2018

To prove Theorem 3, we first need a convergence result about convergence to equilibrium in Wasserstein distance for Fokker-Planck equations, which is presented in Bolley et al. (2012). Putting in our setting, we can get the following lemma based on Corollary 2.4 in Bolley et al. (2012).

Lemma 6 (Bolley et al. (2012)). Let T be the solution of the FP equation (3) at time T , p(x, z) be

the joint posterior distribution given x. Assume that T (z)p- 1(x, z)d z <  and there exists a

constant

C

such

that

dW22(T ,p (x,z)) dt



CW22 (T , p(x, z)).

Then

W2 (T , p(x, z))  W2 (0, p(x, z)) e-CT .

(12)

We further need to borrow convergence results from Mattingly et al. (2010); Vollmer et al. (2016);

Chen et al. (2015) to characterize error bounds of a numerical integrator for the diffusion (2).

Specifically, the goal is to evaluate the posterior average of a test function (z), defined as ¯

(z)p(x, z)d z. When using a numerical integrator to solve (2) to get samples {zk}Kk=1, the

sample average ^K

1 K

K k=1

 (zk )

is

used

to

approximate

the

posterior

average.

The

accuracy

is characterized by the mean square error (MSE) defined as: E

^K - ¯

2
. Lemma 7 derives the

bound for the MSE.

Lemma 7 (Vollmer et al. (2016)). Under Assumption 1, and for a 1st-order numerical intergrator, the MSE is bounded, for a constant C independent of h and K, by

E

^K - ¯

2
C

1 hK

+ h2

.

Furthermore, except for the 2nd-order Wasserstein distance defined in Lemma 2, we define the 1st-order Wasserstein distance between two probability measures µ1 and µ2 as

W1 (µ1, µ2)

inf

pP (µ1 ,µ2 )

x - y 2 p(d x, d y) .

(13)

According to the Kantorovich-Rubinstein duality Arjovsky et al. (2017), W1(µ1, µ2) is equivalently represented as

W1 (µ1, µ2) = sup Ezµ1 [f (z)] - Ezµ2 [f (z)] ,
f L1

(14)

where L1 is the space of 1-Lipschitz functions f : RL  R. We have the following relation between W1(µ1, µ2) and W2(µ1, µ2). Lemma 8 (Givens & Shortt (1984)). We have for any two distributions µ1 and µ2 that W1(µ1, µ2)  W2(µ1, µ2).
Now it is ready to prove Theorem 3.

Proof of Theorem 3. The idea is to simply decompose the MSE into two parts, with one part charactering the MSE of the numerical method, the other part charactering the MSE of T and p(x, z), which consequentially can be bounded using Lemma 6 above.
15

Under review as a conference paper at ICLR 2018

Specifically, we have MSE(¯T , T ; ) E

2
(z)(~T - T )(z)d z

=E

1 K

K

(zk) -

k=1

2
(z)T (z)d z

=E

1 K

K

(zk) -

(z)p(x, z)d z -

k=1

(z)T (z)d z -

(=1)E

1 K

K

(zk) -

k=1

2
(z)p(x, z)d z +

(z)T (z)d z -

(2)
E

1 K

K

(zk) -

k=1

2
(z)p(x, z)d z + W12(T , p)

(3)
E

1 K

K

(zk) -

k=1

2
(z)p(x, z)d z + W22(T , p)

(4)
 C1

1 hK

+ h2

+ W22 (0, p(x, z)) e-2CT

=O

1 hK

+ h2

+ e-2ChK

,

2
(z)p(x, z)d z
2
(z)p(x, z)d z

where "(1)" follows by the fact that E

1 K

K k=1

 (zk )

-

(z)p(x, z)d z

= 0 Chen et al.

(2015); "(2)" follows by the definition of W1(µ1, µ2) in (13) and the 1-Lipschitz assumption of the test function ; "(3)" follows by Lemma 8; "(4)" follows by Lemma 6 and Lemma 7.

C CONNECTION TO WGAN

We derive the upper bound of the maximum likelihood estimator, which connects MacGAN to WGAN. Let pr be the data distribution, rewrite our maximum likelihood objective as

max

1 N

N

log

p (xi )

=

max

1 N

N

U (xi; ) - log

i=1 i=1

eU(x;)d x .

The above maximum likelihood estimator can be bounded with Jensen's inequality as:

max

1 N

N

log p(xi)  max Expr [U (x; )] - log

i=1

eU (x;) q(x; )

q

(x;

)d

x

 max Expr [U (x; )] - Exq(x;)

log

eU (x;) q(x; )

= max Expr [U (x; )] - Exq(x;) [U (x; )] - Exq(x;) [log q(x; )] .

(15)

This results in the same objective form as WGAN except that our model does not restrict U (x; ) to be 1-Lipschitz functions and the objective has an extra constant term Exq(x;) [log q(x; )] w.r.t. .
Now we prove Proposition 5.

Proof of Proposition 5. First it is clear that the equality in (15) is achieved if and only if q(x; ) = p(x)  eU(x;) .

16

Under review as a conference paper at ICLR 2018

Table 1: Architecture of generator in MacGAN

Output Size Architecture

100 × 1 256 × 8 × 8 128 × 16 × 16 3 × 32 × 32

100 × 10 Linear, BN, ReLU 512 × 4 × 4 deconv, 256 5 × 5 kernels, ReLU, strike 2, BN 256 × 8 × 8 deconv, 128 5 × 5 kernels, ReLU, strike 2, BN 128 × 16 × 16 deconv, 3 5 × 5 kernels, Tanh, strike 2

From the description in Section 4 and (15), we know that  and  share the same objective function, which is an upper bound of the MLE in (15).
Furthermore, based on the property of continuous-time flows (or formally Theorem 3), we know that q is learned such that q  p in the limit of h  0 (or alternatively, we could achieve this by using a decreasing-step-size sequence in a numerical method, as proved in Chen et al. (2015)). When q = p, the equality in (15) is achieved, leading to the MLE.

D ADDITIONAL EXPERIMENTS

D.1 CALCULATING THE TESTING ELBO FOR MACVAE

We follow the method in Pu et al. (2017a) for calculating the ELBO for a test data x. First, after distilling the CTF into the inference network q, we have that the ELBO can be represented as

log p(x)  Eq [log p(x, z)] - Eq [log q] .

The expectation is approximated with samples {zj}jM=1 with zj = f(x, j), and j  q0() the

standard isotropic normal. Here f represents the deep neural network in the inference network.

Note q(z) is not readily obtained. To evaluate it, we use the density transformation formula:

q(z) = q0()

det



f

(x 

,

)

-1
.

D.2 NETWORK ARCHITECTURE The architecture of the generator of MacGAN is given in Table 1.

D.3 ADDITIONAL RESULTS Additional experimental results are given in Figure 7 ­ 12.

17

Under review as a conference paper at ICLR 2018
Figure 7: Generated images for MNIST datasets with MacGAN (top) and SteinGAN (bottom). 18

Under review as a conference paper at ICLR 2018
Figure 8: Generated images for CelebA datasets with MacGAN. Figure 9: Generated images for CIFAR-10 datasets with MacGAN.
19

Under review as a conference paper at ICLR 2018
Figure 10: Generated images for CelebA datasets with SteinGAN. Figure 11: Generated images for CIFAR-10 datasets with SteinGAN.
20

Under review as a conference paper at ICLR 2018
Figure 12: Generated images with a random walk on the  space for CelebA datasets with MacGAN, t = t-1 + 0.02 × rand([-1, 1]).
21

