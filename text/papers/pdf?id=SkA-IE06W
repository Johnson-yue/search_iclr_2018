Under review as a conference paper at ICLR 2018

WHEN IS A CONVOLUTIONAL FILTER EASY TO LEARN?
Anonymous authors Paper under double-blind review

ABSTRACT
We analyze the convergence of (stochastic) gradient descent algorithm for learning a convolutional filter with Rectified Linear Unit (ReLU) activation function. Our analysis does not rely on any specific form of the input distribution and our proofs only use the definition of ReLU, in contrast with previous works that are restricted to standard Gaussian input. We show that (stochastic) gradient descent with random initialization can learn the convolutional filter in polynomial time and the convergence rate depends on the smoothness of the input distribution and the closeness of patches. To the best of our knowledge, this is the first recovery guarantee of gradient-based algorithms for convolutional filter on non-Gaussian input distributions. Our theory also justifies the two-stage learning rate strategy in deep neural networks. While our focus is theoretical, we also present experiments that justify our theoretical findings.

1 INTRODUCTION
Deep convolutional neural networks (CNN) have achieved the state-of-the-art performance in many applications such as computer vision (Krizhevsky et al., 2012), natural language processing (Dauphin et al., 2016) and reinforcement learning applied in classic games like Go (Silver et al., 2016). Despite the highly non-convex nature of the objective function, simple first-order algorithms like stochastic gradient descent and its variants often train such networks successfully. On the other hand, the success of convolutional neural network remains elusive from an optimization perspective.
When the input distribution is not constrained, existing results are mostly negative, such as hardness of learning a 3-node neural network (Blum & Rivest, 1989) or a non-overlap convolutional filter (Brutzkus & Globerson, 2017). Recently, Shamir (2016) showed learning a simple one-layer fully connected neural network is hard for some specific input distributions.
These negative results suggest that, in order to explain the empirical success of SGD for learning neural networks, stronger assumptions on the input distribution are needed. Recently, a line of research (Tian, 2017; Brutzkus & Globerson, 2017; Li & Yuan, 2017; Soltanolkotabi, 2017; Zhong et al., 2017) assumed the input distribution be standard Gaussian N (0, I) and showed (stochastic) gradient descent is able to recover neural networks with ReLU activation in polynomial time.
One major issue of these analysis is that they rely on specialized analytic properties of the Gaussian distribution (c.f. Section 1.1) and thus cannot be generalized to the non-Gaussian case, in which real-world distributions fall into. For general input distributions, new techniques are needed.
In this paper we consider a simple architecture: a convolution layer, followed by a ReLU activation function, and then average pooling. Formally, we let x  Rd be an input sample, e.g., an image, we generate k patches from x, each with size p: Z  Rp×k where the i-th column is the i-th patch generated by some known function Zi = Zi(x). For a filter with size 2 and stride 1, Zi(x) is the i-th and (i + 1)-th pixels. Since for convolutional filters, we only need to focus on the patches instead of the input, in the following definitions and theorems, we will refer Z as input and let Z as the distribution of Z: ((x) = max(x, 0) is the ReLU activation function)

f (w, Z)

=

1 k

k



w

Zi

.

i=1

1

(1)

Under review as a conference paper at ICLR 2018

(a)
Input

ReLU

(b)
+
Label (Estimate)

(c)

Figure 1: (a) Architecture of the network we are considering. Given input X, we extract its patches {Zi} and send them to a shared weight vector w. The outputs are then sent to ReLU and then summed to yield the final label (and its estimation). (b)-(c) Two conditions we proposed for con-
vergence. We want the data to be (b) highly correlated and (c) concentrated more on the direction aligned with the ground truth vector w.

See Figure 1 (a) for a graphical illustration. Such architectures have been used as the first layer of

many works in computer vision (Lin et al., 2013; Milletari et al., 2016). We address the realizable

case, where training data are generated from (1) with some unknown teacher parameter w under

input distribution Z. Consider the

2 loss

(w, Z)

=

1 2

(f

(w,

Z)

-

f

(w,

Z))2.

We learn by

(stochastic) gradient descent, i.e.,

wt+1 = wt - tg(wt)

(2)

where t is the step size which may change over time and g(wt) is a random function where its expectation equals to the population gradient E [g(w)] = EZZ [ (w, Z)] . The goal of our analysis is to understand the conditions where w  w, if w is optimized under (stochastic) gradient
descent.

In this setup, our main contributions are as follows:

· Learnability of Filters: We show if the input patches are highly correlated (Section 3), i.e.,  (Zi, Zj)   for some small  > 0, then gradient descent and stochastic gradient descent with random initialization recovers the filter in polynomial time.1 Furthermore, strong correlations imply faster convergence. To the best of our knowledge, this is the first recovery guarantee of randomly initialized gradient-based algorithms for learning filters (even for the simplest one-layer one-neuron network) on non-Gaussian input distribution, answering an open problem in (Tian, 2017).
· Distribution-Aware Convergence Rate. We formally establish the connection between the smoothness of the input distribution and the convergence rate for filter weights recovery where the smoothness in our paper is defined as the ratio between the largest and the least eigenvalues of the second moment of the activation region (Section 2). We show that a smoother input distribution leads to faster convergence, and Gaussian distribution is a special case that leads to the tightest bound. This theoretical finding also justifies the twostage learning rate strategy proposed by (He et al., 2016; Szegedy et al., 2017) if the step size is allowed to change over time.

1.1 RELATED WORKS
In recent years, theorists have tried to explain the success of deep learning from different perspectives. From optimization point of view, optimizing neural network is a non-convex optimization problem. Pioneered by Ge et al. (2015), a class of non-convex optimization problems that satisfy strict saddle property can be optimized by perturbed (stochastic) gradient descent in polynomial time (Jin et al., 2017).2 This motivates the research of studying the landscape of neural net-
1Note since in this paper we focus on continuous distribution over Z, our results do not conflict with previous negative results(Blum & Rivest, 1989; Brutzkus & Globerson, 2017) whose constructions rely on discrete distributions.
2Gradient descent is not guaranteed to converge to a local minima in polynomial time (Du et al., 2017; Lee et al., 2016).

2

Under review as a conference paper at ICLR 2018
works (Soltanolkotabi et al., 2017; Kawaguchi, 2016; Choromanska et al., 2015; Hardt & Ma, 2016; Haeffele & Vidal, 2015; Mei et al., 2016; Freeman & Bruna, 2016; Safran & Shamir, 2016; Zhou & Feng, 2017; Nguyen & Hein, 2017) However, these results cannot be directly applied to analyzing the convergence of gradient-based methods for ReLU activated neural networks.
From learning theory point of view, it is well known that training a neural network is hard in the worst cases (Blum & Rivest, 1989; Livni et al., 2014; S´ima, 2002; Shalev-Shwartz et al., 2017a;b) and recently, Shamir (2016) showed either "niceness" of the target function or of the input distribution alone is sufficient for optimization algorithms used in practice to succeed. With some additional assumptions, many works tried to design algorithms that provably learn a neural network with polynomial time and sample complexity (Goel et al., 2016; Zhang et al., 2016; 2015; Sedghi & Anandkumar, 2014; Janzamin et al., 2015; Gautier et al., 2016; Goel & Klivans, 2017). However, these algorithms are tailored for certain architecture and cannot explain why (stochastic) gradient based optimization algorithms work well in practice.
Focusing on gradient-based algorithms, a line of research analyzed the behavior of (stochastic) gradient descent for Gaussian input distribution. Tian (2017) showed population gradient descent is able to find the true weight vector with random initialization for one-layer one-neuron model. Brutzkus & Globerson (2017) showed population gradient descent recovers the true weights of a convolution filter with non-overlapping input in polynomial time. Li & Yuan (2017) showed SGD can recover the true weights of a one-layer ResNet model with ReLU activation under the assumption that the spectral norm of the true weights is bounded by a small constant. All the methods use explicit formulas for Gaussian input, which enable them to apply trigonometric inequalities to derive the convergence. With the same Gaussian assumption, Soltanolkotabi (2017) shows that the true weights can be exactly recovered by projected gradient descent with enough samples in linear time, if the number of inputs is less than the dimension of the weights.
Other approaches combine tensor approaches with assumptions of input distribution. Zhong et al. (2017) proved that with sufficiently good initialization, which can be implemented by tensor method, gradient descent can find the true weights of a 3-layer fully connected neural network. However, their approach works with known input distributions. Soltanolkotabi (2017) used Gaussian width (c.f. Definition 2.2 of (Soltanolkotabi, 2017)) for concentrations and his approach cannot be directly extended to learning a convolutional filter.
In this paper, we adopt a different approach that only relies on the definition of ReLU. We show as long as the input distribution satisfies weak smoothness assumptions, we are able to find the true weights by SGD in polynomial time. Using our conclusions, we can justify the effectiveness of large amounts of data (which may eliminate saddle points), two-stage and adaptive learning rates used by He et al. (2016); Szegedy et al. (2017), etc.
1.2 ORGANIZATION
This paper is organized as follows. In Section 2, we analyze the simplest one-layer one-neuron model where we state our key observation and establish the connection between smoothness and convergence rate. In Section 3, we discuss the performance of (stochastic) gradient descent for learning a convolutional filter. We provide empirical illustrations in Section 4 and conclude in Section 5. We place most of our detailed proofs in the Appendix.
1.3 NOTATIONS
Let · 2 denote the Euclidean norm of a finite-dimensional vector. For a matrix A, we use max (A) to denote its largest singular value and min (A) its smallest singular value. Note if A is a positive semidefinite matrix, max (A) and min (A) represent the largest and smallest eigenvalues of A, respectively. Let O(·) and (·) denote the standard Big-O and Big-Theta notations that hide absolute constants. We assume the gradient function is uniformly bounded, i.e., There exists B > 0 such that g(w) 2  B. This condition is satisfied as long as patches, w and noise are all bounded.
3

Under review as a conference paper at ICLR 2018

S(w, w)
(a)
S( w, w)

S(w, w)

(b) L( )
()

L w ( )

S( w, w)
Figure 2: (a) The four regions considered in our analysis. (b) Illustration of L () , () and L-w () defined in Definition 2.1 and Assumption 2.1.

2 WARM UP: ANALYZING ONE-LAYER ONE-NEURON MODEL
Before diving into the convolutional filter, we first analyze the special case for k = 1, which is equivalent to the one-layer one-neuron architecture. The analysis in this simple case will give us insights for the fully general case. For the ease of presentation, we define following two events and corresponding second moments
S(w, w) = Z : w Z  0, w Z  0 , S(w, -w) = Z : w Z  0, w Z  0 , (3) Aw,w = E ZZ I {S(w, w)} , Aw,-w = E ZZ I {S(w, -w)} .
where I {·} is the indicator function. Intuitively, S(w, w) is the joint activation region of w and w and S(w, -w) is the joint activation region of w and -w. See Figure 2 (a) for the graphical illustration. With some simple algebra we can derive the population gradient.
E [ (w, Z)] = Aw,w (w - w) + Aw,-w w.
One key observation is we can write the inner product w (w) , w - w as the sum of two non-negative terms (c.f. Lemma A.1). This observation directly leads to the following Theorem 2.1.
Theorem 2.1. Suppose for any w1, w2 with  (w1, w2) < , E ZZ I {S(w, w)} 0 and the initialization w0 satisfies (w0) < (0) then gradient descent algorithm recovers w.
The first assumption is about the non-degeneracy of input distribution. For  (w1, w2) < , one case that the assumption fails is that the input distribution is supported on a low-dimensional space, or degenerated. The second assumption on the initialization is to ensure that gradient descent does not converge to w = 0, at which the gradient is undefined. This is a general convergence theorem that holds for a wide class of input distribution and initialization points. In particular, it includes Theorem 6 of (Tian, 2017) as a special case. If the input distribution is degenerate, i.e., there are holes in the input space, the gradient descent may stuck around saddle points and we believe more data are needed to facilitate the optimization procedure This is also consistent with empirical evidence in which more data are helpful for optimization.

2.1 CONVERGENCE RATE OF ONE-LAYER ONE-NEURON MODEL

In the previous section we showed if the distribution is regular and the weights are initialized appropriately, gradient descent recovers the true weights when it converges. In practice we also want to know how many iterations are needed. To characterize the convergence rate, we need some quantitative assumptions. We note that different set of assumptions will lead to a different rate and ours is only one possible choice. In this paper we use the following quantities.
Definition 2.1 (The Largest/Smallest eigenvalue Values of the Second Moment on Intersection of two Half Spaces). For   [0, ], define

()

=

min
w:w,w =

min

(Aw,w )

,

L()

=

max
w:w,w =

max

(Aw,w )

,

4

Under review as a conference paper at ICLR 2018

These two conditions quantitatively characterize the angular smoothness of the input distribution. For a given angle , if the difference between () and L() is large then there is one direction has
large probability mass and one direction has small probability mass, meaning the input distribution is not smooth. On the other hand, if () and L() are close, then all directions have similar
probability mass, which means the input distribution is smooth. The smoothest input distributions are rotationally invariant distributions (e.g. standard Gaussian) which have () = L(). For analogy, we can think of L() as Lipschitz constant of the gradient and () as the strong convexity
parameter in the optimization literature but here we also allow they change with the angle. Also observe that when  = , () = L() = 0 because the intersection has measure 0 and both () and L() are monotonically decreasing.

Our next assumption is on the growth of Aw,-w . Note that when  (w, w) = 0, then Aw,-w = 0 because the intersection between w and -w has 0 measure. Also, Aw,-w grows as the angle between w and w becomes larger.
In the following, we assume the operator norm of Aw,-w increases smoothly with respect to the angle. The intuition is that as long as input distribution bounded probability density with respect to the angle, the operator norm of Aw,-w is bounded. We show in Theorem A.1 that  = 1 for rotational invariant distribution and in Theorem A.2 that  = p for standard Gaussian distribution.
Assumption 2.1. We assume there exists  > 0 that for 0    /2, L-w () maxw,(w,w) max (Aw,-w )  .

Now we are ready to state the convergence rate.

Theorem 2.2. Suppose the initialization w0 satisfies w0 - w 2 < w 2. Denote t =

arcsin

wt-w 2 w 2

then if step size is set as 0



t



min0t

() 2(L()+4)2

,

we have for

t = 1, 2, . . .

wt+1 - w

2 2



1

-

t (t) 2

wt - w

2 2

.

Note both () and L() increases as  decreases so we can choose a constant step size

t = 

 (0 ) (L(0)+)2

.

This theorem implies that we can find the

-close solution of w in

O

(L(0)+)2  2 (0 )

log

1

iterations. It also suggests a direct relation between the smoothness of the

distribution and the convergence rate. For smooth distribution where () and L() are close and 

is

small

then

(L(0)+)2  2 (0 )

is

relatively

small

and

we

need

fewer

iterations.

On

the

other

hand,

if

L()

or  is much larger than (), we will need more iterations. We verify this intuition in Section 4.

If we are able to choose the step sizes adaptively t

=



 (t ) (L(t )+ )2

, like using meth-

ods proposed by Lin & Xiao (2014), we may improve the computational complexity to

O

max0

(L()+)2  2 ()

log

1

. This justifies the use of two-stage learning rate strategy proposed

by He et al. (2016); Szegedy et al. (2017) where at the beginning we need to choose learning to be

small

because

 (0 ) 2(L(0 )+2 )2

is

small

and

later

we

can

choose

a

large

learning

rate

because

as

the

angle

between

wt

and

w

becomes

smaller,

 (t ) 2(L(t )+2 )2

becomes

bigger.

The theorem requires the initialization satisfying w0 - w 2 < w 2, which can be achieved by random initialization with constant success probability. See Section 3.2 for a detailed discussion.

3 MAIN RESULTS FOR LEARNING A CONVOLUTIONAL FILTER
In this section we generalize ideas from the previous section to analyze the convolutional filter. First, for given w and w we define four events that divide the input space of each patch Zi. Each event corresponds to a different activation region induced by w and w, similar to (3).
S(w, w)i = Zi : w Zi  0, w Zi  0 , S(w, -w)i = Zi : w Zi  0, w Zi  0 , S(-w, -w)i = Zi : w Zi  0, w Zi  0 , S(-w, w)i = Zi : w Zi  0, w Zi  0 .

5

Under review as a conference paper at ICLR 2018

Please check Figure 2 (a) again for illustration. For the ease of presentation we also define the average over all patches in each region

ZS (w,w )

=

1 k

k

ZiI {S(w, w)i} , ZS(w,-w) =

1 k

k

ZiI {S(w, -w)i} ,

i=1 i=1

ZS (-w,w )

=

1 k

k

ZiI {S(-w, w)i} .

i=1

Next, we generalize the smoothness conditions analogue to Definition 2.1 and Assumption 2.1. Here the smoothness is defined over the average of patches.

Assumption 3.1. For   [0, ], define

() = min min
w:(w,w )=

E

ZS (w,w ) ZS (w,w )

,

L() = max max
w:(w,w )=

E ZS(w,w)ZS(w,w)

.

(4)

We assume for all 0    /2, maxw:(w,w)= max E ZS(w,-w)ZS(w,-w)  > 0.

for some

The main difference between the simple one-layer one-neuron network and the convolution filter is two patches may appear in different regions. For a given sample, there may exists patch Zi and Zj such that Zi  S(w, w)i and Zj  S(w, -w)j and their interaction plays an important role in the convergence of (stochastic) gradient descent. Here we assume the second moment of this interaction, i.e., cross-covariance, also grows smoothly with respect to the angle.
Assumption 3.2. We assume there exists Lcross > 0 such that

max max
w:(w,w )

E ZS(w,w)ZS(w,-w)

+max E ZS(w,w)ZS(-w,w)

+max E ZS(w,-w)ZS(-w,w)  Lcross.

First note if  = 0, then ZS(w,-w) and ZS(-w,w) has measure 0 and this assumption models the growth of cross-covariance. Next note this Lcross represents the closeness of patches. If Zi and Zj are very similar, then the joint probability density of Zi  S(w, w)i and Zj  S(w, -w)j is small which implies Lcross is small. In the extreme setting, Z1 = . . . = Zk, we have Lcross = 0 because in this case the events {Zi  S(w, w)i}  {Zj  S(w, -w)j}, {Zi  S(w, w)i} 
{Zj  S(-w, w)j} and {Zi  S(w, -w)i}  {Zj  S(-w, w)j} all have measure 0.

Now we are ready to present our result on learning a convolutional filter by gradient descent.

Theorem 3.1. If the initialization satisfies w0 - w 2 < w 2 and denote t

arcsin

wt-w 2 w 2

which satisfies (0) > 6Lcross.

Then if we choose t

min0t

,()-6Lcross
2(L()+10Lcross +4 )2

we

have

for

t

=

1, 2, . . .

and

t

arcsin

wt-w 2 w 2

wt+1 - w

2 2



1

-

((t)

- 2

6Lcross)

wt - w

2 2

= 

Our theorem suggests if the initialization satisfies (0) > 6Lcross, we obtain linear conver-

gence rate. In Section 3.1, we give a concrete example showing closeness of patches implies

large () and small Lcross. Similar to Theorem 2.2, if the step size is chosen so that t =

 (0 )-6Lcross
 ( ) , in OLS(w,w)(0)+10Lcross+4 2

log (0 )-6Lcross

2

LS (w,w ) (0)+10Lcross +4

1

iterations, we can

find the -close solution of w and the proof is also similar to that of Theorem 3.1.

In practice,we never get a true population gradient but only stochastic gradient g(w) (c.f. Equation (2)). The following theorem shows SGD also recovers the underlying filter.

6

Under review as a conference paper at ICLR 2018

Theorem 3.2. Let  = argmax()  6Lcross. Denote r0 = w0 - w 2, 0 =

arcsin

r0 w 2

and 1

=



+0 2

.

For

sufficiently small, if t = 

,2 ( (1 )-6Lcross )2

w

2 2

B2

then we have in T = O

logB2

2 ( (1 )-6Lcross )2

w

2 2

least 1 -  we have wT - w  w 2 .

w0 -w  w 2

iterations, with probability at

Unlike the vanilla gradient descent case, here the convergence rate depends on 1 instead of 0.
This is because of the randomness in SGD and we need a more robust initialization. We choose
1 to be the average of 0 and  for the ease of presentation. As will be apparent in the proof we only require 0 not very close to . The proof relies on constructing a martingale and use Azuma-Hoeffding inequality and this idea has been previously used by Ge et al. (2015).

3.1 WHAT DISTRIBUTION IS EASY FOR SGD TO LEARN A CONVOLUTIONAL FILTER?

Different from One-Layer One-Neuron model, here we also requires the Lipschitz constant for closeness Lcross to be relatively small and (0) to be relatively large. A natural question is: What input distributions satisfy this condition?

Here we give an example. We show if (1) patches are close to each other (2) the input distribution has small probability mass around the decision boundary then the assumption in Theorem 3.1 is satisfied. See Figure 1 (b)-(c) for the graphical illustrations.

Theorem 3.3. i,  (Zi, Zavg)

Denote Zavg  . Further

a=ssk1umeikt=h1erZeie. xSiustpspLose a0llspuacthchtheasthfaovreaunnyit norma3nadnfdorfoarllaZllifor

all

P  (Zi, w) 

 2

-

,

 2

+



 µ,

P

 (Zi, w)  -

 2

-

,

-

 2

+



 µ,

then we have

 (0)  avg (0) - 4 (1 - cos ) and Lcross  3µ.

where avg(0) = min E ZZ I w0 Z  0, w Z  0 , analogue to Definition 2.1.

Several comments are in sequel. We view  as a quantitative measure of the closeness between different patches, i.e.,  small means they are similar. This lower bound is monotonically decreasing
as a function of  and note when  = 0, min E ZS(w,w)ZS(w,w) = avg(0) which recovers Definition 2.1.

For the upper bond on Lcross, µ represents the upper bound of the probability density around the

decision boundary. For example if P  (Zi, w) 

 2

- ,

 2

+

 2, then for  in a small

neighborhood around /2, say radius

, we have P  (Zi, w) 

 2

- ,

 2

+

. This as-

sumption is usually satisfied in real world examples like images because the image patches are not

usually close to the decision boundary. For example, in computer vision, the local image patches of-

ten form clusters and is not evenly distributed over the appearance space. Therefore, if we use linear

classifier to separate their cluster centers from the rest of the clusters, near the decision boundary

the probability mass should be very low.

3.2 THE POWER OF RANDOM INITIALIZATION

For one-layer one-neuron model, we need initialization w0 - w 2 < w 2 and for the convolution filter, we need a stronger initialization w0 - w 2 < w 2 cos (). The following theorem shows with uniformly random initialization we have constant probability to obtain a good initialization. Note with this theorem at hand, we can boost the success probability to arbitrary close to 1 by random restarts. The proof is similar to (Tian, 2017).

Theorem 3.4. If we uniformly sample w0



1 2p

,

then

with

probability

at

least

1 2

from -

a p-dimensional ball with

p 2

,

we

have

w0 - w

2

radius 1

 -

w so that 2 w .

3This is condition can be relaxed to the norm and the angle of each patch are independent and the norm of each pair is independent of others.

7

Under review as a conference paper at ICLR 2018

log(||w-w*||2) log(||w-w*||2)

0
-1
-2
-3
-4 =10 =5
-5 =1 =0.5
-6 0 2000 4000 6000 8000 10000 Epochs

0 -0.2 -0.4 -0.6 -0.8
-1 -1.2 -1.4
0

2=10 2=2 2=1 2=0.1
200

400 600 Epochs

800 1000

Figure 3: Convergence rates of SGD (a) with different closeness of patches where larger 2 is smoother; (b) with different smoothness where larger  is smoother; (c) for a learning a random filter with different initialization on MNIST data; (d) for a learning a Gabor filter with different
initialization on MNIST data.

To apply this general initialization theorem to our convolution filter case, we can choose  = cos . Therefore, with some simple algebra we have the following corollary.

Corollary 3.1.

Suppose cos () <

1 8p

,

then

if

w0

is

uniformly

sampled

from

a

ball

with

center

0 and radius

w

cos (),

we

have

with

probability

at

least

1 2

-

cos ()

p 2

>

1 4

.

The assumption of this corollary is satisfied if the patches are close to each other as discussed in the previous section.

4 EXPERIMENTS

In this section we use simulations to verify our theoretical findings. We first test how the smoothness

affect the convergence rate in one-layer one-neuron model described in Section 2 To construct input

distribution with different L(), () and  (c.f. Definition 2.1 and Assumption 2.1), we fix the

patch to have unit norm and use a mixture of truncated Gaussian distribution to model on the angle

around w and around the -w Specifically, the probability density of Z, w is sampled from

1 2

N

(0,

)I[-/2,/2]

+

1 2

N

(-,

)I[-/2,/2].

Note

by

definitions

of

L()

and

()

if





0

the

probability mass is centered around w, so the distribution is very spiky and L()/() and  will

be large. On the other hand, if   , then input distribution is close to the rotation invariant

distribution and L()/() and  will be small. Figure 3a verifies our prediction where we fix the

initialization and step size.

Next we test how the closeness of patches affect the convergence rate in the convolution setting. We
first generate a single patch Z using the above model with  = 1, then generate each unit norm
Zi whose angle with Z, Zi, Z is sampled from Zi, Z  N (0, 2)I[-,). Figure 3b shows as variance between patches becomes smaller, we obtain faster convergence rate, which coincides with Theorem 3.1.

We also test whether SGD can learn a filter on real world data. Here we choose MNIST data and generate labels using two filters. One is random filter where each entry is sampled from a standard Gaussian distribution (Figure 4a) and the other is a Gabor filter (Figure 4b). Figure 3a and Figure 3c show convergence rates of SGD with different initializations. Here, better initializations give faster rates, which coincides our theory. Note that here we report the relative loss, logarithm of squared error divided by the square of mean of data points instead of the difference between learned filter and true filter because we found SGD often cannot converge to the exact filter but rather a filter with near zero loss. We believe this is because the data are approximately lying in a low dimensional manifold in which the learned filter and the true filter are equivalent. To justify this conjecture, we try to interpolate the learned filter and the true filter linearly and the result filter has similar low loss (c.f. Figure 5). Lastly, we visualize the true filters and the learned filters in Figure 4 and we can see that the they have similar patterns.

5 CONCLUSIONS AND FUTURE WORKS
In this paper we provide the first recovery guarantee of (stochastic) gradient descent algorithm with random initialization for learning a convolution filter when the input distribution is not Gaussian.

8

Under review as a conference paper at ICLR 2018

(a) Random generated target filters.

(b) Gabor filters.

Figure 4: Visualization of true and learned filters. For each pair, the left one is the underlying truth and the right is the filter learned by SGD.

Our analyses only used the definition of ReLU and some mild structural assumptions on the input distribution. Here we list some future directions.
One possibility is to extend our result to deeper and wider architectures. Even for two-layer fullyconnected network, the convergence of (stochastic) gradient descent with random initialization is not known. Existing results either requires sufficiently good initialization (Zhong et al., 2017) or relies on special architecture (Li & Yuan, 2017). However, we believe the insights from this paper is helpful to understand the behaviors of gradient-based algorithms in these settings.
Another direction is to consider the agnostic setting, where the label is not equal to the output of a neural network. This will lead to different dynamics of (stochastic) gradient descent and we may need to analyze the robustness of the optimization procedures. This problem is also related to the expressiveness of the neural network (Raghu et al., 2016) where if the underlying function is not equal bot is close to a neural network. We believe our analysis can be extend to this setting.
REFERENCES
Avrim Blum and Ronald L Rivest. Training a 3-node neural network is np-complete. In Advances in neural information processing systems, pp. 494­501, 1989.
Alon Brutzkus and Amir Globerson. Globally optimal gradient descent for a convnet with gaussian inputs. arXiv preprint arXiv:1702.07966, 2017.
Anna Choromanska, Mikael Henaff, Michael Mathieu, Ge´rard Ben Arous, and Yann LeCun. The loss surfaces of multilayer networks. In Artificial Intelligence and Statistics, pp. 192­204, 2015.
Yann N Dauphin, Angela Fan, Michael Auli, and David Grangier. Language modeling with gated convolutional networks. arXiv preprint arXiv:1612.08083, 2016.
Simon S Du, Chi Jin, Jason D Lee, Michael I Jordan, Barnabas Poczos, and Aarti Singh. Gradient descent can take exponential time to escape saddle points. arXiv preprint arXiv:1705.10412, 2017.
C Daniel Freeman and Joan Bruna. Topology and geometry of half-rectified network optimization. arXiv preprint arXiv:1611.01540, 2016.
Antoine Gautier, Quynh N Nguyen, and Matthias Hein. Globally optimal training of generalized polynomial neural networks with nonlinear spectral methods. In Advances in Neural Information Processing Systems, pp. 1687­1695, 2016.
Rong Ge, Furong Huang, Chi Jin, and Yang Yuan. Escaping from saddle pointsonline stochastic gradient for tensor decomposition. In Proceedings of The 28th Conference on Learning Theory, pp. 797­842, 2015.
Surbhi Goel and Adam Klivans. Learning depth-three neural networks in polynomial time. arXiv preprint arXiv:1709.06010, 2017.
9

Under review as a conference paper at ICLR 2018
Surbhi Goel, Varun Kanade, Adam Klivans, and Justin Thaler. Reliably learning the relu in polynomial time. arXiv preprint arXiv:1611.10258, 2016.
Benjamin D Haeffele and Rene´ Vidal. Global optimality in tensor factorization, deep learning, and beyond. arXiv preprint arXiv:1506.07540, 2015.
Moritz Hardt and Tengyu Ma. Identity matters in deep learning. arXiv preprint arXiv:1611.04231, 2016.
Kaiming He, Xiangyu Zhang, Shaoqing Ren, and Jian Sun. Deep residual learning for image recognition. In Proceedings of the IEEE conference on computer vision and pattern recognition, pp. 770­778, 2016.
Majid Janzamin, Hanie Sedghi, and Anima Anandkumar. Beating the perils of non-convexity: Guaranteed training of neural networks using tensor methods. arXiv preprint arXiv:1506.08473, 2015.
Chi Jin, Rong Ge, Praneeth Netrapalli, Sham M Kakade, and Michael I Jordan. How to escape saddle points efficiently. arXiv preprint arXiv:1703.00887, 2017.
Kenji Kawaguchi. Deep learning without poor local minima. In Advances in Neural Information Processing Systems, pp. 586­594, 2016.
Alex Krizhevsky, Ilya Sutskever, and Geoffrey E Hinton. Imagenet classification with deep convolutional neural networks. In Advances in neural information processing systems, pp. 1097­1105, 2012.
Jason D Lee, Max Simchowitz, Michael I Jordan, and Benjamin Recht. Gradient descent only converges to minimizers. In Conference on Learning Theory, pp. 1246­1257, 2016.
Yuanzhi Li and Yang Yuan. Convergence analysis of two-layer neural networks with relu activation. arXiv preprint arXiv:1705.09886, 2017.
Min Lin, Qiang Chen, and Shuicheng Yan. Network in network. arXiv preprint arXiv:1312.4400, 2013.
Qihang Lin and Lin Xiao. An adaptive accelerated proximal gradient method and its homotopy continuation for sparse optimization. In International Conference on Machine Learning, pp. 73­ 81, 2014.
Roi Livni, Shai Shalev-Shwartz, and Ohad Shamir. On the computational efficiency of training neural networks. In Advances in Neural Information Processing Systems, pp. 855­863, 2014.
Song Mei, Yu Bai, and Andrea Montanari. The landscape of empirical risk for non-convex losses. arXiv preprint arXiv:1607.06534, 2016.
Fausto Milletari, Nassir Navab, and Seyed-Ahmad Ahmadi. V-net: Fully convolutional neural networks for volumetric medical image segmentation. In 3D Vision (3DV), 2016 Fourth International Conference on, pp. 565­571. IEEE, 2016.
Quynh Nguyen and Matthias Hein. The loss surface of deep and wide neural networks. arXiv preprint arXiv:1704.08045, 2017.
Maithra Raghu, Ben Poole, Jon Kleinberg, Surya Ganguli, and Jascha Sohl-Dickstein. On the expressive power of deep neural networks. arXiv preprint arXiv:1606.05336, 2016.
Itay Safran and Ohad Shamir. On the quality of the initial basin in overspecified neural networks. In International Conference on Machine Learning, pp. 774­782, 2016.
Hanie Sedghi and Anima Anandkumar. Provable methods for training neural networks with sparse connectivity. arXiv preprint arXiv:1412.2693, 2014.
Shai Shalev-Shwartz, Ohad Shamir, and Shaked Shammah. Failures of gradient-based deep learning. In International Conference on Machine Learning, pp. 3067­3075, 2017a.
10

Under review as a conference paper at ICLR 2018
Shai Shalev-Shwartz, Ohad Shamir, and Shaked Shammah. Weight sharing is crucial to succesful optimization. arXiv preprint arXiv:1706.00687, 2017b.
Ohad Shamir. Distribution-specific hardness of learning neural networks. arXiv preprint arXiv:1609.01037, 2016.
David Silver, Aja Huang, Chris J Maddison, Arthur Guez, Laurent Sifre, George Van Den Driessche, Julian Schrittwieser, Ioannis Antonoglou, Veda Panneershelvam, Marc Lanctot, et al. Mastering the game of go with deep neural networks and tree search. Nature, 529(7587):484­489, 2016.
Jir´i S´ima. Training a single sigmoidal neuron is hard. Neural Computation, 14(11):2709­2728, 2002.
Mahdi Soltanolkotabi. Learning relus via gradient descent. arXiv preprint arXiv:1705.04591, 2017. Mahdi Soltanolkotabi, Adel Javanmard, and Jason D Lee. Theoretical insights into the optimiza-
tion landscape of over-parameterized shallow neural networks. arXiv preprint arXiv:1707.04926, 2017. Christian Szegedy, Sergey Ioffe, Vincent Vanhoucke, and Alexander A Alemi. Inception-v4, inception-resnet and the impact of residual connections on learning. In AAAI, pp. 4278­4284, 2017. Yuandong Tian. An analytical formula of population gradient for two-layered relu network and its applications in convergence and critical point analysis. arXiv preprint arXiv:1703.00560, 2017. Yuchen Zhang, Jason D Lee, Martin J Wainwright, and Michael I Jordan. Learning halfspaces and neural networks with random initialization. arXiv preprint arXiv:1511.07948, 2015. Yuchen Zhang, Jason D Lee, and Michael I Jordan. l1-regularized neural networks are improperly learnable in polynomial time. In International Conference on Machine Learning, pp. 993­1001, 2016. Kai Zhong, Zhao Song, Prateek Jain, Peter L Bartlett, and Inderjit S Dhillon. Recovery guarantees for one-hidden-layer neural networks. arXiv preprint arXiv:1706.03175, 2017. Pan Zhou and Jiashi Feng. The landscape of deep learning algorithms. arXiv preprint arXiv:1705.07038, 2017.
11

Under review as a conference paper at ICLR 2018

A PROOFS AND ADDITIONAL THEOREMS

A.1 PROOFS OF THE THEOREM IN SECTION 2
Lemma A.1. w (w) , w - w = (w - w) Aw,w (w - w) + (w - w) Aw,-w w.
and both terms are non-negative.

(5)

Proof. Since Aw,w 0 and Aw,-w 0 (positive-semidefinite), both the first term and one part of the second term w Aw,-w w are non-negative. The other part of the second term is
-w Aw,-w w = -E w Z w Z I w Z  0, w Z  0  0.

Proof of Theorem 2.1. The assumption on the input distribution ensures when  (w, w) = , Aw,w 0 and when  (w, w) = 0, Aw,-w 0. Now when gradient descent converges we have w (w) = 0. We have the following theorem. By assumption, since (w) < (0) and gradient descent only decreases function value, we will not converge to w = 0. Note that at any
critical points, w (w) , w - w = 0, from Lemma A.1, we have:

(w - w) Aw,w (w - w) = 0 (w - w) Aw,-w w = 0.
Suppose we are converging to a critical point w = w. There are two cases:

(6) (7)

· If  (w, w) = , then we have(w - w) Aw,w (w - w) > 0, which contradicts with Eqn. 6.

· If  (w, w) = , without loss of generality, let w = -w for some  > 0.

By the assumption we know Aw,-w

0. Now the second equation becomes

(w - w) Aw,-w w = (1 + )wAw,-w w > 0, which contradicts with Eqn. 7.

Therefore we have w = w.

Proof of Theorem 2.2. Our proof relies on the following simple but crucial observation: if w - w 2 < w 2, then

 (w, w)  arcsin

w - w 2 w 2

.

We denote  (wt, w) = t and by the observation we have t  t. Recall the gradient descent dynamics,

wt+1 = wt - wt (wt) = wt -  E ZZ I wt Z  0, w Z  0 (wt - w) - E w Z  0, w Z  0 wt .

Consider the squared distance to the optimal weight

wt+1 - w

2 2

=

wt - w

2 2

-  (wt - w) E ZZ I wt Z  0, w Z  0 (wt - w) - E w Z  0, w Z  0 wt

+ 2 E ZZ I wt Z  0, w Z  0

(wt - w) - E

w

Z  0, w Z  0

wt

2 2

.

By our analysis in the previous section, the second term is smaller than

- (wt - w) E ZZ I wt Z  0, w Z  0

(wt - w)  -(t)

wt - w

2 2

12

Under review as a conference paper at ICLR 2018

where we have used our assumption on the angle. For the third term, we expand it as

E ZZ I wt Z  0, w Z  0 = E ZZ I wt Z  0, w Z  0

(wt - w) - E

w

Z  0, w Z  0

wt

2 2

(wt - w)

2 2

- 2 E ZZ I wt Z  0, w Z  0 (wt - w) E w Z  0, w Z  0 wt

+

E

w

Z  0, w Z  0 wt

2 2

L2(t)

wt - w

2 2

+

2L(t)

wt - w

2 · 2

wt - w w 2

+

2

wt - w w 2

2

2

wt

2 2

L2(t)

wt - w

2 2

+

2L(t)

wt - w

· 2

wt - w w 2

· 2 w 2 +

2

wt - w 2 w 2

2

·4

w

2 2

 L2(t) + 8L(t) + 162

w - w

2 2

.

Therefore, in summary,

wt+1 - w

2 2



1 - (t) + 2 (L(t) + 4)2



1

-

(t) 2

wt - w

2 2



1

-

(t) 2

wt - w

2 2

wt - w

2 2

where the first inequality is by our assumption of the step size and second is because t  t and (·) is monotonically decreasing.

Theorem A.1 (Rotational Invariant Distribution). For any unit norm rotational invariant input distribution, we have  = 1.

Proof of Theorem A.1. Without loss of generality, we only need to focus on the plane spanned by w and w and suppose w = (1, 0) . Then

E ZZ I {S(w, -w)} =

-/2+ -/2

cos  sin 

(cos

, sin )d

=

1 2

 - sin  cos  - sin2 

- sin2   + sin  cos 

.

It has two eigenvalues

1()

=



+ sin  2

and

2()

=



- sin 2



.

Therefore,

maxw,(w,w) max (Aw,-w )

=

+sin  2





for

0







.

Theorem A.2. If Z  N (0, I), then   p

Proof. Note in previous theorem we can integrate angle and radius separately then multiply them

together. For Gaussian distribution, we have E

Z

2 2

 p. The result follows.

A.2 PROOFS OF THEOREMS IN SECTION 3

Proof of Theorem 3.1. The proof is very similar to Theorem 2.2. Notation-wise, for two events
S1, S2 we use S1S2 as a shorthand for S1  S2 and S1 + S2 as a shorthand for S1  S2. Denote t =  (wt, w) . First note with some routine algebra, we can write the gradient as

wt (wt)


(d,d)

=E 

ZiZj I

(i,j)=(1,1)

S(w, w)iS(w, w)j

  (w - w)

13

Under review as a conference paper at ICLR 2018

 (d,d)

+E

ZiZj I

(i,j)=(1,1)

 (d,d)

+E

ZiZj I

(i,j)=(1,1)

 (d,d)

-E

ZiZj I

(i,j)=(1,1)

 S(w, w)iS(w, -w)j + S(w, -w)iS(w, w)j  w
 S(w, -w)iS(w, -w)j  w
S(w, w)iS(-w, w)j + S(w, -w)iS(w, w)j + S(w, -w)iS(-w, w)j

  w

We first examine the inner product between the gradient and w - w.

wt (w), w - w  (d,d)



= (w - w) E 

ZiZjI S(w, w)iS(w, w)j  (w - w)

(i,j)=(1,1)

 (d,d)



+ (w - w) E 

ZiZjI S(w, w)iS(w, -w)j + S(w, -w)iS(w, w)j + S(w, -w)iS(w, -w)j  w

(i,j)=(1,1)

 (d,d)



- (w - w) E 

ZiZjI S(w, w)iS(-w, w)j + S(w, -w)iS(w, w)j + S(w, -w)iS(-w, w)j  w

(i,j)=(1,1)

 (d,d)



 (w - w) E 

ZiZjI S(w, w)iS(w, w)j  (w - w)

(i,j)=(1,1)

 (d,d)



+ (w - w) E 

ZiZjI S(w, w)iS(w, -w)j  w

(i,j)=(1,1)

 (d,d)



- (w - w) E 

ZiZjI S(w, w)iS(-w, w)j + S(w, -w)iS(w, w)j + S(w, -w)iS(-w, w)j  w

(i,j)=(1,1)

 (t)

w - w

2 2

- w - w 2 w 2

 (d,d) E  ZiZjI
(i,j)=(1,1)

  (d,d)

S(w, w)iS(w, -w)j



op


- w - w 2 w 2  E 

ZiZjI S(w, w)iS(-w, w)j 

(i,j)=(1,1)

op

 (d,d)

  (d,d)

+ E

ZiZjI S(w, -w)iS(w, w)j  + E 

ZiZj I

(i,j)=(1,1)

op (i,j)=(1,1)

 (t)

w - w

2 2

 (d,d)



S(w, -w)iS(-w, w)j

 
op

- 2 w - w 2 w 2 E 

ZiZjI S(w, w)iS(w, -w)j 

(i,j)=(1,1)

op

  (d,d)



- w - w 2 w 2  E 

ZiZjI S(w, w)iS(-w, w)j 

(i,j)=(1,1)

op

14

Under review as a conference paper at ICLR 2018

 (d,d)

  (d,d)



+ E

ZiZjI S(w, -w)iS(w, w)j  + E 

ZiZjI S(w, -w)iS(-w, w)j  

(i,j)=(1,1)

op (i,j)=(1,1)

op

  (t)

wt - w

2 2

-

3Lcrosst

w 2

wt - w 2

  (t)

wt - w

2 2

-

6Lcross

wt - w w 2

2·

w 2

wt - w

2

 ( (t) - 6Lcross)

wt - w

2 2

where the first inequality we used the definitions of the regions; the second inequality we used the
definition of operator norm; the third inequality we used the fact wt - w 2  w 2; the fourth inequality we used the definition of Lcross and the fifth inequality we used   2 sin  for any 0    /2. Next we can upper bound the norm of the gradient using similar argument

wt (wt) 2 L (t) wt - w 2 + 10Lcross wt - w + 2 wt - w 2 =(L(t) + 10Lcross + 4) wt - w 2 .

Therefore, using the dynamics of gradient descent, putting the above two bounds together, we have

wt+1 - w

2 2



1 -  ((t) - 6Lcross) + 2(L(t) + 10Lcross + 4)2



1

-

((t)

- 2

6Lcross)

wt - w

2 2

wt - w

2 2



1

-

((t)

- 2

6Lcross)

wt - w

2 2

where the last step we have used our choice of t and t  t.

The proof of Theorem 3.2 consists of two parts. First we show if  is chosen properly and T is not to big, then for all 1  t  T , with high probability the iterates stat in a neighborhood of w. Next, conditioning on this, we derive the rate.

Lemma A.2. Denote r0 = w0 - w 2 < w 2 sin . Given 0 < r1 < w 2 sin , number

of iterations T  Z++ and failure probability , denote 1 = arcsin

r1 w 2

then if the step size

satisfies

0 < 1 - (1) + 2(L(0) + 10Lcross + 4)2 < 1

T

r12 - r02 2 (1 + 2T ) (2B (L(0) + 10Lcross + 4) r1

+ 2B2)2



log

T 

with  =  (1) -  (L(0) + 10Lcross + 4). Then with probability at least 1 - , for all t = 1, . . . , T , we have

wt - w  r1.

Proof of Lemma A.2. Let g(wt) = E [wt (wt)] + t. We denote Ft =  {1, . . . , t}, the sigmaalgebra generated by 1, . . . , t and define the event
Ct = {  t, w - w  r1} .

Consider

E

wt+1 - w

2 2

ICt

|Ft

=E

wt - wt

(wt) - w - t

2 2

ICt

|Ft



1 - (1) + 2 (L(0) + 10Lcross + 4)2

wt - w

2 2

+

2B2

ICt

where the inequality follows by our analysis of gradient descent together with definition of Ct and

E [t|Ft] = 0. Define

Gt = (1 - )-t

wt - w

2 2

-

B2 

.

15

Under review as a conference paper at ICLR 2018

By our analysis above, we have

E [Gt+1ICt |Ft]  GtICt  GtICt-1
where the last inequality is because Ct is a subset of Ct-1. Therefore, GtICt-1 is a super-martingale and we may apply Azuma-Hoeffding inequality. Before that, we need to bound the difference between GtICt and its expectation. Note

GtICt-1 - E GtICt-1 |Ft-1 = (1 - )-t

wt - w

2 2

-

E

wt - w

2 2

|Ft-1

ICt-1

= (1 - )-t 2 t, wt - wt (wt) - w - 2E

t

2 2

|Ft-1

ICt-1

 (1 - )-t 2B (L(0) + 10Lcross + 4) wt - w 2 + 2B2 ICt-1  (1 - )-t 2B (L(0) + 10Lcross + 4) r1 + 2B2

dt.

Therefore for all t  T

t
c2t d2
 =1
t
= (1 - )-2t 2B (L(0) + 10Lcross + 4) r1 + 2B2 2
 =1
t (1 - )-2t 2B (L(0) + 10Lcross + 4) r1 + 2B2 2
T (1 + 2T ) 2B (L(0) + 10Lcross + 4) r1 + 2B2 2

where the first inequality we used 1 -  < 1, the second we used t  T and the third we used our assumption on . Let us bound at (t + 1)-th step, the iterate goes out of the region,

P [Ct  { wt+1 - w 2 > r1}] =P Ct 

wt+1 - w

2 2

>

r12

=P Ct 

wt+1 - w

2 2

>

r02

+

(r12

-

r02)

=P Ct 

Gt+1 (1 - )t

+

B2 



G0

+

B2 

+ r12

- r02

P Ct  Gt+1 - G0  r12 - r02

 exp

-

r12 - r02 2c2t

2



 T

where the second inequality we used Azuma-Hoeffding inequality, the last one we used our assumption of . Therefore for all 0  t  T , we have with probability at least 1 - , Ct happens.

Now we can derive the rate.

Lemma A.3. Denote r0 = w0 - w 2 < w 2 sin . Given 0 < r1 < w 2 sin , number

of iterations T  Z++ and failure probability , denote 1 = arcsin

r1 w 2

then if the step size

satisfies

0 < 1 - (1) + 2(L(0) + 10Lcross + 4)2 < 1

T

r12 - r02 2 (1 + 2T ) (2B (L(0) + 10Lcross

+

4) r1

+ 2B2)2



log

T (1) -  (L(0) + 10Lcross + 4)2  log

T 

r02

2

w

2 2



16

Under review as a conference paper at ICLR 2018

2 (1) -  (L(0) + 10Lcross + 4)2

w

2 2



B2

with  =  (1) -  (L(0) + 10Lcross + 4), then we have with probability 1 - 2, wt - w 2  2 w 2 .

Proof of Lemma A.3. We use the same notations in the proof of Lemma A.2. By the analysis of Lemma A.2, we know

E

wt+1 - w

2 2

ICt

|Ft



(1 - )

wt - w

2 2

+

2B2

ICt .

Therefore we have

E

wt - w

2 2

ICt

-

B2 

 (1 - )t

w0 - w

2 2

-

B 

.

Now we can bound the failure probability

P [ wT - w 2  2

w 2] P

wT - w

2 2

-

B2 



2

w

2 2

P

wT - w

2 2

ICt

-

B2 



2

w

2 2

P

wT - w

2 2

ICt

-

B2 



2

w

2 2

E 

wT - w

2 2

ICt

-

B2 

2

w

2 2

+

(1 - )t 
2.

w0 - w

2 2

-

B 

2

w

2 2

+

 Ctc +

The first inequality we used the last assumption. The second inequality we used the probability of an event is upper bound by any superset of this event. The third one we used Lemma A.2 and the union bound. The fourth one we used Markov's inequality.

Now we can specify the T and  and derive the convergence rate of SGD for learning a convolution filter.

Proof of Theorem 3.2. With the choice of  and T , it is straightforward to check they satisfies conditions in Lemma A.3.

Proof of Theorem 3.3. We first prove the lower bound of  (0).


k
E  ZiI {S(w, w)i}
i=1

k
ZiI {S(w, w)i}
i=1

 


k

k

=E kZ + (ZiI {S(w, w)i} - Z) kZ + (ZiI {S(w, w)i} - Z)

i=1 i=1

=k2E ZZ


k

+ kE Z

(ZiI {S(w, w)i} - Z)

i=1

 

+ kE

k
(ZiI {S(w, w)i} - Z) Z
i=1

 

17

Under review as a conference paper at ICLR 2018


k

+E

(ZiI {S(w, w)i} - Z1I {S(w, w)1})

i=1

k2E ZZ


k

+ kE Z

(ZiI {S(w, w)i} - Z)

i=1

+ kE

k
(ZiI {S(w, w)i} - Z) Z
i=1

k
(ZiI {S(w, w)i} - Z1I {S(w, w)1})
i=1



 

Note because Zis have unit norm and by law of cosines Z (ZiI {S(w, w)i} - Z) op  2(1 - cos ). Therefore,


d

min E 

ZiI {S(w, w)i}

i=1

d
ZiI {S(w, w)i}
i=1

   k2(1(0) - 4(1 - cos )).

Now we prove the upper bound of Lcross. Notice that

E ZiZj I S(w, w)iS(w, -w)j

E
2

Zi 2 Zj 2 I S(w, w)iS(w, -w)j

If   , then by our assumption, we have

=
S (w,-w )j

dP (Zi|Zj) dP (j) .
S (w,w )i

S (w,-w )j

dP (Zi|Zj) dP (j) 

dP (Zj)  L.

S (w,w )i

S (w,-w )j

On the other hand, if   , let j be the angle between w and Zj, we have

S (w,-w )j

dP (Zi|Zj)
S (w,w )i

 2

+

dP (j) 



2

L

dP (Zi|Zj) dP (j)
S (w,w )i

L.

Therefore, max E ZS(w,w)ZS(w,-w)  L. Using similar arguments we can show max E ZS(w,w)ZS(-w,w)  L and max E ZS(w,-w)ZS(-w,w)  L.

Proof of Theorem 3.4. We use the same argument by Tian (2017). Let rinit be the initialization radius. The failure probability is lower bounded

1 2

(rinit)

-

+ri2nit
2 w 2

w 2 cos() 2
Vk (rinit)

Vk-1 (rinit) .

Therefore, rinit = cos () w 2 maximizes this lower bound. Plugging this optimizer in and using formula for the volume of the Euclidean ball, the failure probability is lower bounded by

1 2

- cos ()

 (p/2 + 1)  (p/2 + 1/2)



1 2

-

cos ()

p 2

where we used Gautschi's inequality for the last step.

B ADDITIONAL EXPERIMENTAL RESULTS
Figure 5 show the loss of linear interpolation between the learned filter w and ground truth filter w. Our interpolation has the form winter = w + (1 - )w where   [0, 1] is the interpolation ratio. Note that for all interpolation ratios, the loss remains very low.

18

Under review as a conference paper at ICLR 2018

log(Relative Loss) log(Relative Loss)

-9 -6

-10 -8
-11
-12 -10

-13 -12

-14

-15 Random Filter

-14 Gabor Filter

-16 0

-16

20 40 60 80 100

0

20 40 60 80

Interpolation Ratio %

Interpolation Ratio %

Figure 5: Loss of linear interpolation between learned filter and the true filter.

100

19

