Under review as a conference paper at ICLR 2018
RESIDUAL LOSS PREDICTION: REINFORCEMENT LEARNING WITH NO INCREMENTAL FEEDBACK
Anonymous authors Paper under double-blind review
ABSTRACT
We consider reinforcement learning and bandit structured prediction problems with very sparse loss feedback: only at the end of an episode. We introduce a novel algorithm, RESIDUAL LOSS PREDICTION (RESLOPE), that solves such problems by automatically learning an internal representation of a denser reward function. RESLOPE operates as a reduction to contextual bandits, using its learned loss representation to solve the credit assignment problem, and a contextual bandit oracle to trade-off exploration and exploitation. RESLOPE enjoys a no-regret reductionstyle theoretical guarantee and outperforms state of the art reinforcement learning algorithms in both MDP environments and bandit structured prediction settings.
1 INTRODUCTION
Current state of the art learning-based systems require enormous, costly datasets on which to train supervised models. To progress beyond this requirement, we need learning systems that can interact with their environments, collect feedback (a loss or reward), and improve continually over time. In most real-world settings, such feedback is sparse and delayed: most decisions made by the system will not immediately lead to feedback. Any sort of interactive system like this will face at least two challenges: the credit assignment problem (which decision(s) did the system make that led to the good/bad feedback?); and the exploration/exploitation problem (in order to learn, the system must try new things, but these could be bad).
We consider the question of how to learn in an extremely sparse feedback setting: the environment operates episodically, and the only feedback comes at the end of the episode, with no incremental feedback to guide learning. This setting naturally arises in many classic reinforcement learning problems (§4): a barista robot will only get feedback from a customer after their cappuccino is finished1. It also arises in the context of bandit structured prediction (Sokolov et al., 2016; Chang et al., 2015) (§2.2), where a structured prediction system must produce a single output (e.g., translation) and observes only a scalar loss that output.
We introduce a novel reinforcement learning algorithm, RESIDUAL LOSS PREDICTION (RESLOPE) (§ 3), which aims to learn effective representations of the loss signal, effectively a representationlearning approach to the credit assignment problem. Intuitively, RESLOPE attempts to learn a decomposition of the episodic loss into a sum of per-time-step losses. This process is akin to how a person solving a task might realize before the task is complete when and where they are likely to have made suboptimal choices. In RESLOPE, the per-step loss estimates are conditioned on all the information available up to the current point in time, allowing it to learn a highly non-linear representation for the episodic loss (assuming the policy class is sufficiently complex; in practice, we use recurrent neural network policies). When the system receives the final episodic loss, it uses the difference between the observed loss and the cumulative predicted loss to update its parameters.
Algorithmically, RESLOPE operates as a reduction (§3.3) to contextual bandits (Langford & Zhang, 2008), allowing the bandit algorithm to handle exploration/exploitation and focusing only on the credit assignment problem. RESIDUAL LOSS PREDICTION is theoretically motivated by the need for variance reduction techniques when estimating counterfactual costs (Dud´ik et al., 2014) and enjoys a
1This problem can be--and to a large degree has been--mitigated through the task-specific and complex process of reward engineering and reward shaping. Indeed, we were surprised to find that many classic RL algorithms fail badly when incremental rewards disappear. We aim to make such problems disappear.
1

Under review as a conference paper at ICLR 2018

no-regret bound (§3.3) when the underlying bandit algorithm is no-regret. Experimentally, we show the efficacy of RESLOPE on four benchmark reinforcement problems and three bandit structured prediction problems (§ 5.1), comparing to several reinforcement learning algorithms: Reinforce, Proximal Policy Optimization and Advantage Actor-Critic.

2 PROBLEM FORMULATION AND BACKGROUND

We focus on finite horizon, episodic Markov Decision Processes (MDPs) in this paper, which captures both traditional reinforcement learning problems (§ 4) and bandit structured prediction problems (§ 2.2). Our solution to this problem, RESIDUAL LOSS PREDICTION (§ 3) operates in a reduction framework. Specifically, we assume there exists "some" machine learning problem that we know how to solve, and can treat as an oracle. Our reduction goal is to develop a procedure that takes the reinforcement learning problem described above and map it to this oracle, so that a good solution to the oracle guarantees a good solution to our problem. The specific oracle problem we consider is a contextual bandit learning algorithm, relevant details of which we review in §2.1.
Formally, we consider a (possibly virtual) learning agent that interacts directly with its environment. The interaction between the agent and the environment is governed by a restricted class of finitehorizon Markov Decision Processes (MDP), defined as a tuple {S, s0, A, P, L, H} where: S is a large but finite state space, typically S  Rd; s0  S is a start state; A is a finite action space2 of size K; P = { P(s |s, a) : s, s  S, a  A } is the set of Markovian transition probabilities; L  R|S| is the state dependent loss function, defined only at terminal states s  S; H is the horizon (maximum length of an episode).
The goal is to learn a policy , which defines the behavior of the agent in the environment. We consider policies that are potentially functions of entire trajectories3, and potentially produce distributions over actions: (s)  A, where A is the A-dimensional probability simplex. However, to ease exposition, we will present the background in terms of policies that depend only on states; this can be accomplished by simply blowing up the state space.
Let dh denote the distribution of states visited at time step h when starting at state s0 and operating according to : dh+1(s ) = Eshdh,ah(sh)P(s | s = sh, a = ah) The quality of the policy  is quantified by its value function or q-value function: V (s)  R associates each state with the expected future loss for starting at this state and following  afterwards; Q(s, a)  R associates each state/action pair with the same expected future loss: V (sh) = EsHdH | sh L(sH ) and Q(sh, ah) = EsHdH | sh,ah L(sH ) The learning goal is to estimate a policy  from a hypothesis class of policies  with minimal expected loss: J() = V (s0).

2.1 CONTEXTUAL BANDITS

The contextual bandit learning problem (Langford & Zhang, 2008) can be seen as a tractable

special case of reinforcement learning in which the time horizon H = 1. In particular, the

world operates episodically. At each round t, the world reveals a context xt  X ; the system

chooses an action at; the world reveals a scalar loss t(xt, at)  R+, a loss only for the se-

lected action that may depend stochastically on xt and at. The total loss for a system over T

rounds is the sum of losses:

T t=1

t(xt, at).

The goal in policy optimization is to learn a pol-

icy  : x  A from a policy class  that has low regret with respect to the best policy in this

class. Assuming the learning algorithm produces a sequence of policies 1, 2, . . . , T , its regret is:

Regret

t

T t=1

=

T t=1

(xt, t(xt)) - min

T t=1

(xt, (xt)). The particular contextual

bandit algorithms we will use in this paper perform a second level of reduction: they assume access

to an oracle supervised learning algorithm that can optimize a cost-sensitive loss (Appendix C), and

transform the contextual bandit problem to a cost-sensitive classification problem. Algorithms in this

family typically vary along two axes: how to explore (faced with a new x how does the algorithm

choose which action to take); and how to update (Given the observed loss t, how does the algorithm

construct a supervised training example on which to train). More details are in Appendix A.

2In some problems the set of actions available will depend on the current state. 3Policies could choose to ignore all but the most recent state, for instance in fully observable environments,
though this may be insufficient in partially observable environments (Littman & Sutton, 2002).

2

Under review as a conference paper at ICLR 2018
2.2 BANDIT STRUCTURED PREDICTION VIA LEARNING TO SEARCH
In structured prediction, we observe structured input sequences xSP  X and the goal is to predict a set of correlated output variables ySP  Y. For example, in machine translation, the input xSP is a sentence in an input language (e.g., Tagalog) and the output ySP is a sentence in an output language (e.g., Chippewa). In the fully supervised setting, we have access to samples (xSP, ySP) from some distribution D over input/output pairs. Structured prediction problems typically come paired with a structured loss (ySP, y^SP)  R+ that measures the fidelity of a predicted output y^SP to the "true" output ySP. The goal is to learn a function f : X  Y with low expected loss under D: E(xSP,ySP)D (ySP, f (xSP)). Recently, it has become popular to solve structured prediction problems incrementally using some form of recurrent neural network (RNN) model. When the output ySP contains multiple parts (e.g., words in a translation), the RNN can predict each word in sequence, conditioning each prediction on all previous decisions. Although typically such models are trained to maximize cross-entropy with the gold standard output (in a fully supervised setting), there is mounting evidence that this has similar drawbacks to pre-RNN techniques, such as overfitting to gold standard prefixes (the model never learns what to do once it has made an error) and sensitivity to errors of different severity (due to error compounding). In order to achieve this we must formally map from the structured prediction problem to the MDP setting; this mapping is natural and described in detail in Appendix B.
Our focus in this paper is on the recently proposed bandit structured prediction setting (Chang et al., 2015; Sokolov et al., 2016), at training time, we only have access to input xSP from the marginal distribution DX . For example, a Chippewa speaker sees an article in Tagalog, and asks for a translation. A system then produces a single translation y^SP, on which a single "bandit" loss (y^SP | xSP) is observed. Given only this bandit feedback, without ever seeing the "true" translation, the system must learn.
3 PROPOSED APPROACH
Our goal is to learn a good policy in a Markov Decision Process (§ 2) in which losses only arrive at the end of episodes. Our solution, RESIDUAL LOSS PREDICTION (RESLOPE), automatically deduces per-step losses based only on the episodic loss. To gain an intuition for how this works, suppose you are at work and want to meet a colleague at a nearby coffee shop. In hopes of finding a more efficient path to the coffee shop, you take a different path than usual. While you're on the way, you run into a friend and talk to them for a few minutes. You then arrive at the coffee shop and your colleague tells you that you are ten minutes late. To estimate the value of the different path, you wonder: how much of this ten minutes is due to taking the different path vs talking to a friend. If you can accurately estimate that you spent seven minutes talking to your friend (you lost track of time), you can conclude that the disadvantage for the different path is three minutes.
RESLOPE addresses the problem of sparse reward signals and credit assignment by learning a decomposition of the reward signal, essentially doing automatic reward shaping (evaluated in §5.3). Finally, it addresses the problem of exploration vs exploitation by relying on a strong underlying contextual bandit learning algorithm with provably good exploration behavior.
3.1 KEY IDEA: RESIDUAL LOSS PREDICTION
Akin to the coffee shop example, RESLOPE learns a decomposition of the episodic loss (i.e total time spent from work to the coffee shop) into a sum of per-time-step losses (i.e. timing activities along the route). RESLOPE operates as a reduction from reinforcement learning with episodic loss to contextual bandits. In this way, RESLOPE solves the credit assignment problem by predicting residual losses, and relies on the underlying contextual bandit oracle to solve explore/exploit. RESLOPE operates online, incrementally updating a policy learn once per episode. In the structured contextual bandit setting, we assume access to a reference policy, ref, that was perhaps pretrained on supervised data, and which we wish to improve; a hyperparameter  controls how much we trust ref. As learn improves, we replace ref with learn. In the RL setting, we set  = 0.
We initially present a simplified variant of RESLOPE that mostly follows the learned policy (and the reference policy as appropriate), except for a single deviation per episode. This algorithm closely
3

Under review as a conference paper at ICLR 2018

Input

International

Deviation Step

Conference

For

Learning

Representations

Residual Loss Observed Loss

RESLOPE

LSTM

Prediction
Estimated Costs

Noun 0.4

LSTM

LSTM

LSTM

Noun 0.3

Preposition 0.1

estimated action Costs

Verb 0.9

LSTM
Noun 0.2

Counterfactual Cost Estimation
Target Costs Loss Func.

Observed Loss = 2

Predicted Costs = 0.4 + 0.3 + 0.1 + 0.2 = 1

Residual Loss = 2 - 1 = 1

Back-Prop

Figure 1: RESIDUAL LOSS PREDICTION: the system assigns a part-of-speech tag sequence to the sentence "International Conference for Learning Representations". Each state represents a partial labeling. The end state e = [Noun, Noun, Preposition, Verb, Noun]. The end state e is associated with an episodic loss (e), which is the total hamming loss in comparison to the optimal output structure e = [Adjective, Noun, Preposition, Noun, Noun]. We emphasize that our algorithm doesn't assume access to neither the optimal output structure, nor the hamming loss for every time step. Only the total hamming loss is observed in this case ( (e) = 2).

follows the bandit version of the Locally Optimal Learning to Search (LOLS) approach of Chang et al. (2015), with three key differences: (1) residual loss prediction; (2) alternative exploration strategies; (3) alternative parameter update strategies. We assume access to a contextual bandit oracle CB that supports the following API:
1. CB.ACT(learn, x), where x is the input example; this returns a tuple (a, p), where a is the selected action, and p is the probability with which that action was selected.
2. CB.COST(learn, x, a) returns the estimated cost of taking action a in the context.
3. CB.UPDATE(learn, x, a, p, c), where x is the input example, a  [K] is the selected action, p  (0, 1] is the probability of that action, and c  R is the target cost.
The requirement that the contextual bandit algorithm also predicts costs (CB.COST) is somewhat non-standard, but is satisfied by many contextual bandit algorithms in practice, which often operate by regressing on costs and picking the minimal predicted cost action. We describe the specific contextual bandit approaches we use in §3.2.
Algorithm 1 shows how our reduction is constructed formally. It uses a MAKEENVIRONMENT(t) function to construct a new environment (randomly in RL and by selecting the tth example in bandit structured prediction). To learn a good policy, RESLOPE reduces long horizon trajectories to singlestep contextual bandit training examples. In each episode, RESLOPE picks a single time step to deviate. Prior to the deviation step, it executes learn as a roll-in policy and after the deviation step, it executes a  mixture of learn and ref. At the deviation step, it calls CB.ACT to handle the exploration and choose an action. At every step, it calls CB.COST to estimate the cost of that action. Finally, it constructs a single contextual bandit training example for the deviation step, whose input was the observation at that step, whose action and probability are those that were selected by CB.ACT, and whose cost is the observed total cost minus the cost of every other action taken in this trajectory. This example is sent to CB.UPDATE. When the contextual bandit policy is an RNN (as in our setting), this will then compute a loss which is back-propagated through the RNN.
Interaction between RESLOPE and the environment takes place via the RESLOPEPOLICY procedure, which is given state and returns the action a predicted by RESLOPE. Internally, RESLOPEPOLICY performs a standard learning-to-search prediction step. A mixture policy is used to generate the roll-out trajectories (Figure 5). The mixture policy either executes ref with probability  or learn with probability 1 - . At the deviation step, the contextual bandit exploration algorithm is used to pick an action (§ 3.2). Regardless of how the action is chosen, the action's cost is estimated using the contextual bandit oracle.
4

Under review as a conference paper at ICLR 2018

Algorithm 1 RESIDUAL LOSS PREDICTION (RESLOPE) with single deviations

Require: Reference policy ref, mixture parameter   [0, 1], contextual bandit oracle

MAKEENVIRONMENT to build new enviornments

1: Initialize a policy 0learn {either randomly or from a pretrained model} 2: for all episodes t = 1 . . . T do

3: env  MAKEENVIRONMENT(t) 4: Initialize variables: example xdev, action adev, probability pdev 5: Initialize cost vector c^hdev = 0 for h = 1 . . . env.H 6: Choose deviation step hdev  UNIFORM(env.H)

7: Choose rollout policy mix to be ref with probability  or tle-ar1n with probability 1 -  8: for all time steps h = 1 . . . env.H do

9: x  env.STATEFEATURES {computed by an RNN} 10: if h = hdev { no deviation } then

11:

a

tle-ar1n(x) if h < hdev mix(x) if h > hdev

12: else if h = hdev { deviation } then 13: (adev, pdev)  CB.ACT(learn, x)

14: xdev  x 15: a  adev

16: end if 17: c^hdev  CB.COST(tle-ar1n, x, a)
18: env.STEP(a) {updates environment and internal state of the RNN }

19: end for

20: residual  env.FINALLOSS - h=hdev c^hdev

21: tlearn  CB.UPDATE(tle-ar1n, xdev, adev, pdev, residual)

22: end for

23:

Return average policy ¯ =

1 T

t tlearn

CB,

3.2 CONTEXTUAL BANDIT ORACLE
The contextual bandit oracle receives examples where the cost for only one predicted action is observed, but no others. It learns a policy for predicting actions minimizing expected loss by estimating the unobserved target costs for the unpredicted actions and exploring different actions to balance the exploitation exploration trade-off (§ 3.2). The contextual bandit oracle then calls a cost-sensitive multi-class oracle (Appendix C) given the target costs and the selected action.

CB.UPDATE: Cost Estimation Techniques. The update procedure for our contextual bandit oracles takes an example x, action a, action probability p and cost c as input and updates its policy.
We do this by reducing to a cost-sensitive classification oracle (Appendix C), which expects an example x and a cost vector y  RK that specifies the cost for all actions (not just the selected one). The reduction challenge is constructing this cost-sensitive classification example given the input to
CB.UPDATE. We consider three methods: inverse propensity scoring (Horvitz & Thompson, 1952), doubly robust estimation (Dud´ik et al., 2014) and multitask regression (Langford & Agarwal, 2017).

Inverse Propensity Scoring (IPS): IPS uses the selected action probability p to correct for the shift

in action proportions predicted by the policy learn. IPS estimates the target cost vector y as: y(i) =

c p

1[i

=

a],

where

1

is

an

indicator

function

and

where

a

is

the

selected

action

and

c

is

the

observed

cost. While IPS yields an unbiased estimate of costs, it typically has a large variance as p  0.

Doubly Robust Cost Estimation (DR): The doubly robust estimator uses both the observed cost c as well as its own predicted costs y^(i) for all actions, forming a target that combines these two sources of information. DR estimates the target cost vector y as: y(i) = y^(i) + 1[i = a](c - y^(i))/p. The DR estimator remains unbiased, and the estimated loss y helps decrease its variance.

Multitask Regression (MTR): The multitask regression estimator functions somewhat differently from IPS and MTR. Instead of reducing to to cost-sensitive classification, MTR reduces directly to importance-weighted regression. MTR maintains K different regressors for predicting costs given input/action pairs. Given x, a, c, p, MTR constructs a regression example, whose input is (x, a), whose target output is c and whose importance weight is 1/p.

5

Under review as a conference paper at ICLR 2018

CB.ACT: Exploration Strategies. We experiment with three exploration strategies:
Uniform: explores randomly with probability and otherwise acts greedily (Sutton & Barto, 1998).
Boltzmann: varies action probabilities where action a is chosen with probability proportional to exp[-c(a)/temp], where temp  R+ is the temperature, and c(a) is the predicted cost of action a.
Bootstrap Exploration: (Agarwal et al., 2014) trains a bag of multiple policies is simultaneously. Each policy in the bag votes once on its predicted action, and an action is sampled from this distribution. To train, each example gets passed to each policy Poisson( = 1)-many times, which ensures diversity . Bootstrap can operate in "greedy update" and "greedy prediction" mode (Bietti et al., 2017). In greedy update, we always update the first policy in the bag exactly once.In greedy prediction, we always predict the action from the first policy during exploitation.

3.3 THEORETICAL ANALYSIS

For simplicity, we first consider the case where we have access to a good reference policy ref but do not have access to good Q-value estimates under ref. The only way one can obtain a Q-value
estimate is to do a roll-out, but in a non-resettable environment, we can only do this once. We will
subsequently consider the case of suboptimal (or missing) reference policies, in which the goal of the analysis will change from competing with ref to competing with both ref and a local optimality
guarantee. We can show the following (proof in Appendix D).

Theorem 1. If  = 1, running RESLOPE for N episodes with a contextual bandit algorithm that

has regret CB(N ), the average returned policy ¯ = Enn has regret equal to the suboptimality of

ref,

namely:

Regret(¯)



Regret(ref)

+

1 N

CB(N ).

In the case that ref is not known to be optimal, or not available, we follow the LOLS analysis and obtain a regret to a convex combination of ref and the learned policy's one-step deviations (a form
of local optimality) and can additionally show the following (proof in Appendix E):

Theorem 2. For arbitrary , define the combined regret of ¯ as: Regret(¯) = [J(¯) - J(ref)] +

(1 - ) h[J (¯) - min Esdh¯ Q¯ (s, )]. The first term is suboptimality to ref; the second

term is suboptimality to the policy's own realizable one-step deviations. Given a contextual bandit

learning

algorithm,

the

combined

regret

of

¯

satisfies:

Regret (¯ )



1 N

CB(N ).

If the contextual bandit algorithm is no regret, then CB/N  0 as N  .

3.4 MULTI-DEVIATION RESIDUAL LOSS PREDICTION
Finally, we present the multiple deviation variant of RESLOPE. Algorithm 2 shows how RESLOPE operates under multiple deviations. The difference between the single and multiple deviation mode is twofold: 1. Instead of deviating at a single time step, multi-dev RESLOPE performs deviations at each time step in the horizon; 2. Instead of generating a single contextual bandit example per episode, multi-dev RESLOPE generates H examples, where H is the length of the time horizon, effectively updating the policy H times.
These two changes means that we update the learned policy learn multiple times per episode. Empirically, we found this to be crucial for achieving superior performance. Although, the generated samples for the same episode are not independent, this is made-up for by the huge increase in the number of available samples for training (i.e. T×H samples for multiple deviations versus only T samples in the single deviation mode). The theoretical analysis that precedes still holds in this case, but only makes sense when  = 0 because there is no longer any distinction between roll-in and roll-out, and so the guarantee reduces to a local optimality guarantee.

4 EXPERIMENTAL SETUP
We conduct experiments on both reinforcement learning and structured prediction tasks. Our goal is to evaluate how quickly different learning algorithms learn from episodic loss. We implement our models on top of the DyNet neural network optimization package (Neubig et al., 2017). The code will be made available upon publication of this work.

6

Under review as a conference paper at ICLR 2018

Algorithm 2 RESIDUAL LOSS PREDICTION (RESLOPE) with multiple deviations

Require: Contextual bandit oracle CB, MAKEENVIRONMENT to build new enviornments

1: Initialize a policy 0learn {either randomly or from a pretrained model}

2: for all episodes t = 1 . . . T do

3: env  MAKEENVIRONMENT(t) 4: Initialize variables: examples xhdev, actions adhev, probabilities phdev
and costs c^dhev = 0 for h = 1 . . . env.H
5: for all time steps h = 1 . . . env.H do

6: xhdev  env.STATEFEATURES {computed by an RNN} 7: (adhev, pdhev)  CB.ACT(learn, xhdev) 8: c^dhev  CB.COST(tle-ar1n, xdhev, adhev) 9: env.STEP(ahdev) {updates environment and internal state of the RNN }
10: end for

11:

residual h



env.FINALLOSS

-

h =h c^dev(h ) for all h

12:

tlearn  CB.UPDATE(tle-ar1n, xhdev, adhev, phdev,

residual h

)

for

all

h

13: end for

14:

Return average policy ¯ =

1 T

t tlearn

Reinforcement Learning Environments We perform experiments in four standard reinforcement learning environments: Blackjack (classic card game), Hex (two-player board game), Cartpole (aka "inverted pendulum") and Gridworld. Our implementations of these environments are described in Appendix F and largely follows the AI Gym (Brockman et al., 2016) implementations. We report results in terms of cumulative loss, where loss is -1×reward for consistency with the loss-based exposition above and the loss-based evaluation of bandit structured prediction (§2.2).

Bandit Structured Prediction Environments We also conduct experiments on structured prediction tasks. The evaluation framework we consider is the fully online setup described in (§ 2.2), measuring the degree to which various algorithms can effectively improve by observing only the episodic loss, and effectively balancing exploration and exploitation. We learn from one structured example at a time and we do a single pass over the available examples. We measure performance in terms of average cumulative loss on the online examples as well as on a held-out evaluation dataset. The loss on the online examples measures how much the algorithm is penalized for unnecessary exploration. We perform experiments on the three tasks described in detail in Appendix G: English Part of Speech Tagging, English Dependency Parsing and Chinese Part of Speech Tagging.

4.1 COMPARATIVE ALGORITHMS
We compare against three common reinforcement learning algorithms: Reinforce (Williams, 1992) with a baseline whose value is an exponentially weighted running average of rewards; Proximal Policy Optimization (PPO) (Schulman et al., 2017); and Advantage Actor-Critic (A2C) (Mnih et al., 2016). For the structured prediction experiments, since the bandit feedback is simulated based on labeled data, we can also estimate an "upper bound" on performance by running a supervised learning algorithm that uses full information (thus forgoing issues of both exploration/exploitation and credit assignment). We run supervised DAgger to obtain such an upper bound.

4.2 POLICY ARCHITECTURE

In all cases, our policy is a recurrent neural network (Elman, 1990) that maintains a real-valued hidden state and combines: (a) its previous hidden state, (b) the features from the environment (described for each environment in the preceding sections), and (c) an embedding of its previous action. These form a new hidden state, from which a prediction is made. Formally, at time step h, vh is the hidden state representation, f (stateh) are the features from the environment and ah is the action taken. The recursion is:

v0 = const ; vh+1 = ReLU A vh , f (stateh) , emb(ah)

(1)

Here, A is a learned matrix, const is an initial (learned) state, emb is a (learned) action embedding function, and ReLU is a rectified linear unit applied element-wise.

7

Under review as a conference paper at ICLR 2018

AveornatgreaiLnoss

AveornatgreaiLnoss

AveornagdeeLvoss

Blackjack

0.5

Reslope-Bootstrap Reslope-Boltzmann

0.4

Advantage Actor-Critic Reinforce w/ baseline

0.3 Prox. Policy Optimization

0.2

0.1 101

Nu1m02ber of1e0p3isodes104

Hex
0.2 0.0 0.2 0.4 0.6 0.8
101 Nu1m02ber of1e0p3isodes104

0 Cartpole
50 100 150 200 101 Numb1e0r2of episod1e0s3

Grid
1.5 1.0 0.5 0.0 0.5 1.0 101 Nu1m02ber of1e0p3isodes104

Figure 2: Average loss during learning on the four RL problems. Shaded regions are empirical quartiles over the experimental replicates with different random seeds.

English POS
14 12 10

English Parsing
14 12 10

Chinese POS
5
4

8 6 4 2
101

N1u0m2ber of e1x0a3mples 104

8 6 4 2
101

Reslope-Bootstrap Reslope-Boltzmann Advantage Actor-Critic Reinforce w/ baseline Prox. Policy Optimization DAgger
N1u0m2ber of e1x0a3mples 104

3
2
1 101

N1u0m2 ber of1e0x3ample1s04

105

Figu12re clud10ed

3: Average loss during learn18ing for three bandit
are supervised learning result1s6 with DAgger.
14

structured2.p50rediction
2.25

problems.

Also in-

8 12 2.00

a(eGnoaxnerinpdtvawdee246sAcnoaitnr21htk0cgCh1omloe,espitwhhgeeiihhNrdds1autit0ddmcti2bimeehbneenngraetoltxhsfoaetepe1ynsax0eaeta3avmcerrstpgh(lvtewamhswhcehit1,inie0tooa4hrouneneftoppiattuhhrchotetei=bsoroea1fnn02486bBctohimo12leh0ist1RuitipdseseotdsLwl,ebiUNhcnte1uhye(0mle,2Bnsabsteye1hoerleveepoarfchesoer1tr)xee0u(aa)3idmt.tcnpi.poInulwnemgsTthtvpgh1hi0aurice4selthuceeieadcdsssaiaeldsoyseoo1111)hns.....ft5207hoae5005IRefrnteu1Emo0tsSu1huiaLsnetxpeOg(cdu-PaNa1tasEu0ovesm2saehbitoncmeh)rftdeoopfRf1rDrple0oeex3riAmasiemnfdgoepfiwgelohecde1srth0cre=f4i,oedcw,rhBcwPh,ovPaif1schro0Otdh5s)r

instance, an action ah is sampled.

Details on optimization, hyperparameters and "deep learning tricks" are reported in Appendix H.

5 EXPERIMENTAL RESULTS
We study several questions empirically: 1. How does RESIDUAL LOSS PREDICTION compare to policy gradient methods on reinforcement learning and bandit structured prediction tasks? (§ 5.1) 2. What's the effect of ablating various parts of the RESLOPE approach, including multiple deviations? (§5.2) 3. Does RESLOPE succeed in learning a good representation of the loss? (§5.3)
5.1 REINFORCEMENT LEARNING AND BANDIT STRUCTURED PREDICTION RESULTS
In our first set of experiments, we compare RESLOPE to the competing approaches on the four reinforcement learning tasks described above. Figure 2 shows the results. In Blackjack, Hex and Grid, RESLOPE outperforms all the competing approaches with lower loss earlier in the learning process (though for Hex and Grid they all finish at the same near-optimal policy). For Cartpole, RESLOPE significantly underperforms both Reinforce and PPO.4 Furthermore, in both Blackjack and Grid, the bootstrap exploration significantly improves upon Boltzmann exploration. In general, both RESLOPE and PPO perform quite well, though PPO often takes a bit longer to learn (likely because it is overly conservative).
In our second set of experiments, we compare the same algorithms plus the fully supervised DAgger algorithm on the three structured prediction problems; the results are in Figure 3. Here, we can
4It is not entirely clear to us yet why this happens. We found that RESLOPE performs as well as Reinforce and PPO if we (a) replace the loss with one centered around zero and (b) replace the RNN policy with a simpler feed-forward network, but we do not include these results in the figure to keep the experiments consistent.

8

Under review as a conference paper at ICLR 2018

Loss

2.5 2.0 1.5 1.0 0.5 0.0
0

Time Sensitive Loss

Truth-L1 Reslope-L1 Truth-L5 Reslope-L5

1.2 1.0

0.8

0.6

0.4

0.2

0.0

20000 40000 60000 80000 100000 Time

0

Distance Sensitive Loss

Truth-L1 Reslope-L1 Truth-L5 Reslope-L5

0.8 0.7 0.6 0.5

0.4

0.3

0.2

0.1

0.0 20000 40000 60000 80000 100000
Time

0

Hamming Loss
Truth-L1 Reslope-L1 Truth-L5 Reslope-L5 20000 40000 60000 80000 100000 Time

Figure 4: Empirical effect of additive vs non-additive loss functions. Performance is better when the loss is additive (blue) vs non-additive (green). The x-axis shows the number of episodes and the y-axis measures the incremental loss using the true loss function (light colors) and using RESLOPE (dark colors). If RESLOPE worked perfectly, these would coincide.

observe RESLOPE significantly outperforming all alternative algorithms (except, of course, DAgger) on training loss (also on heldout (development) loss; see Figure 8 in the appendix). There is still quite a gap to fully supervised learning, but nonetheless RESLOPE is able to reduce training error significantly on all tasks: by over 25% on English POS, by about half on English dependency parsing, and by about 10% on Chinese POS tagging.

5.2 ABLATION OF RESIDUAL LOSS PREDICTION
In our construction of RESLOPE, there are several tunable parameters: which contextual bandit learner to use (IPS, DR, MTR), which exploration strategy (Uniform, Boltzmann, Bootstrap), and, for Bootstrap, whether to do greedy prediction and/or greedy update. In Table 1 (in the Appendix), we show the results on all tasks for ablating these various parameters. For the purpose of the ablation, we fix the "baseline" system as: DR, Bootstrap, and with both greedy prediction and greedy updates, though this is not uniformly the optimal setting (and therefore these numbers may differ slightly from the preceding figures). The primary take-aways from these results are: (1) MTR and DR are competitive, but IPS is much worse; (2) Bootstrap is much better than either other exploration method (especially uniform, not surprisingly); (3) Greedy prediction is a bit of a wash, with only small differences either way; (4) Greedy update is important. In Appendix I, we consider the effect of single vs multiple deviations and observe that significant importance of multiple deviations for all algorithms, with Reinforce and PPO behaving quite poorly with only single deviations.

5.3 EVALUATING THE LEARNED LOSS REPRESENTATION

In our final set of experiments, we study RESLOPE's performance under different--and especially non-additive--loss functions. Our goal is to investigate RESLOPE's ability to learn good representations for the episodic loss. We consider the following different incremental loss functions for each time step: Hamming (0/1 loss at each position), Time-Sensitive (cost for an error at position h is equal to h) and Distance-Sensitive (cost for predicting a^ instead of a is |a^ - a|). To combine these per-stop losses into a per-trajectory loss  of length H, we compute the H-dimensional loss vector
suffered by RESLOPE along this trajectory. To consider both additive and non-additive combinations, we consider Lp norms of this loss vector. When the norm is L1, this is simple additive loss.

More generally, we consider ( ) = p

t=H t=1

p(t) for any p > 0.

We run six different experiments using different incremental and episodic loss functions. For each incremental loss function (i.e. hamming, time sensitive, distance sensitive) we run two experiments: using the total hamming loss (additive) and an Lp norm of five (non-additive). Results are presented in Figure 4. We observe the following. RESLOPE can always learn the optimal representation for the incremental loss when the episodic loss function is additive. This is the case for all the three incremental loss functions: hamming, time sensitive, and distance sensitive. Learning is faster when the episodic loss function is additive. While RESLOPE is still able to learn a good representation even when using the L5 norm loss, this happens much later in comparison to the additive loss function (40k time steps for L5 norm vs 20k for total hamming loss). Not surprisingly, performance degrades as the episodic loss function becomes non-additive. This is most acute when using L-5 norm with

9

Under review as a conference paper at ICLR 2018
the incremental hamming loss. This is expected as in the distance and time sensitive loss functions, RESLOPE observes a smoother loss function and learns to distinguish between different time steps based on the implicit encoding of time and distance information in the observed loss. RESLOPE can still learn a good representation for smoother episodic loss functions. This is shown empirically for time and distance sensitive loss functions.
6 RELATED WORK AND DISCUSSION
RESIDUAL LOSS PREDICTION builds most directly on the bandit learning to search frameworks LOLS (Chang et al., 2015) and BLS (Sharaf & Daume´, 2017). The "bandit" version of LOLS was analyzed theoretically but not empirically in the original paper; Sharaf & Daume´ (2017) found that it failed to learn empirically.They addressed this by requiring additional feedback from the user, which worked well empirically but did not enjoy any theoretical guarantees. RESLOPE achieves the best of both worlds: a strong regret guarantee, good empirical performance, and no need for additional feedback. The key ingredient for making this work is using the residual loss structure together with strong base contextual bandit learning algorithms.
A number of recent algorithms have updated "classic" learning to search papers with deep learning underpinnings (Wiseman & Rush, 2016; Leblond et al., 2017). These aim to incorporate sequencelevel global loss function to mitigate the mismatch between training and test time discrepancies, but only apply in the fully supervised setting. Mixing of supervised learning and reinforcement signals has become more popular in structured prediction recently, generally to do a better job of tuning for a task-specific loss using either Reinforce (Ranzato et al., 2015) or Actor-Critic (Bahdanau et al., 2016). The bandit variant of the structured prediction problem was studied by Sokolov et al. (2016), who proposed a reinforce method for optimizing different structured prediction models under bandit feedback in a log-linear structured prediction model.
A standard technique for dealing with sparse and episodic reward signals is reward shaping (Ng et al., 1999): supplying additional rewards to a learning agent to guide its learning process, beyond those supplied by the underlying environment. Typical reward shaping is hand-engineered; RESLOPE essentially learns a good task-specific reward shaping automatically. The most successful baseline approach we found is Proximal Policy Optimization (PPO, (Schulman et al., 2017)), a variant of Trust Region Policy Optimization (TRPO, (Schulman et al., 2015)) that is more practical. Experimentally we have seen RESLOPE to typically learn more quickly than PPO. Theoretically both have useful guarantees of a rather incomparable nature.
Since RESLOPE operates as a reduction to a contextual bandit oracle, this allows it to continually improve as better contextual bandit algorithms become available, for instance work of Syrgkanis et al. (2016) and Agarwal et al. (2014). Although RESLOPE is quite effective, there are a number of shortcomings that need to be addressed in future work. For example, the bootstrap sampling algorithm is prohibitive in terms of both memory and time efficiency. One approach for tackling this would be using the amortized bootstrap approach by Nalisnick & Smyth (2017), which uses amortized inference in conjunction with implicit models to approximate the bootstrap distribution over model parameters. There is also a question of whether the reduction to contextual bandits creates "reasonable" contextual bandit problems in conjunction with RNNs. While some contextual bandit algorithms assume strong convexity or linearity, the ones we employ operate on arbitrary policy classes, provided a good cost-sensitive learner exists. The degree to which this is true will vary by neural network architecture, and what can be guaranteed (e.g., no regret online neural learning).
REFERENCES
Alekh Agarwal, Daniel Hsu, Satyen Kale, John Langford, Lihong Li, and Robert E. Schapire. Taming the monster: A fast and simple algorithm for contextual bandits. In In Proceedings of the 31st International Conference on Machine Learning (ICML-14, pp. 1638­1646, 2014.
J. A. Bagnell, Sham M Kakade, Jeff G. Schneider, and Andrew Y. Ng. Policy search by dynamic programming. In S. Thrun, L. K. Saul, and P. B. Scho¨lkopf (eds.), Advances in Neural Information Processing Systems 16, pp. 831­838. MIT Press, 2004. URL http://papers.nips.cc/ paper/2378-policy-search-by-dynamic-programming.pdf.
10

Under review as a conference paper at ICLR 2018
Dzmitry Bahdanau, Philemon Brakel, Kelvin Xu, Anirudh Goyal, Ryan Lowe, Joelle Pineau, Aaron Courville, and Yoshua Bengio. An actor-critic algorithm for sequence prediction. arXiv preprint arXiv:1607.07086, 2016.
A. G. Barto, R. S. Sutton, and C. W. Anderson. Neuronlike adaptive elements that can solve difficult learning control problems. IEEE Transactions on Systems, Man, and Cybernetics, SMC-13(5): 834­846, Sept 1983. ISSN 0018-9472. doi: 10.1109/TSMC.1983.6313077.
Alina Beygelzimer, John Langford, and Bianca Zadrozny. Weighted one-against-all. In AAAI, pp. 720­725, 2005.
Alina Beygelzimer, John Langford, Lihong Li, Lev Reyzin, and Robert Schapire. Contextual bandit algorithms with supervised learning guarantees. In Proceedings of the Fourteenth International Conference on Artificial Intelligence and Statistics, volume 15 of Proceedings of Machine Learning Research, pp. 19­26, Fort Lauderdale, FL, USA, 11­13 Apr 2011. PMLR. URL http://proceedings.mlr.press/v15/beygelzimer11a.html.
Alberto Bietti, Alekh Agarwal, and John Langford. Vowpal wabbit. VW, 2017. URL https: //github.com/JohnLangford/vowpal_wabbit/wiki.
Greg Brockman, Vicki Cheung, Ludwig Pettersson, Jonas Schneider, John Schulman, Jie Tang, and Wojciech Zaremba. Openai gym. arXiv preprint arXiv:1606.01540, 2016.
Kai-Wei Chang, Akshay Krishnamurthy, Alekh Agarwal, Hal Daume´, III, and John Langford. Learning to search better than your teacher. In Proceedings of the 32Nd International Conference on International Conference on Machine Learning - Volume 37, ICML'15, pp. 2058­2066. JMLR.org, 2015. URL http://dl.acm.org/citation.cfm?id=3045118.3045337.
Hal Daume´, John Langford, and Daniel Marcu. Search-based structured prediction. Machine Learning, 75(3):297­325, Jun 2009. ISSN 1573-0565. doi: 10.1007/s10994-009-5106-x. URL https://doi.org/10.1007/s10994-009-5106-x.
Hal Daume´, III and Daniel Marcu. Learning as search optimization: Approximate large margin methods for structured prediction. In Proceedings of the 22Nd International Conference on Machine Learning, ICML '05, pp. 169­176, New York, NY, USA, 2005. ACM. ISBN 1-59593180-5. doi: 10.1145/1102351.1102373. URL http://doi.acm.org/10.1145/1102351. 1102373.
John Duchi, Elad Hazan, and Yoram Singer. Adaptive subgradient methods for online learning and stochastic optimization. Journal of Machine Learning Research, 12:2121­2159, July 2011. ISSN 1532-4435. URL http://dl.acm.org/citation.cfm?id=1953048.2021068.
Miroslav Dud´ik, Dumitru Erhan, John Langford, and Lihong Li. Doubly robust policy evaluation and optimization. Statist. Sci., 29(4):485­511, 11 2014. doi: 10.1214/14-STS500. URL https: //doi.org/10.1214/14-STS500.
Jeffrey L. Elman. Finding structure in time. Cognitive Science, 14(2):179 ­ 211, 1990. ISSN 0364-0213. doi: https://doi.org/10.1016/0364-0213(90)90002-E. URL http://www. sciencedirect.com/science/article/pii/036402139090002E.
Xavier Glorot and Yoshua Bengio. Understanding the difficulty of training deep feedforward neural networks. In Yee Whye Teh and Mike Titterington (eds.), Proceedings of the Thirteenth International Conference on Artificial Intelligence and Statistics, volume 9 of Proceedings of Machine Learning Research, pp. 249­256, Chia Laguna Resort, Sardinia, Italy, 13­15 May 2010. PMLR. URL http://proceedings.mlr.press/v9/glorot10a.html.
Ryan B Hayward and Jack Van Rijswijck. Hex and combinatorics. Discrete Mathematics, 306(19): 2515­2528, 2006.
Sepp Hochreiter and Ju¨rgen Schmidhuber. Long short-term memory. Neural Computation, 9 (8):1735­1780, 1997. doi: 10.1162/neco.1997.9.8.1735. URL https://doi.org/10.1162/ neco.1997.9.8.1735.
11

Under review as a conference paper at ICLR 2018
D. G. Horvitz and D. J. Thompson. A generalization of sampling without replacement from a finite universe. Journal of the American Statistical Association, 47(260):663­685, 1952. doi: 10. 1080/01621459.1952.10483446. URL http://www.tandfonline.com/doi/abs/10.1080/ 01621459.1952.10483446.
Armand Joulin, Edouard Grave, Piotr Bojanowski, Matthijs Douze, He´rve Je´gou, and Tomas Mikolov. Fasttext.zip: Compressing text classification models. arXiv preprint arXiv:1612.03651, 2016.
Sham Machandranath Kakade et al. On the sample complexity of reinforcement learning. PhD thesis, University of London London, England, 2003.
Diederik P. Kingma and Jimmy Ba. Adam: A method for stochastic optimization. CoRR, abs/1412.6980, 2014. URL http://arxiv.org/abs/1412.6980.
John Langford and Alekh Agarwal. Vowpal wabbit online learning project, 2017.
John Langford and Tong Zhang. The epoch-greedy algorithm for multi-armed bandits with side information. In Advances in Neural Information Processing Systems 20, pp. 817­824. Curran Associates, Inc., 2008. URL http://papers.nips.cc/paper/ 3178-the-epoch-greedy-algorithm-for-multi-armed-bandits-with-side-information. pdf.
Re´mi Leblond, Jean-Baptiste Alayrac, Anton Osokin, and Simon Lacoste-Julien. Searnn: Training rnns with global-local losses. arXiv preprint arXiv:1706.04499, 2017.
Michael L. Littman and Richard S Sutton. Predictive representations of state. In T. G. Dietterich, S. Becker, and Z. Ghahramani (eds.), Advances in Neural Information Processing Systems 14, pp. 1555­1561. MIT Press, 2002. URL http://papers.nips.cc/paper/ 1983-predictive-representations-of-state.pdf.
Mitchell P Marcus, Mary Ann Marcinkiewicz, and Beatrice Santorini. Building a large annotated corpus of english: The penn treebank. Computational linguistics, 19(2):313­330, 1993.
Volodymyr Mnih, Adria Puigdomenech Badia, Mehdi Mirza, Alex Graves, Timothy Lillicrap, Tim Harley, David Silver, and Koray Kavukcuoglu. Asynchronous methods for deep reinforcement learning. In International Conference on Machine Learning, pp. 1928­1937, 2016.
Eric Nalisnick and Padhraic Smyth. The amortized bootstrap. In ICML 2017 Workshop on Implicit Models., 2017.
John F Nash. Some games and machines for playing them. Technical Report, D-1164, 1952.
Gergely Neu and Csaba Szepesva´ri. Training parsers by inverse reinforcement learning. Mach. Learn., 77(2-3):303­337, December 2009. ISSN 0885-6125. doi: 10.1007/s10994-009-5110-1. URL https://doi.org/10.1007/s10994-009-5110-1.
Graham Neubig, Chris Dyer, Yoav Goldberg, Austin Matthews, Waleed Ammar, Antonios Anastasopoulos, Miguel Ballesteros, David Chiang, Daniel Clothiaux, Trevor Cohn, et al. Dynet: The dynamic neural network toolkit. arXiv preprint arXiv:1701.03980, 2017.
Andrew Y. Ng, Daishi Harada, and Stuart J. Russell. Policy invariance under reward transformations: Theory and application to reward shaping. In Proceedings of the Sixteenth International Conference on Machine Learning, ICML '99, pp. 278­287, San Francisco, CA, USA, 1999. Morgan Kaufmann Publishers Inc. ISBN 1-55860-612-2. URL http://dl.acm.org/citation. cfm?id=645528.657613.
Joakim Nivre. An efficient algorithm for projective dependency parsing. In IWPT, pp. 149­160, 2003.
Olutobi Owoputi, Chris Dyer, Kevin Gimpel, Nathan Schneider, and Noah A. Smith. Improved part-of-speech tagging for online conversational text with word clusters. In In Proceedings of NAACL, 2013.
12

Under review as a conference paper at ICLR 2018
Jeffrey Pennington, Richard Socher, and Christopher Manning. Glove: Global vectors for word representation. In Proceedings of the 2014 Conference on Empirical Methods in Natural Language Processing (EMNLP), pp. 1532­1543, Doha, Qatar, October 2014. Association for Computational Linguistics. URL http://www.aclweb.org/anthology/D14-1162.
Marc'Aurelio Ranzato, Sumit Chopra, Michael Auli, and Wojciech Zaremba. Sequence level training with recurrent neural networks. arXiv preprint arXiv:1511.06732, 2015.
Stephane Ross and J Andrew Bagnell. Reinforcement and imitation learning via interactive no-regret learning. arXiv preprint arXiv:1406.5979, 2014.
Stephane Ross, Geoffrey Gordon, and Drew Bagnell. A reduction of imitation learning and structured prediction to no-regret online learning. In Proceedings of the Fourteenth International Conference on Artificial Intelligence and Statistics, volume 15 of Proceedings of Machine Learning Research, pp. 627­635, Fort Lauderdale, FL, USA, 11­13 Apr 2011. PMLR. URL http://proceedings.mlr.press/v15/ross11a.html.
John Schulman, Sergey Levine, Pieter Abbeel, Michael Jordan, and Philipp Moritz. Trust region policy optimization. In Proceedings of the 32nd International Conference on Machine Learning (ICML-15), pp. 1889­1897, 2015.
John Schulman, Filip Wolski, Prafulla Dhariwal, Alec Radford, and Oleg Klimov. Proximal policy optimization algorithms. arXiv preprint arXiv:1707.06347, 2017.
Amr Sharaf and Hal Daume´, III. Structured prediction via learning to search under bandit feedback. In Proceedings of the 2nd Workshop on Structured Prediction for Natural Language Processing, pp. 17­26, Copenhagen, Denmark, September 2017. Association for Computational Linguistics. URL http://www.aclweb.org/anthology/W17-4304.
Artem Sokolov, Julia Kreutzer, Christopher Lo, and Stefan Riezler. Learning structured predictors from bandit feedback for interactive NLP. In Proceedings of the 54th Annual Meeting of the Association for Computational Linguistics (Volume 1: Long Papers). Association for Computational Linguistics (ACL), 2016. doi: 10.18653/v1/p16-1152. URL http://dx.doi.org/10.18653/ v1/P16-1152.
Richard S. Sutton and Andrew G. Barto. Introduction to Reinforcement Learning. MIT Press, Cambridge, MA, USA, 1st edition, 1998. ISBN 0262193981.
Vasilis Syrgkanis, Haipeng Luo, Akshay Krishnamurthy, and Robert E Schapire. Improved regret bounds for oracle-based adversarial contextual bandits. In D. D. Lee, M. Sugiyama, U. V. Luxburg, I. Guyon, and R. Garnett (eds.), Advances in Neural Information Processing Systems 29, pp. 3135­3143. Curran Associates, Inc., 2016. URL http://papers.nips.cc/paper/ 6400-improved-regret-bounds-for-oracle-based-adversarial-contextual-bandits. pdf.
Tijmen Tieleman and Geoffrey Hinton. Lecture 6.5-rmsprop: Divide the gradient by a running average of its recent magnitude. COURSERA: Neural networks for machine learning, 4(2):26­ 31, 2012.
Ronald J. Williams. Simple statistical gradient-following algorithms for connectionist reinforcement learning. Mach. Learn., 8(3-4):229­256, May 1992. ISSN 0885-6125. doi: 10.1007/ BF00992696. URL https://doi.org/10.1007/BF00992696.
Sam Wiseman and Alexander M. Rush. Sequence-to-sequence learning as beam-search optimization. In Proceedings of the 2016 Conference on Empirical Methods in Natural Language Processing, pp. 1296­1306, Austin, Texas, November 2016. Association for Computational Linguistics. URL https://aclweb.org/anthology/D16-1137.
Fei Xia. The part-of-speech tagging guidelines for the penn chinese treebank (3.0). Technical Report, 2000.
Naiwen Xue, Fei Xia, Fu-Dong Chiou, and Marta Palmer. The penn chinese treebank: Phrase structure annotation of a large corpus. Natural language engineering, 11(2):207­238, 2005.
13

Under review as a conference paper at ICLR 2018

A MORE DETAILS ON CONTEXTUAL BANDIT ALGORITHMS

We assume that contexts are chosen i.i.d from an unknown distribution D(x), the actions are chosen from a finite action set A, and the distribution over loss D( |a, x) is fixed over time, but is unknown. In this context, the key challenge in contextual bandit learning is the exploration/exploitation problem. Classic algorithms for the contextual bandit problem such as EXP4.P (Beygelzimer et al., 2011) can achieve a T regret bound; in particular:

R (EXP4)  O T K log ||

(2)

where K = |A|. When the regret is provably sublinear in T , such algorithms are often called "no regret" because their average regret per time step goes to zero as T  .
The particular contextual bandit algorithms we will use in this paper perform a second level of reduction: they assume access to an oracle supervised learning algorithm that can optimize a costsensitive loss, and transform the contextual bandit problem to a cost-sensitive classification problem. Algorithms in this family typically vary along two axes:

1. How to explore? I.e., faced with a new x how does the algorithm choose which action to take;
2. How to update? Given the observed loss t, how does the algorithm construct a supervised training example on which to train.

As a simple example, an algorithm might explore uniformly at random on 10% of the examples and

return the best guess action on 90% of examples ( -greedy exploration). A single round to such

an algorithm consists of a tuple (x, a, p), where p is the probability with which the algorithm took

action

a.

(In

the

current example,

this

would

be

0.1 K

for

all

actions except

(x) and

0.9 +

0.1 K

for

a = (x).) If the update rule were "inverse propensity scaling" (IPS) (Horvitz & Thompson, 1952),

the generated cost-sensitive learning example would have x as an input, and a cost vector c  RK

with zeros everywhere except in position a where it would take value p . The justification for this scaling is that in expectation over a  p, the expected value of this cost vector is equal to the true

costs for each action. Neither of these choices is optimal (IPS has very high variance as p gets

small); we discuss alternative exploration strategies and variance reduction strategies (§3.2).

B BANDIT STRUCTURED PREDICTION
Recently, it has become popular to solve structured prediction problems incrementally using some form of recurrent neural network (RNN) model. When the output y contains multiple parts (e.g., words in a translation), the RNN can predict each word in sequence, conditioning each prediction on all previous decisions. Although typically such models are trained to maximize cross-entropy with the gold standard output (in a fully supervised setting), there is mounting evidence that this has similar drawbacks to pre-RNN techniques, such as overfitting to gold standard prefixes (the model never learns what to do once it has made an error) and sensitivity to errors of different severity (due to error compounding).
By casting the structured prediction problem explicitly a sequential decision making problem (Daume´ & Marcu, 2005; Daume´ et al., 2009; Ross et al., 2011; Neu & Szepesva´ri, 2009) by, we can avoid these problems by applying imitation-learning style algorithms to their solution. This "Learning to Search" framework (Figure 5) solves structured prediction problems by:
1. converting structured and control problems to search problems by defining a search space of states S and an action set A;
2. defining structured features over each state to capture the inter-dependency between output variables;
3. constructing a reference policy ref based on the supervised training data; 4. learning a policy learn that imitates or improves upon the reference policy.
In the bandit structured prediction setting, this maps nicely to the type of MDPs described at the beginning of this section. The formal reduction, following (Daume´ & Marcu, 2005) is to ignore the

14

Under review as a conference paper at ICLR 2018

Figure 5: An example for a search space defined by a Learning to Search (L2S) algorithm. A search
space is defined in terms of the set of states X , and the set of action A. The agent starts at the initial state S, and queries the roll-in policy in twice, next, at state R, the agent considers all three actions as possible one-step deviations. The agent queries the roll-out policy out to generate three different
trajectories from the set of possible output structures Y.

first action a0 and to transition to an "initial state" s1 by drawing an input xSP  DX . The search space of the structured prediction task then generates the remainder of the state/action space for this
example. The episode terminates when a state, sH that corresponds to a "final output" is reached, at which point the structured prediction loss (y^sH | xSP) is computed on the output that corresponds to sH . This then becomes the loss function L in the MDP. Clearly, learning a good policy under this MDP is equivalent to learning a structured prediction model with low expected loss.

C COST-SENSITIVE CLASSIFICATION
Many of the contextual bandit approaches we use in turn reduce the contextual bandit problem to a cost-sensitive classification problem. Cost-sensitive classification problems are defined by inputs x and cost vectors y  RK, where y(i) is the cost of choosing class i on this example. The goal in cost-sensitive classification is to learn a classifier f : x  [K] such that E(x,y)D y(f (x)) is small. A standard strategy for solving cost-sensitive classification is via reduction to regression in a one-against-all framework (Beygelzimer et al., 2005). Here, a regression function g(x, i)  R is learned that predicts costs given input/class pairs. A predicted class on an input x is chosen as argmini g(x, i). This cost-sensitive one-against-all approach achieves low regret when the underlying regressor is good. In practice, we use regression against Huber loss.

D PROOF OF THEOREM 1

In a now-classic lemma, (Kakade et al., 2003; Bagnell et al., 2004) show that the difference in total loss between two policies can be computed exactly as a sum of per-time-step advantages of one over the other:
Lemma 1 ((Bagnell et al., 2004; Kakade et al., 2003)). For all policies  and  :

H
J () - J ( ) = Eshdh Q (sh, ) - V  (sh)
h=1

(3)

Theorem 1. Let n be the nth learned policy and ¯ be the average learned policy. We wish to bound J(¯) - J(). We proceed as follows, largely following the AggreVaTe analysis (Ross & Bagnell,

15

Under review as a conference paper at ICLR 2018

2014). We begin by noting that J(¯) - J() = J(¯) - J(ref) + J(ref) - J() and will concern ourselves with bounding the first difference.

J (¯) - J (ref) = En

Esdhn Qref (s, n) - Qref (s, ref)

h

Fix an n, and consider the sum above for a fixed deviation time step hdev:

(4)

Esdhn Qref (s, n) - Qref (s, ref)
h


(5) 

=Esdhdnev Qref (s, n) - Qref (s, ref) -

Es dhn

h=hdev

Qref (s , n) - Qref (s , ref)  (6)





=Esdhdnev Qref (s, n) - EsH ref | sh=s (sH ) -

Es dhn Aref(s , n)

h=hdev

(7)

where Aref(s , n) = Qref (s , n) - Qref (s , ref) is the policy (dis)advantage. The term in the round parentheses (. . . ) is exactly the expected value of the target of the contextual bandit cost;
therefore:

Regret(¯)  Regret(ref) + 1 N

CB(N )

(8)

If the CB algorithm has regret sublinear in N , the second term goes to zero as N  .

E PROOF OF THEOREM 2

Proof. The proof follows a combination of the above analysis with the LOLS analysis. Using the same notation as before, additionally let nout be the mixture of n with ref for rollout.
First, we observe (LOLS Eq 6):

J (¯) - J (ref) = En

Esdhn [Qref (s, n) - Qref (s, ref)]

h

(9)

Then (LOLS Eq 7):

J

(¯)

-

min


Esdh¯

Q¯

(s,

)

 En

Esdhn

Qn (s, n) - min Qn (s, a)
a

hh

(10)

So far nothing has changed. It will be convenient to define Qn (s) =  mina Qref (s, a) + (1 -
) mina Qn (s, a). For each n fix the deviation time step hdnev. We plug these together ala LOLS and get:



J (¯) - J (ref)

+ (1 - )

J

(¯)

-

min


Esdh¯

Q¯

(s,

)

(11)

En

Esdhn

Qnout (s, n) -  min Qref (s, a) - (1 - ) min Qn (s, a)
aa

h

(12)

=En

Esdhn Qnout (s, n) - Qn (s)

h



(13) 

=E En sdevdhndnev Qnout (sdev, n) - Qn (sdev) - h=hndev Eshdhn

Qnout (sh, n) - Qn (sh)  (14)

16

Under review as a conference paper at ICLR 2018

(a) Blackjack

(b) Hex

(c) Cart Pole

Figure 6: Reinforcement Learning Tasks

(d) Grid World





=E En sdevdhdnev Qnout (sdev, n) - EsH dHn | shndev =sdev Ln(sH ) -

CB.COST(n, sh)

h=hdev

(15)

1

= N

CB(N )

(16)

The penultimate step follows because the inner-most expectation is exactly what the contextual bandit algorithm is estimating, and Qn (sdev) is exactly the expectation of the observed loss The final step follows because the costs observed by the CB algorithm are exactly those in (. . . ), and so if the CB algorithm is no-regret, then it follows that RESLOPE is also no-regret.

F DETAILS ON REINFORCEMENT LEARNING ENVIRONMENTS
Blackjack is a card game where the goal is to obtain cards that sum to as near as possible to 21 without going over. Players play against a fixed dealer who hits until they have at least 17. Face cards (Jack, Queen, King) have a point value of 10. Aces can either count as 11 or 1, and a card is called "usable" at 11. The reward for winning is +1, drawing is 0, and losing is -1. The world is partially visible: the player can see one their own cards and one of the two initial dealer cards.
Hex is a classic two-player board game invented by Piet Hein and independently by John Nash (Hayward & Van Rijswijck, 2006; Nash, 1952). The board is an n×n rhombus of hexagonal cells. Players alternately place a stone of their color on any empty cell. To win, a player connects her two opposing sides with her stones. We use n = 5; the world is fully visible to the agent, with each hexagon showing as unoccupied, occupied with white or occupied with black. The reward is +1 for winning and -1 for losing.
Cart Pole is a classic control problem variously referred to as the "cart-pole", "inverted pendulum", or "pole balancing" problem (Barto et al., 1983). Is is an example of an inherently unstable dynamic system, in which the objective is to control translational forces that position a cart at the center of a finite width track while simultaneously balancing a pole hinged on the cart's top. In this task, a pole is attached by a joint to a cart which moves along a frictionless track (Figure 6c). The system is controlled by applying a force of +1 or -1 to the cart, thus, we operate in a discrete action space with only two actions. The pendulum starts upright, and the goal is to prevent it from falling over. The episode ends when the pole is more than 15 degrees from the vertical axis, or the cart moves more than 2.4 units from the center. The state is represented by four values indicating the poles position, angle to the vertical axis, and the linear and angular velocities. The total cumulative reward at the end of the episode is the total number of time steps the pole remained upright before the episode terminates.
Grid World consists of a simple 3×4 grid, with a +1 reward in the upper-right corner and -1 reward immediately below it; the cell at (1, 1) is blocked (Figure 6d). The agent starts at a random unoccupied square. Each step costs 0.05 and the agent has a 10% chance of misstepping. The agent only gets partial visibility of the world: it gets an indicator feature specifying which directions it can step. The only reward observed is the complete sum of rewards over an episode.

17

Under review as a conference paper at ICLR 2018

Chinese POS English POS

NT NN NN NN NN AD
(this year) (global) (mobile) (market) (size) (will) . . .

NNP NNP , CD NNS JJ , MD VB DT NN IN DT

JJ

NN

Pierre Vinken , 61 years old , will join the board as a nonexecutive director . . .

Parsing

Root Flying planes

can

be dangerous

Figure 7: Example inputs for part of speech tagging and dependency parsing.

G STRUCTURED PREDICTION DATA SETS
English POS Tagging we conduct POS tagging experiments over the 45 Penn Treebank (Marcus et al., 1993) tags. We simulate a domain adaptation setting by training a reference policy on the TweetNLP dataset (Owoputi et al., 2013) which achieves good accuracy in domain, but performs badly out of domain. We simulate bandit episodic loss over the entire Penn Treebank Wall Street Journal (sections 02  21 and 23), comprising 42k sentences and about one million words. The measure of performance is the average Hamming loss. We define the search space by sequentially selecting greedy part-of-speech tags for words in the sentence from left to right.
Chinese POS Tagging we conduct POS tagging experiments over the Chinese Penn Treebank (3.0) (Xia, 2000) tags. We simulate a domain adaptation setting by training a reference policy on the Newswire domain from the Chinese Treebank Dataset (Xue et al., 2005) and simulate bandit episodic feedback from the spoken conversation domain. We simulate bandit episodic loss over 40k sentences and about 300k words. The measure of performance is the average Hamming loss. We define the search space by sequentially selecting greedy part-of-speech tags for words in the sentence from left to right.
English Dependency Parsing For this task, we assign a grammatical head (i.e. parent) for each word in the sentence. We train an arc-eager dependency parser (Nivre, 2003) which chooses among (at most) four actions at each state: Shift, Reduce, Left or Right. The reference policy is trained on the TweetNLP dataset and evaluated on the Penn Treebank corpus. The loss is the unlabeled attachment score (UAS), which measures the fraction of words that are assigned the correct parent.
In all structured prediction settings, the feature representation begins with pretrained (and nonupdated) embeddings. For English, these are the 6gb Glove embeddings (Pennington et al., 2014); for Chinese, these are the FastText embeddings (Joulin et al., 2016). We then run a bidirectional LSTM (Hochreiter & Schmidhuber, 1997) over the input sentence. The input features for labeling the nth word in POS tagging experiments are the biLSTM representations at position n. The input features for dependency actions are a concatenation of the biLSTM features of the next word on the buffer and the two words on the top of the stack.
H OPTIMIZATION, HYPERPARAMETER SELECTION AND "TRICKS"
We optimize all parameters of the model using the Adam5 optimizer (Kingma & Ba, 2014), with a tuned learning rate, a moving average rate for the mean of 1 = 0.9 and for the variance of 2 = 0.999; epsilon (for numerical stability) is fixed at 1e - 8 (these are the DyNet defaults). The learning rate is tuned in the range {0.050.01, 0.005, 0.001, 0.0005, 0.0001}.
For the structured prediction experiments, the following input features hyperparameters are tuned:
· Word embedding dimension  {50, 100, 200, 300} (for the Chinese embeddings, which come only in 300 dimensional versions, we took the top singular vectors to reduce the dimensionality).
5We initially experimented also with RMSProp (Tieleman & Hinton, 2012) and AdaGrad (Duchi et al., 2011) but Adam consistently performed as well or better than the others on all tasks.
18

Under review as a conference paper at ICLR 2018
· BiLSTM dimension  {50, 150, 300} · Number of BiLSTM layers  {1, 2} · Pretraining: DAgger or AggreVaTe initialization with probability of rolling in with the
reference policy  {0.0, 0.999N , 0.99999N , 1.0}, where N is the number of examples · Policy RNN dimension  {50, 150, 300} · Number of policy layers  {1, 2}
For each task, the network architecture that was optimal for supervised pretraining was fixed and used for all bandit learning experiments6.
For the reinforcement learning experiments, we tuned:
· Policy RNN dimension  {20, 50, 100} · Number of policy layers  {1, 2}
Some parameters we do not tune: the nonlinearities used, the size of the action embeddings (we use 10 in all cases), the input RNN form for the text experiments (we always use LSTM instead of RNN or GRU based on preliminary experiments). We do not regularize our models (weight shrinkage only reduced performance in initial experiments) nor do we use dropout. Pretraining of the structured prediction models ran for 20 passes over the data with early stopping based on held-out loss. The state of the optimizer was reset once bandit learning began.
The variance across difference configurations was relatively small across RL tasks, so we chose a two layer policy with 20 dimensional vectors for all RL tasks.
Each algorithm also has a set of hyperparameters; we tune them as below:
· Reinforce: with baseline or without baseline · A2C: a multiplier on the relative importance of actor loss and critic loss 
{0.1, 0.2, 0.5, 1.0, 2.0, 5.0, 10.0} · PPO: with baseline or without baseline; and epsilon parameter 
{0.01, 0.05, 0.1, 0.2, 0.4, 0.8} · RESLOPE: update strategy (IPS, DR, MTR) and exploration strategy (uniform, Boltzmann
or Bootstrap)
In each reinforcement/bandit experiment, we optimistically pick algorithm hyperparameters and learning rate based on final evaluation criteria, noting that this likely provides unrealistically optimistic performance for all algorithms. We perform 100 replicates of every experiment in the RL setting and 20 replicates in the structured prediction setting. We additionally ablate various aspects of RESLOPE in §5.2.
We employ only two "tricks," both of which are defaults in dynet: gradient clipping (using the default dynet settings) and smart parameter initialization (dynet uses Glorot initialization (Glorot & Bengio, 2010)).
I EFFECT OF SINGLE VS MULTIPLE DEVIATIONS
Next, we consider the single-deviation version of RESLOPE (1) versus the multiple-deviation version (2). To enable comparison with alternative algorithms, we also experiment with variants of Reinforce, PPO and DAgger that are only allowed single deviations as well (also chosen uniformly at random). The results are shown in Figure 9. Not surprisingly, all algorithms suffer when only allowed single deviations. PPO makes things worse over time (likely because its updates are very conservative, such that even in the original PPO paper the authors advocate multiple runs over the same data), as does Reinforce. DAgger still learns, though more slowly, when only allowed a single
6English POS tagging and dependency parsing: DAgger 0.99999N , 300 dim embeddings, 300 dim 1 layer LSTM, 2 layer 300 dimensional policy; Chinese POS tagging: DAgger 0.999N , 300 dim embeddings, 50 dim 2 layer LSTM, 1 layer 50 dimensional policy).
19

Under review as a conference paper at ICLR 2018

AveornatgreaiLnoss

AveornagdeeLvoss

14 12 10 8 6 4 2
101 12
10
8
6
4
2 101

English POS
N1u0m2ber of e1x0a3mples 104 N1u0m2ber of e1x0a3mples 104

English Parsing
14

12

10

8 6 4 2
101

Reslope-Bootstrap Reslope-Boltzmann Advantage Actor-Critic Reinforce w/ baseline Prox. Policy Optimization DAgger
N1u0m2ber of e1x0a3mples 104

18 16 14 12 10 8 6 4 2
101

N1u0m2ber of e1x0a3mples 104

5
4
3
2
1 101
2.50 2.25 2.00 1.75 1.50 1.25 1.00
101

Chinese POS
N1u0m2 ber of1e0x3ample1s04 N1u0m2 ber of1e0x3ample1s04

105 105

Figure 8: Average loss (top) and heldout loss (bottom) during learning for three bandit structured prediction problems. Also included are supervised learning results with DAgger. The main difference between the training loss and the development loss is that in the development data, the system needn't explore, and so the gaps in algorithms which explore different amounts (e.g., especially on English POS tagging) disappear.

total loss loss std
 MTR  IPS
 Boltzmann  Uniform
­ g-predict ­ g-update

Reinforcement Learning

Blackjack Cartpole Grid

Hex

0.17 -28.0 0.021 23.0

0.69 -0.88 0.74 0.008

-1.55 -1.81

-0.105 -0.783 0.77 -0.28

2.88 0.427

2.85 10.8

0.263 0.28

0.184 54.8 0.566 104.0

-0.638 1.03

0.362 -0.31 -0.151

0.508 -0.158

2.24

Zh-POS
1.8 0.019
0.023 282.0
275.0 285.0
0.236 7.11

Bandit SP En-Dep
6.3 0.58
1.56 13.2
14.1 16.1
0.314 3.87

En-POS
7.3 0.77
0.661 17.6
18.3 13.8
0.596 2.79

Table 1: Results of ablating various parts of the RESIDUAL LOSS PREDICTION approach. Columns are tasks. The first two rows are the cumulative average loss over multiple runs and its standard deviation. The numbers in the rest of the column measure how much it hurts (positive number) or helps (negative number) to ablate the corresponding parameter. To keep the numbers on a similar scale, the changes are reported as multiples of the standard deviation. So a value of 2.0 means that the cumulative loss gets worse by an additive factor of two standard deviations.

deviation. RESLOPE behaves similarly though not quite as poorly. Overall, this suggests that even though the samples generated with multiple deviations by RESLOPE are no longer independent, the gain in number of samples more than makes up for this.
20

AveornatgreaiLnoss

Under

review

aEsngalischoPnOSference

paper

at
18

ICLR

20En1g8lish

Parsing

20.0

16

17.5 14

15.0 12

12.5 10.0 7.5

10 Reslope 1-dev

8

Reslope Reinforce 1-dev

6 Reinforce

5.0

PPO 1-dev 4 PPO

2.5

DAgger 1-dev 2 DAgger

101 1N0u2mber of e1x0am3 ples 104

101 1N0u2mber of e1x0am3 ples

104

8 6 4 2
101

Chinese POS
10N2umber of1e0x3amples 104

Figure 9: The empirical effect of multiple deviations for different algorithms.

105

J SYNTHETIC DATA FOR EVALUATING THE LEARNED LOSS REPRESENTATION
Experiments were conducted on a synthetic sequence labeling dataset. Input sequences are random integers (between one and ten) of length 6. The ground truth label for the hth word is the corresponding input mod 4. We generate 16k training sequences for this experiment. We run RESLOPE with bootstrap sampling in multiple deviation mode. We use the MTR cost estimator, and optimize the policies using ADAM with a learning rate of 0.01.

21

